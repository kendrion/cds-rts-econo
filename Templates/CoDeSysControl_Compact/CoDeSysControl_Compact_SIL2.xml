<documentation>
<filename>CoDeSysControl_Compact_SIL2.pdf</filename>
<docversion>3.4.2.0</docversion>
<projectdesc>CoDeSysControl Compact for SIL2</projectdesc>
<component>
<name>CmpMgr</name>
<description>
This implementation of the component manager is used typically in environments with
the possibility to load and unload components dynamically. But the components must not
loaded dynamically, they can be linked static too.
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<p><h1>Compiler Switch</h1></p>
<ul>
<li>
<csdef>#define EXTERNAL_LIB_PACKMODE</csdef>
<csdesc>Define the alignment of the CODESYS Compiler:</csdesc>
<p></p>
</li>
<li>
<csdef>#define STATIC_LINK</csdef>
<csdesc>All components are linked statically to the component manager during compile time.</csdesc>
<p></p>
</li>
<li>
<csdef>#define MIXED_LINK</csdef>
<csdesc>All components are linked static, but can be extended by dynamically linked components.</csdesc>
<p></p>
</li>
<li>
<csdef>#define DYNAMIC_LINK</csdef>
<csdesc>[Default] All components exists as separate compiled modules. So this modules can be loaded dynamically.</csdesc>
<p></p>
</li>
<li>
<csdef>#define CPLUSPLUS</csdef>
<csdesc>All components are linked together via C++ classes.</csdesc>
<p></p>
</li>
<li>
<csdef>#define CM_SYSTARGET_DISABLE_OVERLOADABLE_FUNCTIONS</csdef>
<csdesc>Switch to disable the possibility to overload the SysTarget functions</csdesc>
<p></p>
</li>
<li>
<csdef>#define CM_DISABLE_API_SIGNATURE_CHECK</csdef>
<csdesc>Switch to disable the signature check of all api functions</csdesc>
<p></p>
</li>
<li>
<csdef>#define CM_DISABLE_API_VERSION_CHECK</csdef>
<csdesc>Switch to disable the version check of all api functions</csdesc>
<p></p>
</li>
<li>
<csdef>#define CM_NO_EXIT</csdef>
<csdesc>Switch to disable definite exit or shutdown process of the runtime system</csdesc>
<p></p>
</li>
<li>
<csdef>#define CM_NO_DYNAMIC_COMPONENTS</csdef>
<csdesc>Switch to disable dynamic loadable components</csdesc>
<p></p>
</li>
</ul>
<element interface="1" name="CMItf">
<interfacename>CmpMgr</interfacename>
<description>
<p>Interface of the component manager</p>
<p>The component manager component is the central component of the runtime system.
The component manager is responsible for:</p>
<ul>
<li>startup and shutdown of the runtime system</li>
<li>loading and unloading all components</li>
<li>intializing all components</li>
<li>linking all functions, including the external IEC library functions</li>
<li>checking the consistency of calling a function (matching function prototypes)</li>
</ul>
<p>The list of components that should be loaded can be specified in different ways.</p>
<p>If the components are linked static, there are two different ways to specify the component list:</p>
<ul>
<li>Static list: The list of static loaded components can be specified as a calling option for the CMInit()
interface method. The name of the component on the entry funtion of each component must be specified.
See the description of the CMInit() method for detailed information.</li>
<li>Settings: The settings component has a settings interface, where the component list can be specified.
Here only the component name must be specified. In this case, the function MainLoadComponent() must be
impleemnted in the Main module and here all static linked components must be added to the list. The advantage
of this method is that in the settings you can specify, which static component can be loaded or not. This
is quite flexible.</li>
</ul>
<p>For dynamically linked components, the component list can only be specified in the settings component.</p>
<p>External IEC library functions are managed by the component manager too. Each interface have to specify,
if it could be used for IEC code or not in the m4 Interface definition.</p>

<p>An additional feature is the possibility to use all components with a C++ interface. Here you can implement
your own component in C++ and can use all other runtime components object oriented with a C++ interface.</p>
</description>

<copyright>(c) 2003-2011 3S-Smart Software Solutions</copyright>
<element define="1">
<name>MAX_COMPONENT_NAME</name>
<key>32</key>
<category>Static defines</category>
<description>Maximum length of component name</description>
</element>
<element define="1">
<name>MAX_API_NAME</name>
<key>64</key>
<category>Static defines</category>
<description>Maximum length of api function name</description>
</element>
<element define="1">
<name>CM_API_VERSION_CHECK_MASK</name>
<key>UINT32_C</key>
<condition>CM_API_VERSION_CHECK_MASK</condition>
<category>Static defines</category>
<description>
Significant mask to check different versions of an api function. If the significant
parts of the version don't match, the api versions don't match!
</description>
</element>
<element define="1">
<name>CM_API_VERSION_CHECK_MINIMUM</name>
<key>UINT32_C</key>
<condition>CM_API_VERSION_CHECK_MINIMUM</condition>
<category>Static defines</category>
<description>
Specifies the minimum supported version of all api functions.
</description>
</element>
<element define="1">
<name>CM_EXTLIB_API_VERSION_CHECK_MASK</name>
<key>UINT32_C</key>
<condition>CM_EXTLIB_API_VERSION_CHECK_MASK</condition>
<category>Static defines</category>
<description>
Significant mask to check different versions of an external library api function. If the significant
parts of the version don't match, the api versions don't match!
</description>
</element>
<element define="1">
<name>CM_EXTLIB_API_VERSION_CHECK_MINIMUM</name>
<key>UINT32_C</key>
<condition>CM_EXTLIB_API_VERSION_CHECK_MINIMUM</condition>
<category>Static defines</category>
<description>
Specifies the minimum supported version of all external library api functions.
</description>
</element>
<element define="1">
<name>EVT_CmpMgr_PrepareShutdown</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent before shutdown of the runtime system</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpMgr_Shutdown</param>
</element>
<element define="1">
<name>EVT_CmpMgr_PrepareExitComm</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent before exit the communication servers during shutdown</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpMgr_Shutdown</param>
</element>
<element define="1">
<name>EVT_CmpMgr_PrepareExitTasks</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent before exit all tasks during shutdown</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpMgr_Shutdown</param>
</element>
<element define="1">
<name>EVT_CmpMgr_Exit3</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent before exit of the runtime system during shutdown</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpMgr_Shutdown</param>
</element>
<element define="1">
<name>EVT_CmpMgr_PrepareExit</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent before exit of the runtime system during shutdown</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpMgr_Shutdown</param>
</element>
<element define="1">
<name>EVT_CmpMgr_Exit2</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent before exit of the runtime system during shutdown</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpMgr_Shutdown</param>
</element>
<element define="1">
<name>EVT_CmpMgr_DisableOperation</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent to disable operations. Each operation is defined in the corresponding Itf.h file of the component, which is specified by its ComponentID</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpMgr_DisableOperation</param>
</element>
<element define="1">
<name>RTS_CMINIT_OPTION_SETTINGSFILEISOPTIONAL</name>
<key>UINT32_C</key>
<category>CMInit options</category>
<element name="RTS_CMINIT_OPTION_SETTINGSFILEISOPTIONAL" type="IN">Specifies, if the Settingsfile is only used optional</element>
<element name="RTS_CMINIT_OPTION_DONTCALLINITHOOKS" type="IN">If this option is set, the CMInit sequence is stopped right after CH_INIT hook.
To finish the startup sequence, you have to call CMInitEnd() afterwards.
This can be used, if you have to do things first before before all other components, but you need here the runtime system components.
</element>
</element>
<element define="1">
<name>CMPTYPE_STANDARD</name>
<key>UINT16_C</key>
<category>ComponentType</category>
<description>
A component can only be a member of type CMPTYPE_STANDARD or type CMPTYPE_SAFETY.
To separate the components in detail, we use the types CMPTYPE_STATIC, CMPTYPE_DYNAMIC, CMPTYPE_SYSTEM or CMPTYPE_IEC.
</description>
<element name="CMPTYPE_STANDARD" type="IN">Standard component category</element>
<element name="CMPTYPE_SAFETY" type="IN">Safety component category</element>
<element name="CMPTYPE_ALL" type="IN">Can be used to select all components. Only a mask to select STANDARD and SAFETY.</element>
<element name="CMPTYPE_STATIC" type="IN">Static linked component</element>
<element name="CMPTYPE_DYNAMIC" type="IN">Dynamically linked component</element>
<element name="CMPTYPE_SYSTEM" type="IN">System component</element>
<element name="CMPTYPE_IEC" type="IN">IEC component (IEC code is registered as a component)</element>
</element>
<element define="1">
<name>RTS_CS_UNKNOWN</name>
<key>UINT16_C</key>
<category>ComponentState</category>
<element name="RTS_CS_UNKNOWN" type="IN">Unknown state</element>
<element name="RTS_CS_NOT_FOUND" type="IN">Not found to load</element>
<element name="RTS_CS_LOADED" type="IN">Component successfully loaded</element>
<element name="RTS_CS_DISABLED" type="IN">Component disabled in the configuration</element>
<element name="RTS_CS_INITIALIZED" type="IN">Component initialized</element>
<element name="RTS_CS_READY" type="IN">Component loaded and initialized and is ready to use</element>
<element name="RTS_CS_UNLOADED" type="IN">Component is unloaded</element>
</element>
<element define="1">
<name>CM_HOOK_TYPE_NORMAL</name>
<key>0</key>
<category>COMM_CYCLE_HOOK types</category>
<description>
<ul>
<li>CM_HOOK_TYPE_NORMAL: Cyclic call of COMM_CYCLE_HOOK </li>
<li>CM_HOOK_TYPE_FLASH_ACCESS: Additional call during flash accesses </li>
</ul>
</description>
</element>
<element define="1">
<name>CM_CNF_STATIC</name>
<key>0</key>
<category>ComponentNameFlags</category>
<description>
<ul>
<li>CM_CNF_STATIC: Name is stored in a static buffer</li>
<li>CM_CNF_DYNAMIC: Name is stored in a dynamic buffer</li>
</ul>
</description>
</element>
<element typedefinition="1">
<name>EVTPARAM_CmpMgr_Shutdown</name>
<structname>EVTPARAM_CmpMgr_Shutdown</structname>
<category>Event parameter</category>
<element name="pdummy" type="IN">dummy</element>
<rawdata>
typedef struct
{
	void* pdummy;
} EVTPARAM_CmpMgr_Shutdown;
</rawdata>
</element>
<element typedefinition="1">
<name>EVTPARAM_CmpMgr_DisableOperation</name>
<structname>EVTPARAM_CmpMgr_DisableOperation</structname>
<category>Event parameter</category>
<element name="cmpId" type="IN">ComponentID of the component, which operation should be disabled</element>
<element name="ulOperation" type="IN">Operation that can be disabled. See category "Operations" in Itf.h file of the corresponding component for details.</element>
<element name="cmpIdDisabled" type="IN">ComponentID of the source, which disabled the operation</element>
<element name="bDisable" type="IN">Must be set to 1 to disable the operation, else: do nothing and remain the value as it is!</element>
<rawdata>
typedef struct
{
	CMPID cmpId;
	RTS_UI32 ulOperation;
	CMPID cmpIdDisabled;
	RTS_I32 bDisable;
} EVTPARAM_CmpMgr_DisableOperation;
</rawdata>
</element>
<element typedefinition="1">
<name>LicenseFunctions</name>
<structname>LicenseFunctions</structname>
<description>LicenseFunctions</description>
<rawdata>
typedef struct tagLicenseFunctions
{
	RTS_IEC_DWORD dwStructSize;
	RTS_IEC_BYTE *pfGetUserLicenseValue;
	RTS_IEC_BYTE *pfConfDynLicChallenge;
	RTS_IEC_BYTE *pfReqDynLicChallenge;
	RTS_IEC_DWORD dwVersion;
} LicenseFunctions;
</rawdata>
</element>
<element typedefinition="1">
<name>cmaddcomponent_struct</name>
<structname>cmaddcomponent_struct</structname>
<description>cmaddcomponent</description>
<rawdata>
typedef struct tagcmaddcomponent_struct
{
	RTS_IEC_STRING *pszComponent;		VAR_INPUT
	RTS_IEC_UDINT udiCmpId;				VAR_INPUT
	RTS_IEC_UDINT udiVersion;			VAR_INPUT
	RTS_IEC_RESULT *pResult;			VAR_INPUT
	RTS_IEC_HANDLE CMAddComponent;		VAR_OUTPUT
} cmaddcomponent_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>cmexitcomponent_struct</name>
<structname>cmexitcomponent_struct</structname>
<description>cmexitcomponent</description>
<rawdata>
typedef struct tagcmexitcomponent_struct
{
	RTS_IEC_HANDLE hComponent;			VAR_INPUT
	RTS_IEC_RESULT CMExitComponent;		VAR_OUTPUT
} cmexitcomponent_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>cmremovecomponent_struct</name>
<structname>cmremovecomponent_struct</structname>
<description>cmremovecomponent</description>
<rawdata>
typedef struct tagcmremovecomponent_struct
{
	RTS_IEC_HANDLE hComponent;			VAR_INPUT
	RTS_IEC_RESULT CMRemoveComponent;	VAR_OUTPUT
} cmremovecomponent_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>cmregisterlicensefunctions_struct</name>
<structname>cmregisterlicensefunctions_struct</structname>
<description>cmregisterlicensefunctions</description>
<rawdata>
typedef struct tagcmregisterlicensefunctions_struct
{
	LicenseFunctions licenseFunctions;	VAR_INPUT
	RTS_IEC_RESULT CMRegisterLicenseFunctions;	VAR_OUTPUT
} cmregisterlicensefunctions_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>cmutlwstrcpy_struct</name>
<structname>cmutlwstrcpy_struct</structname>
<description>cmutlwstrcpy</description>
<rawdata>
typedef struct tagcmutlwstrcpy_struct
{
	RTS_IEC_WSTRING *pwszDest;			VAR_INPUT
	RTS_IEC_DINT nDestSize;				VAR_INPUT
	RTS_IEC_WSTRING *pwszSrc;			VAR_INPUT
	RTS_IEC_RESULT CMUtlwstrcpy;		VAR_OUTPUT
} cmutlwstrcpy_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>cmutlstricmp_struct</name>
<structname>cmutlstricmp_struct</structname>
<description>cmutlstricmp</description>
<rawdata>
typedef struct tagcmutlstricmp_struct
{
	RTS_IEC_STRING *pszString1;			VAR_INPUT
	RTS_IEC_STRING *pszString2;			VAR_INPUT
	RTS_IEC_DINT CMUtlStrICmp;			VAR_OUTPUT
} cmutlstricmp_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>cmunregistergetuserlicensevalue_struct</name>
<structname>cmunregistergetuserlicensevalue_struct</structname>
OBSOLETE FUNCTION: Use CMUnregisterLicenseFunctions instead
<rawdata>
typedef struct tagcmunregistergetuserlicensevalue_struct
{
	RTS_IEC_BYTE *pfGetUserLicenseValue;	VAR_INPUT
	RTS_IEC_RESULT CMUnregisterGetUserLicenseValue;	VAR_OUTPUT
} cmunregistergetuserlicensevalue_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>cmutlcwstrcpy_struct</name>
<structname>cmutlcwstrcpy_struct</structname>
<description>cmutlcwstrcpy</description>
<rawdata>
typedef struct tagcmutlcwstrcpy_struct
{
	RTS_IEC_CWCHAR *pcwszDest;			VAR_INPUT
	RTS_IEC_DINT nDestSize;				VAR_INPUT
	RTS_IEC_CWCHAR *pcwszSrc;			VAR_INPUT
	RTS_IEC_RESULT CMUtlcwstrcpy;		VAR_OUTPUT
} cmutlcwstrcpy_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>cmunregisterlicensefunctions_struct</name>
<structname>cmunregisterlicensefunctions_struct</structname>
<description>cmunregisterlicensefunctions</description>
<rawdata>
typedef struct tagcmunregisterlicensefunctions_struct
{
	LicenseFunctions licenseFunctions;	VAR_INPUT
	RTS_IEC_RESULT CMUnregisterLicenseFunctions;	VAR_OUTPUT
} cmunregisterlicensefunctions_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>cminitcomponent_struct</name>
<structname>cminitcomponent_struct</structname>
<description>cminitcomponent</description>
<rawdata>
typedef struct tagcminitcomponent_struct
{
	RTS_IEC_HANDLE hComponent;			VAR_INPUT
	RTS_IEC_RESULT CMInitComponent;		VAR_OUTPUT
} cminitcomponent_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>cmgetcomponentbyname_struct</name>
<structname>cmgetcomponentbyname_struct</structname>
<description>cmgetcomponentbyname</description>
<rawdata>
typedef struct tagcmgetcomponentbyname_struct
{
	RTS_IEC_STRING *pszComponent;		VAR_INPUT
	RTS_IEC_RESULT *pResult;			VAR_INPUT
	RTS_IEC_HANDLE CMGetComponentByName;	VAR_OUTPUT
} cmgetcomponentbyname_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>cmshutdown_struct</name>
<structname>cmshutdown_struct</structname>
<description>cmshutdown</description>
<rawdata>
typedef struct tagcmshutdown_struct
{
	RTS_IEC_UDINT dwReason;				VAR_INPUT
	RTS_IEC_RESULT CMShutDown;			VAR_OUTPUT
} cmshutdown_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>cmutlsafestrcpy_struct</name>
<structname>cmutlsafestrcpy_struct</structname>
<description>cmutlsafestrcpy</description>
<rawdata>
typedef struct tagcmutlsafestrcpy_struct
{
	RTS_IEC_STRING *pszDest;			VAR_INPUT
	RTS_IEC_DINT nDestSize;				VAR_INPUT
	RTS_IEC_STRING *pszSrc;				VAR_INPUT
	RTS_IEC_RESULT CMUtlSafeStrCpy;		VAR_OUTPUT
} cmutlsafestrcpy_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>cmregistergetuserlicensevalue_struct</name>
<structname>cmregistergetuserlicensevalue_struct</structname>
OBSOLETE FUNCTION: Use CMRegisterLicenseFunctions instead
<rawdata>
typedef struct tagcmregistergetuserlicensevalue_struct
{
	RTS_IEC_BYTE *pfGetUserLicenseValue;	VAR_INPUT
	RTS_IEC_RESULT CMRegisterGetUserLicenseValue;	VAR_OUTPUT
} cmregistergetuserlicensevalue_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>cmloadcomponent_struct</name>
<structname>cmloadcomponent_struct</structname>
/** EXTERN LIB SECTION END *
<rawdata>
typedef struct
{
	RTS_IEC_STRING *pszComponent;
	RTS_IEC_RESULT *pResult;
	RTS_IEC_HANDLE hComponent;
} cmloadcomponent_struct;
</rawdata>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char *pszSettingsFile, StaticComponent *pStaticComponents)">CMInit</functionname>
<description>
Called to initialize the component manager
</description>
<param name="pszSettingsFile" type="IN">Pointer to name of the configuration file</param>
<param name="pStaticComponents" type="IN">Pointer to list of components with name and entry routine to initialize without configuration</param>
<result>Error code:
<ul>
<li>ERR_OK</li>
<li>ERR_FAILED: One or more components failed to load</li>
<li>ERR_ID_MISMATCH: Signature mismatch of the SysTargetIDs</li>
</ul>
</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char *pszSettingsFile, StaticComponent *pStaticComponents, int bSettingsFileIsOptional)">CMInit2</functionname>
<description>
Called to initialize the component manager
</description>
<param name="pszSettingsFile" type="IN">Pointer to name of the configuration file</param>
<param name="pStaticComponents" type="IN">Pointer to list of components with name and entry routine to initialize without configuration</param>
<param name="bSettingsFileIsOptional" type="IN">Specifies, if the Settingsfile is only used optionally</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char *pszSettingsFile, StaticComponent *pStaticComponents, RTS_UI32 options)">CMInit3</functionname>
<description>
Called to initialize the component manager
</description>
<param name="pszSettingsFile" type="IN">Pointer to name of the configuration file</param>
<param name="pStaticComponents" type="IN">Pointer to list of components with name and entry routine to initialize without configuration</param>
<param name="options" type="IN">Options for the init sequence of the component manager. See category "CMInit options" for details.</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(void)">CMExit</functionname>
<description>
Called to deinitialize the component manager
</description>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(void)">CMSetExit</functionname>
<description>Set a flag for main loop to exit</description>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(void)">CMGetExit</functionname>
<description>Get a flag to exit main loop</description>
<result>ERR_OK, if exit flag is set
ERR_FAILED else</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(const char *szFormat, ...)">CMDebugOut</functionname>
<description>Can be used for debug outputs on a console.</description>
<result>ERR_OK or ERR_NOT_SUPPORTED, if SysOut component is not available</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(const char *szFormat, va_list *pargList)">CMDebugOutArg</functionname>
<description>Can be used for debug outputs on a console.</description>
<result>ERR_OK or ERR_NOT_SUPPORTED, if SysOut component is not available</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(const CMP_EXT_FUNCTION_REF *pExpTable, RTS_UINTPTR dummy, int bExternalLibrary, RTS_UI32 cmpId)">CMRegisterAPI</functionname>
<description>
Called to register a list of component API functions at the component manager
</description>
<param name="pExpTable" type="IN">Table of functions to be registered</param>
<param name="CmpId" type="IN">Component identifier</param>
<param name="bExternalLibrary" type="IN">Can be used as external library in the plc program</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(const char *pszAPIName, RTS_VOID_FCTPTR pfAPIFunction, int bExternalLibrary, RTS_UI32 ulSignatureID, RTS_UI32 ulVersion)">CMRegisterAPI2</functionname>
<description>
Called to register a component API function at the component manager
</description>
<param name="pszAPIName" type="IN">Name of the API routine</param>
<param name="pfAPIFunction" type="IN">Function pointer of the API routine</param>
<param name="bExternalLibrary" type="IN">Can be used as external library in the plc program</param>
<param name="ulSignatureID" type="IN">SignatureID of the function prototype</param>
<param name="ulVersion" type="IN">Actual supported implementation version</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char *pszAPIName, RTS_VOID_FCTPTR *ppfAPIFunction, int importOptions, RTS_UI32 *pulSignatureID, RTS_UI32 *pulVersion)">CMGetAPI3</functionname>
<description>
Called to get an API function of another component
</description>
<param name="pszAPIName" type="IN">Name of the API routine</param>
<param name="ppfAPIFunction" type="OUT">Returned the function pointer of the API routine</param>
<param name="pulSignatureID" type="INOUT">SignatureID of the function prototype requested and returns the actual signature implemented</param>
<param name="pulVersion" type="INOUT">Implementation version requested and returns the actual version implemented</param>
<param name="importOptions" type="IN">Import options. See CM_IMPORT_xx defines in CmpStd.h for details</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_VOID_FCTPTR pfAPIFunction)">CMReleaseAPI</functionname>
<description>
Called to release an API function of another component
</description>
<param name="pfAPIFunction" type="IN"></param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(char *pszComponent, RTS_RESULT *pResult)">CMLoadComponent</functionname>
<description>
Called to load a component. Can also be called during runtime.
ATTENTION: If component has references to other components, referenced components must be loaded first!
</description>
<param name="pszComponent" type="IN">Name of the component</param>
<param name="pResult" type="INOUT">Pointer to error code</param>
<result>Component handle or RTS_INVALID_HANDLE, if an error is occured</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hComponent)">CMInitComponent</functionname>
<description>
Called to initialize a component after it was loaded during runtime.
</description>
<param name="hComponent" type="IN">Handle of the component</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hComponent)">CMExitComponent</functionname>
<description>
Called to exit a component after it was loaded during runtime. After this it can be unloaded,
if no other components references this component
</description>
<param name="hComponent" type="IN">Handle of the component</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hComponent)">CMUnloadComponent</functionname>
<description>
Called to unload a component. Can also be called during runtime.
ATTENTION: CMExitComponent must be called before unloading the component!
</description>
<param name="hComponent" type="IN">Handle of the component</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(COMPONENT_ENTRY *pComponent, RTS_RESULT *pResult)">CMAddComponent</functionname>
<description>
Add a component to the list
</description>
<param name="pComponent" type="IN">Pointer to component description</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>returns a handle to the component</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hComponent)">CMRemoveComponent</functionname>
<description>
Remove a component from the list
</description>
<param name="hComponent" type="IN">Handle to the component</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(char *pszCmpName, RTS_RESULT *pResult)">CMGetComponentByName</functionname>
<description>
Get the component handle of a component specified by name.
</description>
<param name="pszCmpName" type="IN">Name of the component</param>
<param name="pResult" type="INOUT">Pointer to error code</param>
<result>Component handle or RTS_INVALID_HANDLE, if an error is occured</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char *pszCmpName, CMPID *pCmpId)">CMGetCmpId</functionname>
<description>
Get the component id of a component specified by name.
A component id always consists of the unique vendor id as high word and the specific component id
as low word. So each component can be assigned to the specific vendor.
</description>
<param name="pszCmpName" type="IN">Name of the component</param>
<param name="pCmpId" type="OUT">Component id</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(CMPID CmpId, char *pszCmpName, int iMaxCmpName)">CMGetCmpName</functionname>
<description>
Get the component name of a component specified by the component id.
</description>
<param name="pCmpId" type="IN">Component id</param>
<param name="pszCmpName" type="OUT">Name of the component</param>
<param name="iMaxCmpName" type="IN">Max length of the component name buffer</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="COMPONENT_ENTRY*" parameters="(CMPID CmpId)">CMGetComponent</functionname>
<description>
Get the component description of a component specified by the component id.
</description>
<param name="pCmpId" type="IN">Component id</param>
<result>Pointer to COMPONENT_ENTRY</result>
</element>
<element function="1">
<functionname returntype="int" parameters="(void)">CMGetNumOfComponents</functionname>
<description>
Returns the number of registered components
</description>
<result>Number of components</result>
</element>
<element function="1">
<functionname returntype="COMPONENT_ENTRY*" parameters="(int iIndex)">CMGetComponentByIndex</functionname>
<description>
Returns the registered component specified by index
</description>
<param name="iIndex" type="IN">Index of the component in the list</param>
<result>Pointer to component or NULL if index ist out of range</result>
</element>
<element function="1">
<functionname returntype="COMPONENT_ENTRY*" parameters="(RTS_RESULT *pResult)">CMGetFirstComponent</functionname>
<description>
Returns the first component entry
</description>
<param name="pResult" type="INOUT">Pointer to error code</param>
<result>Pointer to component or NULL if no component available</result>
</element>
<element function="1">
<functionname returntype="COMPONENT_ENTRY*" parameters="(COMPONENT_ENTRY *pCmp, RTS_RESULT *pResult)">CMGetNextComponent</functionname>
<description>
Returns the registered component specified by index
</description>
<param name="pCmp" type="IN">Pointer to the previous component</param>
<param name="pResult" type="INOUT">Pointer to error code</param>
<result>Pointer to component or NULL if end of list is reached</result>
</element>
<element function="1">
<functionname returntype="IBase*" parameters="(CLASSID ClassId, RTS_RESULT *pResult)">CMCreateInstance</functionname>
<description>
Create an instance of a specified class.
</description>
<param name="ClassId" type="IN">ClassId of the class to create an object</param>
<param name="pResult" type="OUT">Pointer to error code for result</param>
<result>Pointer to IBase interface of the object</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(IBase *pIBase)">CMDeleteInstance</functionname>
<description>
Delete an instance.
</description>
<param name="pIBase" type="IN">Pointer to IBase interface</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(CLASSID ClassId, IBase *pIBase)">CMDeleteInstance2</functionname>
<description>
Delete an instance.
</description>
<param name="ClassId" type="IN">ClassId of the instance</param>
<param name="pIBase" type="IN">Pointer to IBase interface</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="IBase*" parameters="(CLASSID ClassId, OBJID ObjId, RTS_RESULT *pResult)">CMGetInstance</functionname>
<description>
Get instance of a class.
</description>
<param name="ClassId" type="IN">ClassId of the class to create an object</param>
<param name="ObjId" type="IN">Index number of the instance</param>
<param name="pResult" type="OUT">Pointer to error code for result</param>
<result>Pointer to IBase interface of the object</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(CLASSID ClassId, OBJID ObjId, IBase *pIBase)">CMRegisterInstance</functionname>
<description>
Register an exisiting instance to the component manager.
</description>
<param name="ClassId" type="IN">ClassId of the class to create an object</param>
<param name="ObjId" type="IN">Index number of the instance</param>
<param name="pResult" type="OUT">Pointer to error code for result</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(IBase *pIBase)">CMUnregisterInstance</functionname>
<description>
Unregister an existing instance from component manager.
</description>
<param name="pIBase" type="IN">Pointer to IBase interface</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(ITFID ItfId, RTS_HANDLE hIBasePool)">CMGetInstanceList</functionname>
<description>
Get a list of instances, that implements the specified interface.
</description>
<param name="ItfId" type="IN">Id of the interface</param>
<param name="hIBasePool" type="INOUT">Must be a MemPool handle. All instances that implements the interface are
stored in this pool as result.</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_UI32 ulHook, RTS_UINTPTR ulParam1, RTS_UINTPTR ulParam2, int bReverse)">CMCallHook</functionname>
<description>
Called to call all components with the specified hook
</description>
<param name="ulHook" type="IN">Hook (for definition, look into CmpItf.h)</param>
<param name="ulParam1" type="IN">First parameter. Hook dependant</param>
<param name="ulParam2" type="IN">Second parameter. Hook dependant</param>
<param name="bReverse" type="IN">Called the components in the opposite order as they were loaded</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_UI16 usComponentTypeMask, RTS_UI32 ulHook, RTS_UINTPTR ulParam1, RTS_UINTPTR ulParam2)">CMCallHook2</functionname>
<description>
Called to call all components with the specified type provided with the specified hook
</description>
<param name="usComponentTypeMask" type="IN" range="[CMPTYPE_ALL,CMPTYPE_SAFETY,CMPTYPE_STANDARD]">ComponentType mask. See corresponding category</param>
<param name="ulHook" type="IN" range="[CH_COMM_CYCLE,CMCALLHOOK_PSEUDOHOOK,RTS_UI32_MAX]">Hook (for definition, look into CmpItf.h)</param>
<param name="ulParam1" type="IN" range="[0,CMCALLHOOK_TEST1]">First parameter. Hook dependant</param>
<param name="ulParam2" type="IN" range="[0,CMCALLHOOK_TEST2]">Second parameter. Hook dependant</param>
<errorcode name="RTS_RESULT pResult" type="ERR_OK">Hookfunction successfully called</errorcode>
<errorcode name="RTS_RESULT pResult" type="ERR_FAILED">Component Pool not initialized or any Component responded with some error</errorcode>
<errorcode name="RTS_RESULT pResult" type="ERR_PENDING">Any Component responded with ERR_PENDING</errorcode>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="int" parameters="(void)">CMIsDemo</functionname>
<description>Routine to check, if runtime runs in demo mode</description>
<result>1=Demo mode, 0=No demo</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(void)">CMInitEnd</functionname>
<description>Routine to complete the component manager initialization.
Contains calling the hooks from CH_INIT2 to CH_INIT_COMM.</description>
<result>
<ul>
<li>ERR_OK</li>
<li>ERR_DUPLICATE: If init end is still done, this error message will be returned</li>
</ul>
</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(void)">CMCheckSysTargetSignature</functionname>
<description>
Functtion checks, if the SysTarget component is originally signed and was not modified.
</description>
<result>error code: ERR_OK: SysTarget is signed, ERR_FAILED: SysTarget was modified or is unsigned</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(LicenseFunctions *pLicenseFunctions)">CMRegisterLicenseFunctions</functionname>
<description>Register the IEC function pointers from the license manager lib</description>
<param name="pLicenseFunctions" type="IN">Pointer to all IEC function pointers of the license manager lib</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(LicenseFunctions *pLicenseFunctions)">CMUnregisterLicenseFunctions</functionname>
<description>Unregister the IEC function pointers from the license manager lib</description>
<param name="pLicenseFunctions" type="IN">Pointer to all IEC function pointers of the license manager lib</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_UI32" parameters="(RTS_UI32 ulLicenseID, RTS_RESULT *pResult)">CMGetUserLicenseValue</functionname>
<description>Function to check the license of a feature</description>
<param name="ulLicenseID" type="IN">HIGHWORD: VendorID, LOWWORD: FeatureID</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>0: Not licensed, !0: Specific license ID</result>
</element>
<element function="1">
<functionname returntype="RTS_UI32" parameters="(RTS_UI32 ulLicenseID, RTS_UI32 ulNewLicenseValue, RTS_RESULT *pResult)">CMReqDynLicChallenge</functionname>
<description></description>
<param name="ulLicenseID" type="IN">HIGHWORD: VendorID, LOWWORD: FeatureID</param>
<param name="ulNewLicenseValue" type="IN"></param>
<param name="pResult" type="OUT">Pointer to error code</param>
<result></result>
</element>
<element function="1">
<functionname returntype="int" parameters="(RTS_UI32 ulLicenseID, RTS_UI32 ulNewLicenseValue, RTS_UI32 ulChallenge, RTS_RESULT *pResult)">CMConfDynLicChallenge</functionname>
<description></description>
<param name="ulLicenseID" type="IN">HIGHWORD: VendorID, LOWWORD: FeatureID</param>
<param name="ulNewLicenseValue" type="IN"></param>
<param name="ulChallenge" type="IN"></param>
<param name="pResult" type="OUT">Pointer to error code</param>
<result></result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_UINTPTR ulParam1, RTS_UINTPTR ulParam2)">CMCallExtraCommCycleHook</functionname>
<description>
Function to call the CommCycleHook of all components from outside the CM, if neccessary. This function is
intended to be called on singletasking systems (with CmpScheduleTimer or CmpScheduleEmbedded) during long
lasting operations. For example SysFlash calls this function to keep the communication alive during writing
long memory areas.
Before calling the CommCycleHook, the function internally checks the following conditions:
- Is SysTask implemented?
- Is the less then the configured time since the last call of the CommCycleHook elapsed?
If one of this conditions is true, the hook is not called. This allows to use this function without doing
these checks locally in the caller.
On multitasking systems this function has no effect. Use AsyncServices instead.
</description>
<param name="ulParam1" type="IN">Type of the COMM_CYCLE_HOOK. See CM_HOOK_TYPE... types.</param>
<param name="ulParam2" type="IN">Second parameter. Hook dependant, typically 0</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_UI32" parameters="(void)">CMGetCurrentHook</functionname>
<description>
Function returns the current hook function, that is called by the component manager
</description>
<result>Current hook</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(CMPID cmpId, RTS_UI32 ulOperation, CMPID *pCmpIdDisabled)">CMIsOperationDisabled</functionname>
<description>
Function can be called from each component to disable single operations. If this function is called, the event EVT_CmpMgr_DisableOperation is
sent to disable this operation from any component or IEC program.
</description>
<element name="cmpId" type="IN">ComponentID</element>
<element name="ulOperation" type="IN">Operation that can be disabled. See category "Operations" in Itf.h file of the corresponding component for details.</element>
<element name="pCmpIdDisabled" type="OUT">Pointer to ComponentID to get the component which disabled the operation. Can be NULL.</element>
<result>
<ul>
<li>ERR_OK: Operation is disabled</li>
<li>ERR_FAILED: Operation is enabled [default]</li>
<li>ERR_NOT_SUPPORTED: Cannot be retrieved, because the event is not available</li>
</ul>
</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char *pszInfo, CMPID cmpId, char *pszComponentName, char *pszModuleName, RTS_I32 nLine, RTS_I32 iID)">CMProfiling</functionname>
<description>
Central function for profiling
</description>
<element name="pszInfo" type="IN">Optional info string. Can be NULL.</element>
<element name="cmpId" type="IN">Component ID</element>
<element name="pszComponentName" type="IN">Component name</element>
<element name="pszModuleName" type="IN">Module name</element>
<element name="nLine" type="IN">Line number in the module</element>
<element name="iID" type="IN">Optional ID to calculate the time difference between two entries with the same ID.
iID = -1: No difference time
iID = 0: No difference time
</element>
<result>Error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char *pszAPIName, RTS_VOID_FCTPTR *ppfAPIFunction, RTS_UI32 ulSignatureID)">CMGetAPI</functionname>
<description>
Called to get an API function of another component
</description>
<param name="pszAPIName" type="IN">Name of the API routine</param>
<param name="ppfAPIFunction" type="OUT">Returned the function pointer of the API routine</param>
<param name="ulSignatureID" type="IN">SignatureID of the function prototype we expected</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char *pszAPIName, RTS_VOID_FCTPTR *ppfAPIFunction, int importOptions, RTS_UI32 ulSignatureID, RTS_UI32 ulVersion)">CMGetAPI2</functionname>
<description>
Called to get an API function of another component
</description>
<param name="pszAPIName" type="IN">Name of the API routine</param>
<param name="ppfAPIFunction" type="OUT">Returned the function pointer of the API routine</param>
<param name="ulSignatureID" type="IN">SignatureID of the function prototype we expected</param>
<param name="ulVersion" type="IN">Actual implementation version requested</param>
<param name="importOptions" type="IN">Import options. See CM_IMPORT_xx defines in CmpStd.h for details</param>
<result>error code</result>
</element>
</element>
<element interface="1" name="CMUtilsItf">
<interfacename>CmpMgrUtils</interfacename>
<description>
<p>Interface for utility functions of the component manager</p>
<p>The utility functions can be used by all components, because they are always included
in the component manager.</p>
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element define="1">
<name>RTS_STATIC_STRING_LEN</name>
<key>32</key>
<category>Static defines</category>
<description>Static length of a string. Is ised for RTS_STRING_CLASS.</description>
</element>
<element define="1">
<name>CMUTL_CPY_COMM2BUFFER</name>
<key>1</key>
<category>Copy mode</category>
<type>Int</type>
<description>Modes to copy strings. Copy byte packed stream to a word stream. HI byte is filled with 0.</description>
</element>
<element define="1">
<name>CMUTL_CPY_BUFFER2COMM</name>
<key>2</key>
<category>Copy mode</category>
<type>Int</type>
<description>Modes to copy strings. Copy word stream to a byte packed stream. HI byte is removed.</description>
</element>
<element define="1">
<name>CMUTL_CPY_DEFAULT</name>
<key>3</key>
<category>Copy mode</category>
<type>Int</type>
<description>Modes to copy strings. Copy stream unchanged.</description>
</element>
<element define="1">
<name>MAX_LONG_BIN_STRING_LEN</name>
<key>sizeof(RTS_I32</key>
<description>
Maximum length of the long binary string
</description>
</element>
<element define="1">
<name>MAX_LONG_DEC_STRING_LEN</name>
<key>11</key>
<description>
Maximum length of the long decimal string
</description>
</element>
<element define="1">
<name>MAX_LONG_HEX_STRING_LEN</name>
<key>11</key>
<description>
Maximum length of the long hexadecimal string
</description>
</element>
<element define="1">
<name>MAX_ULONG_BIN_STRING_LEN</name>
<key>sizeof(RTS_UI32</key>
<description>
Maximum length of the unsigned long binary string
</description>
</element>
<element define="1">
<name>MAX_ULONG_DEC_STRING_LEN</name>
<key>11</key>
<description>
Maximum length of the unsigned long decimal string
</description>
</element>
<element define="1">
<name>MAX_ULONG_HEX_STRING_LEN</name>
<key>11</key>
<description>
Maximum length of the long unsigned hexadecimal string
</description>
</element>
<element define="1">
<name>MAX_GUID_STRING_LEN</name>
<key>38</key>
<description>
Maximum legth of the GUID string
</description>
</element>
<element define="1">
<name>RTS_STRING_STATIC</name>
<key>0x00000001</key>
<category>ComponentNameFlags</category>
<description>
<ul>
<li>RTS_STRING_STATIC: Name is stored in a static buffer</li>
<li>RTS_STRING_DYNAMIC: Name is stored in a dynamic buffer</li>
<li>RTS_STRING_ASCII: Ascii string content</li>
</ul>
</description>
</element>
<element define="1">
<name>CM_STRING_GET_CONTENT</name>
<key>pString</key>
<condition>default</condition>
<description>
Macro to get the string content out of a string class.
</description>
<param name="pString" type="IN">Pointer to string class</param>
<param name="default" type="IN">Default string, if string content could not be returned</param>
<result>Pointer to content</result>
</element>
<element define="1">
<name>CM_STRING_GET_SIZE</name>
<key>pString</key>
<description>
Macro to get the size in bytes of the content of a string class.
</description>
<param name="pString" type="IN">Pointer to string class</param>
<result>Size in bytes of the string content</result>
</element>
<element function="1">
<functionname returntype="char*" parameters="(char* psz)">CMUtlSkipWhiteSpace</functionname>
<description>
Called to skip withspaces out of a string.
</description>
<param name="psz" type="IN">Pointer to the string</param>
<result>returns the pointer to the next position in the string with no whitespace</result>
</element>
<element function="1">
<functionname returntype="char*" parameters="(RTS_I32 lValue, char *pszString, int nMaxLen, int iBase, RTS_RESULT *pResult)">CMUtlLtoa</functionname>
<description>
<p>Converts a long value to a string. The representation can be specified by the iBase value:</p>
<p>2: binary (e.g. "10101010101110111100110011011101"). String length must be at least MAX_LONG_BIN_STRING_LEN bytes!</p>
<p>10: decimal (e.g. "2864434397"). String length must be at least MAX_LONG_DEC_STRING_LEN bytes!</p>
<p>16: hexadecimal (e.g. "0xAABBCCDD"). String length must be at least MAX_LONG_HEX_STRING_LEN bytes!</p>
</description>
<param name="lValue" type="IN">Long value to convert</param>
<param name="szString" type="OUT">Pointer to the string to get integer value as string</param>
<param name="iBase" type="IN">Base for the conversion: See description</param>
<result>returns the pointer to the next position in the string with no whitespace</result>
</element>
<element function="1">
<functionname returntype="char*" parameters="(RTS_UI32 ulValue, char *pszString, int nMaxLen, int iBase, RTS_RESULT *pResult)">CMUtlUltoa</functionname>
<description>
<p>Converts an unsigned long value to a string. The representation can be specified by the iBase value:</p>
<p>2: binary (e.g. "10101010101110111100110011011101"). String length must be at least MAX_ULONG_BIN_STRING_LEN bytes!</p>
<p>10: decimal (e.g. "2864434397"). String length must be at least MAX_ULONG_DEC_STRING_LEN bytes!</p>
<p>16: hexadecimal (e.g. "0xAABBCCDD"). String length must be at least MAX_ULONG_HEX_STRING_LEN bytes!</p>
</description>
<param name="ulValue" type="IN">Unsigned long value to convert</param>
<param name="szString" type="OUT">Pointer to the string to get integer value as string</param>
<param name="iBase" type="IN">Base for the conversion: See description</param>
<result>returns the pointer to the next position in the string with no whitespace</result>
</element>
<element function="1">
<functionname returntype="char*" parameters="(char *psz)">CMUtlStrrev</functionname>
<description>
<p>Reverses content of a string in place</p>
</description>
<param name="psz" type="INOUT">Pointer to a null-terminated string</param>
<result>returns the pointer to the next the same string</result>
</element>
<element function="1">
<functionname returntype="char*" parameters="(char *pszString, char *pszBegin, char cFind)">CMUtlStrRChr</functionname>
<description>
Scan a string for the last occurrence of a character
</description>
<param name="pszString" type="IN">Pointer to scan</param>
<param name="pszBegin" type="IN">Pointer of a position into pszString to start the scan</param>
<result>Pointer to the first occurrence in string, or NULL if not found</result>
</element>
<element function="1">
<functionname returntype="int" parameters="(char *pszString1, char *pszString2)">CMUtlStrICmp</functionname>
<description>
<p>Case insensitive string compare.</p>
</description>
<param name="pszString1" type="IN" range="[NULL,VALID_POINTER_TO_STRING1,VALID_POINTER_TO_STRING2]">Pointer to first string to compare</param>
<param name="pszString2" type="IN" range="[NULL,VALID_POINTER_TO_STRING1]">Pointer to second string to compare</param>
<result>0 if strings are equal, -1 or 1 if there is a difference between them</result>
</element>
<element function="1">
<functionname returntype="int" parameters="(char *pszString1, char *pszString2, RTS_SIZE n)">CMUtlStrNICmp</functionname>
<description>
Lower case comparison of two strings specified by length.
</description>
<param name="pszString1" type="IN">Pointer to first string to compare</param>
<param name="pszString2" type="IN">Pointer to second string to compare</param>
<param name="n" type="IN">Number of characters to compare</param>
<result>0= strings are equal, !0=strings unequal</result>
</element>
<element function="1">
<functionname returntype="char *" parameters="(const char *pszString, const char *pszStringToFind)">CMUtlStrIStr</functionname>
<description>
Find a substring in another string.
</description>
<param name="pszString" type="IN">String to search substring in</param>
<param name="pszStringToFind" type="IN">Substring to find</param>
* <result>NULL= substring not found in string, !NULL= pointer to string, where substring was found</result>
</element>
<element function="1">
<functionname returntype="char*" parameters="(char *pszString)">CMUtlStrlwr</functionname>
<description>
Lower case conversion of a string.
</description>
<param name="pszString" type="IN">Pointer to conversion string</param>
<result>Returns a pointer to the converted string, NULL if conversion failed</result>
</element>
<element function="1">
<functionname returntype="char*" parameters="(char *pszString)">CMUtlStrupr</functionname>
<description>
Upper case conversion of a string.
</description>
<param name="pszString" type="IN">Pointer to conversion string</param>
<result>Returns a pointer to the converted string, NULL if conversion failed</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char *pszDest, RTS_SIZE nDestSize, const char *pszSrc)">CMUtlSafeStrCpy</functionname>
<description>
Safe string copy of a string. The length of the destination buffer is checked to avoid memory overwrites.
</description>
<param name="pszDest" type="IN">Pointer to destination buffer</param>
<param name="nDestSize" type="IN">Length of destination buffer</param>
<param name="pszSrc" type="IN">Pointer to source buffer. String must be NUL terminated!</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char *pszDest, RTS_SIZE nDestSize, const char *pszSrc, int nCopyMode)">CMUtlSafeStrCpy2</functionname>
<description>
<p>Copy a string from one buffer to another, but limit the size of the
destination buffer to nDestSize.</p>
</description>
<param name="pszDest" type="IN" range="[0,VALID_POINTER_TO_STRINGDEST]">Pointer to destination buffer</param>
<param name="nDestSize" type="IN" range="[0,INVALID_DST_SIZE,VALID_DST_SIZE]">Length of destination buffer</param>
<param name="pszSrc" type="IN" range="[0,VALID_POINTER_TO_STRINGSRC]">Pointer to source buffer. String must be NUL terminated!</param>
<param name="nCopyMode" type="IN" range="[0,CMUTL_CPY_COMM2BUFFER,CMUTL_CPY_BUFFER2COMM,CMUTL_CPY_DEFAULT]">Copy mode. See corresponding category "Copy mode"</param>
<errorcode name="RTS_RESULT pResult" type="ERR_OK">Copied successful!</errorcode>
<errorcode name="RTS_RESULT pResult" type="ERR_BUFFERSIZE">Size of SrcString is greater than nDestSize!</errorcode>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char *pszDest, RTS_SIZE nDestSize, const char *pszSrc, RTS_SIZE nBytesCopy)">CMUtlSafeStrNCpy</functionname>
<description>
<p>Copy a string from one buffer to another specified by the number of characters to copy, but limit the size of the
destination buffer to nDestSize.</p>
</description>
<param name="pszDest" type="IN" range="[RTS_INVALID_HANDLE,NULL,VALID_POINTER_TO_STRINGDEST]">Pointer to destination buffer</param>
<param name="nDestSize" type="IN" range="[0,1,RTS_SIZE_MAX]">Length of destination buffer</param>
<param name="pszSrc" type="IN" range="[RTS_INVALID_HANDLE,NULL,VALID_POINTER_TO_STRINGSRC]">Pointer to source buffer. String must be NUL terminated!</param>
<param name="nBytesCopy" type="IN" range="[0,1,RTS_SIZE_MAX]">Number of bytes to copy</param>
<errorcode name="RTS_RESULT Result" type="ERR_OK">Copy successful</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_BUFFERSIZE">Destination buffer too short. Only the possible number of charachters copied</errorcode>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char *pszDest, RTS_SIZE nDestSize, const char *pszSrc)">CMUtlSafeStrCat</functionname>
<description>
<p>Concatenate two strings, but limit the size of the destination buffer to nDestSize.</p>
</description>
<param name="pszDest" type="IN" range="[RTS_INVALID_HANDLE,NULL,VALID_POINTER_TO_STRINGDEST]">Pointer to destination buffer</param>
<param name="nDestSize" type="IN" range="[0,1,RTS_SIZE_MAX]">Length of destination buffer</param>
<param name="pszSrc" type="IN" range="[RTS_INVALID_HANDLE,NULL,VALID_POINTER_TO_STRINGSRC]">Pointer to source buffer. String must be NUL terminated!</param>
<errorcode name="RTS_RESULT Result" type="ERR_OK">Concatenate successful</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_BUFFERSIZE">Destination buffer too short. Only the possible number of charachters copied</errorcode>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_SIZE" parameters="(char *str)">CMUtlStrLen</functionname>
<description>
<p>Calculate the string length</p>
<p>Is able to handle Null pointer</p>
<p>This function works for targets where char has a size of 8 bits as well
as for targets where char is 16 bits wide.</p>
</description>
<param name="str" type="IN" range="[NULL,VALID_POINTER_TO_STRING1]">pointer to string</param>
<result>Length of string without trailing \0, 0 if str is Null</result>
</element>
<element function="1">
<functionname returntype="char*" parameters="(char* psz)">CMUtlStrToLower</functionname>
<description>
Convert a string in lower case. String must be NUL terminated!
</description>
<param name="psz" type="IN">Pointer to string to convert</param>
<result>Pointer to psz with the converted content</result>
</element>
<element function="1">
<functionname returntype="char*" parameters="(char* psz)">CMUtlStrToUpper</functionname>
<description>
Convert a string in upper case. String must be NUL terminated!
</description>
<param name="psz" type="IN">Pointer to string to convert</param>
<result>Pointer to psz with the converted content</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char *pszStr, RTS_SIZE ulStrSize, const char *pszFormat, va_list *pargList)">CMUtlvsnprintf</functionname>
<description>
Safe sprintf with argument list.
NOTES:
- If ANSI vsnprintf is not available on the target, vsprintf is used instead and the size of the string can be evaluated only after
writing the complete string! So the memory could be overwritten in this case and so the error code is the only way to detect this situation!
- RTS_ASSERT() is generated, if string buffer is too short!
</description>
<param name="pszStr" type="IN">Destination buffer</param>
<param name="ulStrSize" type="IN">Destination buffer size</param>
<param name="pszFormat" type="IN">Format string</param>
<param name="pargList" type="IN">Pointer to argument list</param>
<result>Error code:
<ul>
<li>ERR_OK: String could be written</li>
<li>ERR_PARAMETER: NULL pointer used as parameter</li>
<li>ERR_BUFFERSIZE: If pszStr is too short to get the string value</li>
</ul>
</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char *pszStr, RTS_SIZE ulStrSize, const char *pszFormat, ...)">CMUtlsnprintf</functionname>
<description>
Safe sprintf with format string and variable argument list.
NOTES:
- If ANSI vsnprintf is not available on the target, vsprintf is used instead and the size of the string can be evaluated only after
writing the complete string! So the memory could be overwritten in this case and so the error code is the only way to detect this situation!
- RTS_ASSERT() is generated, if string buffer is too short!
</description>
<param name="pszStr" type="IN">Destination buffer</param>
<param name="ulStrSize" type="IN">Destination buffer size</param>
<param name="pszFormat" type="IN">Format string</param>
<param name="..." type="IN">Argument list</param>
<result>Error code:
<ul>
<li>ERR_OK: String could be written</li>
<li>ERR_PARAMETER: NULL pointer used as parameter</li>
<li>ERR_BUFFERSIZE: If pszStr is too short to get the string value</li>
</ul>
</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(void *pDest, RTS_SIZE ulDestSize, const void *pSrc, RTS_SIZE ulToCopy)">CMUtlSafeMemCpy</functionname>
<description>
Safe memory copy between two buffers. The length of the destination buffer is checked to avoid memory overwrites.
</description>
<param name="pDest" type="IN">Pointer to destination buffer</param>
<param name="ulDestSize" type="IN">Length of destination buffer</param>
<param name="pSrc" type="IN">Pointer to source buffer</param>
<param name="ulToCopy" type="IN">Bytes to copy from source to destination buffer</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_GUID *pguid, char *pszGUID, RTS_SIZE nMaxLen)">CMUtlGUIDToString</functionname>
<description>
Conversion of a GUID into a string.
</description>
<param name="pguid" type="IN">Pointer to the GUID to convert</param>
<param name="pszGUID" type="OUT">Pointer to string buffer for the result</param>
<param name="nMaxLen" type="IN">maximum length of the string buffer. Should be at least MAX_GUID_STRING_LEN</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_STRING_CLASS *pString, char *pszComponentName, char *pszInit)">CMStringCreate</functionname>
<description>
Create a string and initialize it with a default string.
</description>
<param name="pString" type="IN">Pointer to string class</param>
<param name="pszComponentName" type="IN">Pointer to the component name, which creates this string</param>
<param name="pszInit" type="IN">Pointer to init string to copy into content. Can be NULL.</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_STRING_CLASS *pString, char *pszComponentName)">CMStringDelete</functionname>
<description>
Create a string and initialize it with a default string.
</description>
<param name="pString" type="IN">Pointer to string class</param>
<param name="pszComponentName" type="IN">Pointer to the component name, which creates this string</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_STRING_CLASS *pString, char *pszComponentName, RTS_SIZE size)">CMStringExtend</functionname>
<description>
Extend a string to a specified size.
</description>
<param name="pString" type="IN">Pointer to string class</param>
<param name="pszComponentName" type="IN">Pointer to the component name, which creates this string</param>
<param name="size" type="IN">Size to which the content must be extended</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="int" parameters="(const RTS_WCHAR *pwsz1, const RTS_WCHAR *pwsz2)">CMUtlwstrcmp</functionname>
<description>
Compare two unicode strings
</description>
<param name="pwsz1" type="IN">Pointer to string 1</param>
<param name="pwsz2" type="IN">Pointer to string 2</param>
<result>
0: string1 identical to string2
lower 0: string1 less than string2
greater 0: string1 greater than string2
</result>
</element>
<element function="1">
<functionname returntype="int" parameters="(const RTS_WCHAR *pwsz1, const RTS_WCHAR *pwsz2, RTS_SIZE nCount)">CMUtlwstrncmp</functionname>
<description>
Compare two unicode strings with specified number of characters
</description>
<param name="pwsz1" type="IN">Pointer to string 1</param>
<param name="pwsz2" type="IN">Pointer to string 2</param>
<param name="nCount" type="IN">Number of characters to compare</param>
<result>
0: string1 identical to string2
lower 0: string1 less than string2
greater 0: string1 greater than string2
</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_WCHAR *pwszDest, RTS_SIZE nDestSize, const RTS_WCHAR *pwszSrc)">CMUtlwstrcpy</functionname>
<description>
Copy one unicode string to another in a safe way
</description>
<param name="pwszDest" type="IN">Destination string</param>
<param name="nDestSize" type="IN">Size of the destination buffer in unicode characters (not bytes)!</param>
<param name="pwszSrc" type="IN">Source string</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_WCHAR *pwszDest, RTS_SIZE nDestSize, const RTS_WCHAR *pwszSrc)">CMUtlwstrcat</functionname>
<description>
Concatenate two unicode strings in a safe way
</description>
<param name="pwszDest" type="IN">Destination string</param>
<param name="nDestSize" type="IN">Size of the destination buffer in unicode characters (not bytes)!</param>
<param name="pwszSrc" type="IN">Source string</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_WCHAR *pwszDest, RTS_SIZE nDestSize, const RTS_WCHAR *pwszSrc, RTS_SIZE n)">CMUtlwstrncpy</functionname>
<description>
Copy number of characters from one unicode string to another in a safe way
</description>
<param name="pwszDest" type="IN">Destination string</param>
<param name="nDestSize" type="IN">Size of the destination buffer in unicode characters (not bytes)!</param>
<param name="pwszSrc" type="IN">Source string</param>
<param name="n" type="IN">Number of characters to copy (not bytes)!</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_SIZE" parameters="(const RTS_WCHAR *pwsz)">CMUtlwstrlen</functionname>
<description>
Get the number of characters (not bytes!) in the content of a string _without_ NUL terminating character.
</description>
<param name="pwsz" type="IN">Pointer to string</param>
<result>Number of characters (not bytes!) in the content of a string _without_ NUL terminating character</result>
</element>
<element function="1">
<functionname returntype="RTS_WCHAR*" parameters="(RTS_WCHAR* pwsz)">CMUtlwtolower</functionname>
<description>
Convert the characters in a unicode string to lower case.
</description>
<param name="pwsz" type="IN">Pointer to string</param>
<result>pwsz is returned</result>
</element>
<element function="1">
<functionname returntype="RTS_WCHAR*" parameters="(RTS_WCHAR* pwsz)">CMUtlwtoupper</functionname>
<description>
Convert the characters in a unicode string to upper case.
</description>
<param name="pwsz" type="IN">Pointer to string</param>
<result>pwsz is returned</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(const char* pszSrc, RTS_WCHAR* pwszDest, RTS_SIZE nDestSize)">CMUtlStrToW</functionname>
<description>
Convert a byte character string to a unicode character string.
</description>
<param name="pszSrc" type="IN">Pointer to byte character string</param>
<param name="pwszDest" type="IN">Pointer to unicode character string</param>
<param name="nDestSize" type="IN">Size of the destination buffer in unicode characters (not bytes)!</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(const RTS_WCHAR* pwszSrc, char* pszDest, RTS_SIZE nDestSize)">CMUtlWToStr</functionname>
<description>
Convert a unicode character string to a byte character string .
</description>
<param name="pwszSrc" type="IN">Pointer to unicode character string</param>
<param name="pszDest" type="IN">Pointer to byte character string</param>
<param name="nDestSize" type="IN">Size of the destination buffer in bytes</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_WCHAR*" parameters="(const RTS_WCHAR *pwsz, RTS_WCHAR w)">CMUtlwstrchr</functionname>
<description>
Find a character in a unicode string.
</description>
<param name="pwsz" type="IN">Pointer to unicode string</param>
<param name="w" type="IN">Character to find</param>
<result>Returns the find position or NULL if not found</result>
</element>
<element function="1">
<functionname returntype="int" parameters="(const RTS_CWCHAR *pwsz1, const RTS_CWCHAR *pwsz2)">CMUtlcwstrcmp</functionname>
<description>
Compare two RTS_CWCHAR strings
</description>
<param name="pwsz1" type="IN">Pointer to string 1</param>
<param name="pwsz2" type="IN">Pointer to string 2</param>
<result>
0: string1 identical to string2
lower 0: string1 less than string2
greater 0: string1 greater than string2
</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_CWCHAR *pwszDest, RTS_SIZE nDestSize, const RTS_CWCHAR *pwszSrc)">CMUtlcwstrcpy</functionname>
<description>
Copy one RTS_CWCHAR string to another in a safe way
</description>
<param name="pwszDest" type="IN">Destination string</param>
<param name="nDestSize" type="IN">Size of the destination buffer in RTS_CWCHAR characters!</param>
<param name="pwszSrc" type="IN">Source string</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_CWCHAR *pwszDest, RTS_SIZE nDestSize, const RTS_CWCHAR *pwszSrc)">CMUtlcwstrcat</functionname>
<description>
Concatenate two RTS_CWCHAR strings in a safe way
</description>
<param name="pwszDest" type="IN">Destination string</param>
<param name="nDestSize" type="IN">Size of the destination buffer in RTS_CWCHAR characters!</param>
<param name="pwszSrc" type="IN">Source string</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_CWCHAR *pwszDest, RTS_SIZE nDestSize, const RTS_CWCHAR *pwszSrc, RTS_SIZE n)">CMUtlcwstrncpy</functionname>
<description>
Copy number of characters from one RTS_CWCHAR string to another in a safe way
</description>
<param name="pwszDest" type="IN">Destination string</param>
<param name="nDestSize" type="IN">Size of the destination buffer in RTS_CWCHAR characters!</param>
<param name="pwszSrc" type="IN">Source string</param>
<param name="n" type="IN">Number of characters to copy (not bytes)!</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_SIZE" parameters="(const RTS_CWCHAR *pwsz)">CMUtlcwstrlen</functionname>
<description>
Get the number of RTS_CWCHAR characters in the content of a string _without_ NUL terminating character.
</description>
<param name="pwsz" type="IN">Pointer to string</param>
<result>Number of RTS_CWCHAR characters in the content of a string _without_ NUL terminating character</result>
</element>
<element function="1">
<functionname returntype="RTS_CWCHAR*" parameters="(RTS_CWCHAR* pwsz)">CMUtlcwtolower</functionname>
<description>
Convert the characters in a RTS_CWCHAR string to lower case.
</description>
<param name="pwsz" type="IN">Pointer to string</param>
<result>pwsz is returned</result>
</element>
<element function="1">
<functionname returntype="RTS_CWCHAR*" parameters="(RTS_CWCHAR* pwsz)">CMUtlcwtoupper</functionname>
<description>
Convert the characters in a RTS_CWCHAR string to upper case.
</description>
<param name="pwsz" type="IN">Pointer to string</param>
<result>pwsz is returned</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(const char* pszSrc, RTS_CWCHAR* pwszDest, RTS_SIZE nDestSize)">CMUtlStrToCW</functionname>
<description>
Convert a byte character string to a RTS_CWCHAR character string.
</description>
<param name="pszSrc" type="IN">Pointer to byte character string</param>
<param name="pwszDest" type="IN">Pointer to RTS_CWCHAR character string</param>
<param name="nDestSize" type="IN">Size of the destination buffer in RTS_CWCHAR characters!</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(const RTS_CWCHAR* pwszSrc, char* pszDest, RTS_SIZE nDestSize)">CMUtlCWToStr</functionname>
<description>
Convert a RTS_CWCHAR character string to a byte character string .
</description>
<param name="pwszSrc" type="IN">Pointer to RTS_CWCHAR character string</param>
<param name="pszDest" type="IN">Pointer to byte character string</param>
<param name="nDestSize" type="IN">Size of the destination buffer in bytes</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_CWCHAR*" parameters="(const RTS_CWCHAR *pwsz, RTS_CWCHAR cw)">CMUtlcwstrchr</functionname>
<description>
Find a character in a RTS_CWCHAR string.
</description>
<param name="pwsz" type="IN">Pointer to RTS_CWCHAR string</param>
<param name="w" type="IN">Character to find</param>
<result>Returns the find position or NULL if not found</result>
</element>
</element>
<element interface="1" name="CMBasicChecksItf">
<interfacename>CmpMgrBasicChecks</interfacename>
<description>
<p>Interface to check the runtime environment. Here things like datatype size and
byte order are checked, before the runtime system was started.</p>
</description>

<copyright>(c) 2003-2013 3S-Smart Software Solutions</copyright>
<element function="1">
<functionname returntype="int" parameters="(void)">CMBasicChecks</functionname>
<description>
Checks to environment and the compiled runtime system for consistency.
- Checks the real size of all data types
- Checks, if swapping must be done and if swapping is done correctly
</description>
<result>TRUE if successful, FALSE if error occurred</result>
</element>
</element>
<element interface="1" name="CMLockItf">
<interfacename>CMLock</interfacename>
<description>
<p>Interface for a generic locking mechanism</p>
<p>If both SysSem and SysInt components are implemented in the runtime system,
a global int-lock implementation can be choosen with CMLOCK_PREFER_SYSINT macro.
Otherwise, a mutex-based implementation is automatically selected.</p>
<p>If either SysSem or SysInt component is implemented only, then
the CMLock implementation is based on an existing component.</p>
<pre>
USAGE in a module:

RTS_HANDLE s_hLock = RTS_INVALID_HANDLE;
CH_INIT:
RTS_RESULT result;
s_hLock = CAL_CMLockCreate(&amp;result);
CH_EXIT:
CAL_CMLockDelete(s_hLock);

Function()
{
RTS_HANDLE hLock;
CM_GET_LOCK(s_hLock, hLock);

CAL_CMLockEnter(hLock);
...
CAL_CMLockLeave(hLock);
}
</pre>
</description>

<copyright>(c) 2003-2013 3S-Smart Software Solutions</copyright>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(RTS_RESULT *pResult)">CMLockCreate</functionname>
<description>
Function to create a lock object to synchronize data against concurrent task or interrupt access.
</description>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Handle to the lock object</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hLock)">CMLockDelete</functionname>
<description>
Function to delete a lock object.
</description>
<param name="hLock" type="IN">Handle to the lock object retrieved by CMLockCreate()</param>
<result>Error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hLock)">CMLockEnter</functionname>
<description>
Function to enter a lock object. After entering, the accessed data is _safe_ against concurrent
access.
</description>
<param name="hLock" type="IN">Handle to the lock object retrieved by macro: CM_GET_LOCK(hLockObject, hLock)
- hLockObject is retrieved by CMLockCreate()
- hLock is a local variable of type RTS_HANDLE (declared in the local function!)</param>
<result>Error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hLock)">CMLockLeave</functionname>
<description>
Function to leave a lock object. After leaving, the accessed data is _unsafe_ against concurrent
access.
</description>
<param name="hLock" type="IN">Handle to the lock object retrieved by CMLockCreate()</param>
<result>Error code</result>
</element>
</element>
</component>
<component>
<name>CmpAppEmbedded</name>
<description>
<p>This component is responsible for handling one single IEC Application.
It has reduced memory requirements compared to the CmpApp. It also uses a different
application download format to be able to run the application directly from flash if required.

</p>
<p>This implementation of the application manager needs two components to handle the IEC tasks:</p>
<ui>
<li>CmpIecTask: All IEC tasks of all applications are registered at this component. The IEC cycle
is implemented there.</li>
<li>CmpSchedule: The IEC task component registered all tasks at the scheduler component for the
timing and scheduling of all tasks.</li>
</ui>
<p>Monitoring is done in a separate component too (CmpMonitor).</p>
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<p><h1>Compiler Switch</h1></p>
<ul>
<li>
<csdef>#define APP_POU_TABLES_ENABLED</csdef>
<csdesc>Management of information for each POU can be enabled with this switch. This can be used in CoDeSys to check during login,</csdesc>
<p></p>
</li>
</ul>
<element interface="1" name="CmpAppItf">
<interfacename>CmpApp</interfacename>
<description>
<p>This is the interface of the IEC application manager. The manager is responsible for:
<ul>
<li>Handles and collects all IEC applications</li>
<li>Application specific online communication to CoDeSys (debugging, forcing, etc.)</li>
<li>Code and data handling (areas)</li>
<li>Handling of non volatile data (retain handling)</li>
</ul>
</p>
<p>An IEC application is a set of objects which are needed for running a particular instance of the
PLC program. Each application is specified by its unique name.</p>
<p>Applications can have relationships among each other. If one application e.g. A2 depends from another
application A1, A1 is the parent and A2 the child. So A2 is derived from A1.</p>
<p>Each application has two different kinde of states:
<ul>
<li>Application state: run, stop, exception, etc.</li>
<li>Operating state: storing bootproject, do online-change, etc.</li>
</ul>
The application state is used to specify, if the application is opertaing normal or not.
The operating state is used to specify, which job is executed in the moment on the application.</p>
<p>An IEC application consists of one or more tasks. The IEC tasks are not handled directly by the
application manager. This is provided by the the IEC task manager. See CmpIecTask for detailed information.</p>
<p>An application can have code and data. So the application manager needs for each application one or
more memory areas in which the code and data will be administrated.</p>
</description>

<copyright>(c) 2003-2013 3S-Smart Software Solutions</copyright>
<element define="1">
<name>MAX_LEN_APPLNAME</name>
<key>60</key>
<category>Static defines</category>
<description>Maximum length fo application name</description>
</element>
<element define="1">
<name>MAX_PATH_LEN</name>
<key>255</key>
<condition>MAX_PATH_LEN</condition>
<category>Static defines</category>
<description>Maximum length of a file path</description>
</element>
<element define="1">
<name>APPL_NUM_OF_STATIC_APPLS</name>
<key>8</key>
<condition>APPL_NUM_OF_STATIC_APPLS</condition>
<category>Static defines</category>
<description>Length of application list that is allocated static</description>
</element>
<element define="1">
<name>APPL_NUM_OF_STATIC_SESSIONIDS</name>
<key>5</key>
<condition>APPL_NUM_OF_STATIC_SESSIONIDS</condition>
<category>Static defines</category>
<description>Length of session id list that is allocated static</description>
</element>
<element define="1">
<name>APPL_NUM_OF_STATIC_AREAS</name>
<key>10</key>
<condition>APPL_NUM_OF_STATIC_AREAS</condition>
<category>Static defines</category>
<description>Length of area pointer list that is allocated static in the application object</description>
</element>
<element define="1">
<name>APP_NUM_OF_STATIC_ASYNC_SERVICES</name>
<key>8</key>
<condition>APP_NUM_OF_STATIC_ASYNC_SERVICES</condition>
<category>Static defines</category>
<description>Number of possible static async services. Can be increased dynamically.</description>
</element>
<element define="1">
<name>PROJECT_ARCHIVE</name>
<key>Archive.prj</key>
<category>File name definitions</category>
<description>Name of the project archive with all applications in the project</description>
</element>
<element define="1">
<name>PROJECT_ARCHIVE_INFO</name>
<key>Archive.inf</key>
<category>File name definitions</category>
<description>Name of the project archive info file, which contains all informations about the archive content</description>
</element>
<element define="1">
<name>APP_BOOTPROJECT_FILE_EXTENSION</name>
<key>.app</key>
<condition>APP_BOOTPROJECT_FILE_EXTENSION</condition>
<category>Static defines</category>
<description>Bootproject file extension</description>
</element>
<element define="1">
<name>APP_BOOTPROJECT_FILE_EXTENSION_INVALID</name>
<key>.ap_</key>
<condition>APP_BOOTPROJECT_FILE_EXTENSION_INVALID</condition>
<category>Static defines</category>
<description>Bootproject file extension to invalidate during download</description>
</element>
<element define="1">
<name>APP_BOOTPROJECT_FILE_EXTENSION_ERROR</name>
<key>.err</key>
<condition>APP_BOOTPROJECT_FILE_EXTENSION_ERROR</condition>
<category>Static defines</category>
<description>Bootproject file extension if file has an error</description>
</element>
<element define="1">
<name>APP_BOOTPROJECT_FILE_EXTENSION_CRC</name>
<key>.crc</key>
<condition>APP_BOOTPROJECT_FILE_EXTENSION_CRC</condition>
<category>Static defines</category>
<description>File extension for bootproject crc checksum file</description>
</element>
<element define="1">
<name>APP_FILE_EXTENSION_SYMBOLS</name>
<key>.xml</key>
<condition>APP_FILE_EXTENSION_SYMBOLS</condition>
<category>Static defines</category>
<description>File extension for symbol file matching to application</description>
</element>
<element define="1">
<name>APP_BOOTPROJECT_FILE_EXTENSION_SYMBOLS</name>
<key>.boot.xml</key>
<condition>APP_BOOTPROJECT_FILE_EXTENSION_SYMBOLS</condition>
<category>Static defines</category>
<description>File extension for symbol file matching to bootproject</description>
</element>
<element define="1">
<name>CCO_SEMAPHORE</name>
<key>1</key>
<category>Static defines</category>
<description>Copy code option for online-change. CCO_DEFAULT defines the option, which mechanism is used to synchronize copy code.</description>
</element>
<element define="1">
<name>OP_APP_STOP</name>
<key>1</key>
<category>Operations</category>
<description>Operations of the application component. Can be disabled with the event CMPID_CmpMgr::EVT_CmpMgr_DisableOperation!</description>
</element>
<element define="1">
<name>EVT_PrepareStart</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent before start of the specified application</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpApp</param>
</element>
<element define="1">
<name>EVT_StartDone</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent after start of the specified application</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpApp</param>
</element>
<element define="1">
<name>EVT_PrepareStop</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent before stop of the specified application</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpAppStop</param>
</element>
<element define="1">
<name>EVT_StopDone</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent after stop of the specified application</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpAppStop</param>
</element>
<element define="1">
<name>EVT_PrepareReset</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent before reset of the specified application, but after the stop of the application! So no IEC user code is executed at this event!</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpApp_Reset</param>
</element>
<element define="1">
<name>EVT_ResetDone</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent after reset of the specified application</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpApp_Reset</param>
</element>
<element define="1">
<name>EVT_PrepareOnlineChange</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent before online change of the specified application</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpApp</param>
</element>
<element define="1">
<name>EVT_OnlineChangeDone</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent after online change of the specified application</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpApp</param>
</element>
<element define="1">
<name>EVT_PrepareDownload</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent before download of the specified application</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpApp</param>
</element>
<element define="1">
<name>EVT_DownloadDone</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent after download of the specified application</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpApp</param>
</element>
<element define="1">
<name>EVT_CodeInitDone</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent after CodeInit. Is called inside the task safe section
and only at online-change! (e.g. the copy code for online-change is executed here).</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpApp</param>
</element>
<element define="1">
<name>EVT_PrepareDelete</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent before an application is deleted. The application is stopped, if this event is posted.</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpApp</param>
</element>
<element define="1">
<name>EVT_DeleteDone</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent after an application is deleted. The application is stopped, if this event is posted.
ATTENTION: Right after this event, the APPLICATION structure of the event parameter is deleted!</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpApp</param>
</element>
<element define="1">
<name>EVT_PrepareExit</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent before an application executes its exit code (deleting the application, reinit at download or reset).
The application is in stop, if this event is posted.</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpApp</param>
</element>
<element define="1">
<name>EVT_ExitDone</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent after an application executes its exit code (deleting the application, reinit at download or reset).
The application is in stop, if this event is posted.</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpApp</param>
</element>
<element define="1">
<name>EVT_CreateBootprojectDone</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent after creating a bootproject of an application successfully</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpApp</param>
</element>
<element define="1">
<name>EVT_DenyLoadBootproject</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent to deny loading a bootproject of an application.
</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpAppDenyLoadBootproject</param>
</element>
<element define="1">
<name>EVT_PrepareLoadBootproject</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent before loading a bootproject of an application</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpAppPrepareLoadBootproject</param>
</element>
<element define="1">
<name>EVT_LoadBootprojectDone</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent after loading a bootproject of an application successfully</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpApp</param>
</element>
<element define="1">
<name>EVT_DenyStartBootproject</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent to deny starting a bootproject of an application.
</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpAppDenyStart</param>
</element>
<element define="1">
<name>EVT_PrepareStartBootproject</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent before starting a bootproject of an application</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpApp</param>
</element>
<element define="1">
<name>EVT_StartBootprojectDone</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent after starting a bootproject of an application</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpApp</param>
</element>
<element define="1">
<name>EVT_DenyStart</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent to deny starting an application</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpAppDenyStart</param>
</element>
<element define="1">
<name>EVT_DenyStop</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent to deny stopping an application</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpAppDenyStop</param>
</element>
<element define="1">
<name>EVT_AllBootprojectsLoaded</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent after all boot applications have been loaded</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpAppAllBootAppsLoaded</param>
</element>
<element define="1">
<name>EVT_GlobalExitOnResetDone</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent on Reset, after global exit and before global init.</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpAppConfig</param>
</element>
<element define="1">
<name>EVT_ExitDoneWithConfigAppInfo</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent after an application has executed its exit code. The application is stopped, if this event is posted. The event has got the additional parameter szConfigApp</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpAppConfig</param>
</element>
<element define="1">
<name>EVT_CmpApp_Exception</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent, if an exception occurred in the context of an application
NOTE:
In case of a retain mismatch, the RTSEXCPT_RETAIN_IDENTITY_MISMATCH is provided as exception code (see ulException in EVTPARAM_CmpAppException).
</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpAppException</param>
</element>
<element define="1">
<name>EVT_RegisterBootproject</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent, if a new bootproject is registered</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpAppRegisterBootproject</param>
</element>
<element define="1">
<name>EVT_CreateBootprojectFileFailed</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent, if the bootproject file cannot be created.
NOTE: EVT_CreateBootprojectFailed is sent additionally in this case!</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpApp</param>
</element>
<element define="1">
<name>EVT_CreateBootprojectFailed</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent, if the creation of a bootproject failed. This can occur at creation of the bootproject
implicit at download or explicit by the user.</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpApp</param>
</element>
<element define="1">
<name>EVT_OperatingStateChanged</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent, if the operating state has changed</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpAppOperatingStateChanged</param>
</element>
<element define="1">
<name>EVT_SourceDownload</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent, if the project archive is downloaded (source download)</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpAppSourceDownload</param>
</element>
<element define="1">
<name>EVT_Login</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent, if a client login to the specified application</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpAppComm</param>
</element>
<element define="1">
<name>EVT_Logout</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent, if a client logout of the specified application. The event is sent additionally, if a communication error occurred.</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpAppComm</param>
</element>
<element define="1">
<name>EVT_DenyDelete</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent to deny deleting an application</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpAppDenyDelete</param>
</element>
<element define="1">
<name>EVT_DenyDeleteBootproject</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent to deny deleting a bootproject of an application</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpAppDenyDelete</param>
</element>
<element define="1">
<name>EVT_OEMDownloadServiceTag</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent to handle own download/online-change service tags</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpApp_OEMServiceTag</param>
</element>
<element define="1">
<name>EVT_OEMRegisteredIecFunction</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent to get all IEC-functions specified in CoDeSys with the following attribute:
{attribute 'register_in_runtime'}
NOTE:
- Only IEC-functions can be registered
- The function name must be unique!
- The user have to handle the events EVT_PrepareExit and EVT_DeleteDone to check, if the application and so the IEC function will be removed!
</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpApp_OEMRegisteredIecFunction</param>
</element>
<element define="1">
<name>EVT_POUTable_Changed</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is fired on any change in the POU Tables Manager</description>
<param name="pEventParam" type="IN">EVT_POUTable_Changed</param>
</element>
<element define="1">
<name>EVT_CommCycle</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is fired at every communication cycle (idle loop). This can be used in IEC-for background jobs.</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpApp_CommCycle</param>
</element>
<element define="1">
<name>EVT_StateChanged</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is fired, if the application state changed.</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpApp_StateChanged</param>
</element>
<element define="1">
<name>AS_NONE</name>
<key>UINT32_C</key>
<category>Application state</category>
<description>
<ul>
<li>AS_NONE: Unspecified state</li>
<li>AS_RUN: Application in run</li>
<li>AS_STOP: Application in stop</li>
<li>AS_DEBUG_HALT_ON_BP: Application halted on breakpoint</li>
<li>AS_DEBUG_STEP: Not used actually</li>
<li>AS_SYSTEM_APPLICATION: State of a system application</li>
</ul>
</description>
</element>
<element define="1">
<name>OS_NONE</name>
<key>UINT32_C</key>
<category>Application operating state</category>
<description>
<ul>
<li>OS_NONE: Unspecified state (init state)</li>
<li>OS_PROGRAM_LOADED: Application is completely loaded</li>
<li>OS_DOWNLOAD: Application download in progress</li>
<li>OS_ONLINE_CHANGE: Application online-change in progress</li>
<li>OS_STORE_BOOTPROJECT: Store bootproject in progress</li>
<li>OS_FORCE_ACTIVE: Force values is active on the application</li>
<li>OS_EXCEPTION: Application is in exception state (an exception occurred in this application)</li>
<li>OS_RUN_AFTER_DOWNLOAD: Download code at the end of download is in progress (initialization of the application)</li>
<li>OS_STORE_BOOTPROJECT_ONLY: Only the bootproject is stored at download</li>
<li>OS_EXIT: Application exit is still executed (application is no longer active)</li>
<li>OS_DELETE: Application is deleted (object is available, but the content is stil deleted)</li>
<li>OS_RESET: Application reset is in progress</li>
<li>OS_RETAIN_MISMATCH: Retain mismatch occurred during loading the bootproject (retain data does not match to the application)</li>
<li>OS_BOOTPROJECT_VALID: Bootproject available (bootproject matched to running application in RAM)</li>
<li>OS_LOAD_BOOTPROJECT: Loading bootproject in progress</li>
<li>OS_FLOW_ACTIVE: Flow control active</li>
<li>OS_RESET_OUTPUTS: Forcing reset outputs if task cycle is called</li>
</ul>
</description>
</element>
<element define="1">
<name>APP_STOP_REASON_UNKNOWN</name>
<key>0</key>
<category>Stop reason</category>
<description>
Reason to set the application in stop.
</description>
<element name="APP_STOP_REASON_UNKNOWN" type="IN">Unknown reason</element>
<element name="APP_STOP_REASON_SHUTDOWN" type="IN">Shutdown of the plc</element>
<element name="APP_STOP_REASON_RESET" type="IN">Reset will be done after stop the application</element>
<element name="APP_STOP_REASON_EXCEPTION" type="IN">Exception occurred</element>
<element name="APP_STOP_REASON_USER" type="IN">User stopped the application</element>
<element name="APP_STOP_REASON_IECPROGRAM" type="IN">Stop is done out of the IEC program</element>
<element name="APP_STOP_REASON_DELETE" type="IN">Application will be deleted after the stop</element>
<element name="APP_STOP_REASON_DEBUGGING" type="IN">Application will be stopped because of debugging</element>
<element name="APP_STOP_REASON_RUNSTOP_SWITCH" type="IN">Application will be stopped because the RunStop switch is on stop</element>
</element>
<element define="1">
<name>USERDB_OBJECT_PLCLOGIC</name>
<key>Device.PlcLogic</key>
<category>Static defines</category>
<description>Predefined objects in the runtime</description>
</element>
<element define="1">
<name>TEXT_PROPERTY_PROJECT</name>
<key>Project</key>
<category>Property keys</category>
<element name="TEXT_PROPERTY_PROJECT" type="IN">Project name</element>
<element name="TEXT_PROPERTY_TITLE" type="IN">Title</element>
<element name="TEXT_PROPERTY_AUTHOR" type="IN">Author</element>
<element name="TEXT_PROPERTY_DESCRIPTION" type="IN">Description</element>
<element name="VERSION_PROPERTY_PROJECTVERSION" type="IN">Project version</element>
</element>
<element define="1">
<name>AF_SYSTEM_APPLICATION</name>
<key>UINT32_C</key>
<category>Application flags</category>
<description>
Flags to specify properties of an application
</description>
<element name="AF_SYSTEM_APPLICATION" type="IN">This is  a system application</element>
<element name="AF_IOCONFIG_BYTE_ADDRESSING" type="IN">Byte addressing for all IO channels is activated on the target.
e.g. "%IW8" means byte 8 and not byte 16 in this case!</element>
<element name="AF_IOCONFIG_BIT_WORD_ADDRESSING" type="IN">Bits are byte adressed.
e.g. "%IX2.3" means bit 3 in word 2 instead of in byte 2!</element>
<element name="AF_KEEP_AT_PARENT_ONLINE_CHANGE" type="IN">This application will survive an online change of the parent application (not a download!)</element>
</element>
<element define="1">
<name>DLF_CONTINUEDOWNLOAD</name>
<key>UINT32_C</key>
<category>Download flags</category>
<description>
Download flags that are transmitted with each download.
</description>
<element name="DLF_CONTINUEDOWNLOAD" type="IN">Continue download, if download is transmitted in several blocks</element>
<element name="DLF_USEBOOTAPPFROMDOWNLOAD" type="IN">This flag indicates newer PS where the user can define whether a boot project shall be written
(to switch on next flag)</element>
<element name="DLF_WRITEBOOTAPPLICATION" type="IN">This flag indicates that a the boot application shall be written with download</element>
</element>
<element define="1">
<name>RTS_RESET</name>
<key>0</key>
<category>Reset options</category>
<description>
Warm reset. All gobal data except retain data is reset to their default values.
</description>
</element>
<element define="1">
<name>RTS_RESET_COLD</name>
<key>1</key>
<category>Reset options</category>
<description>
Cold reset. All gobal data AND retain data is reset to their default values.
</description>
</element>
<element define="1">
<name>RTS_RESET_ORIGIN</name>
<key>2</key>
<category>Reset options</category>
<description>
Origin reset. Delete the application, delete all application files (bootproject, etc.),
reset all gobal and retain data. After this command, the controller doesn't know anything about the
the application.</description>
</element>
<element define="1">
<name>SRV_LOGIN_APP</name>
<key>0x01</key>
<category>Online services</category>
<description>
</description>
</element>
<element define="1">
<name>TAG_DATA_AREA</name>
<key>0x01</key>
<category>Online tags</category>
<description>
</description>
</element>
<element define="1">
<name>TAG_REPLY_EXTERNAL_REFERENCE_ERROR_LIST</name>
<key>0x01</key>
<category>Online reply tags</category>
<description>
</description>
</element>
<element typedefinition="1">
<name>EVTPARAM_CmpApp</name>
<structname>EVTPARAM_CmpApp</structname>
<category>Event parameter</category>
<element name="pApp" type="IN">Pointer to application description</element>
<rawdata>
typedef struct
{
	struct tagAPPLICATION* pApp;
} EVTPARAM_CmpApp;
</rawdata>
</element>
<element typedefinition="1">
<name>EVTPARAM_CmpApp_Reset</name>
<structname>EVTPARAM_CmpApp_Reset</structname>
<category>Event parameter</category>
<element name="pApp" type="IN">Pointer to application description</element>
<element name="usResetOption" type="IN">Reset option. See the category reset options for detailed information</element>
<rawdata>
typedef struct
{
	struct tagAPPLICATION* pApp;
	RTS_UI16 usResetOption;
} EVTPARAM_CmpApp_Reset;
</rawdata>
</element>
<element typedefinition="1">
<name>EVTPARAM_CmpAppConfig</name>
<structname>EVTPARAM_CmpAppConfig</structname>
<category>Event parameter</category>
<element name="pApp" type="IN">Pointer to application description</element>
<element name="pszConfigApplication" type="IN">Pointer to the name of the config application</element>
<rawdata>
typedef struct
{
	struct tagAPPLICATION* pApp;
	char* pszConfigApplication;
} EVTPARAM_CmpAppConfig;
</rawdata>
</element>
<element typedefinition="1">
<name>EVTPARAM_CmpAppStop</name>
<structname>EVTPARAM_CmpAppStop</structname>
<category>Event parameter</category>
<element name="pApp" type="IN">Pointer to application description</element>
<element name="ulStopReason" type="IN">Stop reason. See category "Stop reason" for details</element>
<rawdata>
typedef struct
{
	struct tagAPPLICATION* pApp;
	unsigned long ulStopReason;
} EVTPARAM_CmpAppStop;
</rawdata>
</element>
<element typedefinition="1">
<name>EVTPARAM_CmpAppDenyStart</name>
<structname>EVTPARAM_CmpAppDenyStart</structname>
<category>Event parameter</category>
<element name="pApp" type="IN">Pointer to application description</element>
<element name="bDeny" type="OUT">1=Start is denied, 0=start is executed</element>
<rawdata>
typedef struct
{
	struct tagAPPLICATION* pApp;
	int bDeny;
} EVTPARAM_CmpAppDenyStart;
</rawdata>
</element>
<element typedefinition="1">
<name>EVTPARAM_CmpAppDenyStop</name>
<structname>EVTPARAM_CmpAppDenyStop</structname>
<category>Event parameter</category>
<element name="pApp" type="IN">Pointer to application description</element>
<element name="ulStop" type="IN">Reason for the stop, see corresponding category</element>
<element name="bDeny" type="OUT">1=Stop is denied, 0=stop is executed</element>
<rawdata>
typedef struct
{
	struct tagAPPLICATION* pApp;
	unsigned long ulStopReason;
	int bDeny;
} EVTPARAM_CmpAppDenyStop;
</rawdata>
</element>
<element typedefinition="1">
<name>EVTPARAM_CmpAppAllBootAppsLoaded</name>
<structname>EVTPARAM_CmpAppAllBootAppsLoaded</structname>
<category>Event parameter</category>
<element name="nTotalBootApps" type="IN">Number of boot applications to be loaded</element>
<element name="nSuccessfullyLoadedBootApps" type="IN">Number of boot applications which could be loaded successfully</element>
<rawdata>
typedef struct
{
	int nTotalBootApps;
	int nSuccessfullyLoadedBootApps;
} EVTPARAM_CmpAppAllBootAppsLoaded;
</rawdata>
</element>
<element typedefinition="1">
<name>EVTPARAM_CmpAppDenyLoadBootproject</name>
<structname>EVTPARAM_CmpAppDenyLoadBootproject</structname>
<category>Event parameter</category>
<element name="pszAppName" type="IN">Name of the application</element>
<element name="bDeny" type="OUT">1=Load bootproject is denied, 0=loading bootproject is be executed</element>
<rawdata>
typedef struct
{
	char *pszAppName;
	int bDeny;
} EVTPARAM_CmpAppDenyLoadBootproject;
</rawdata>
</element>
<element typedefinition="1">
<name>EVTPARAM_CmpAppPrepareLoadBootproject</name>
<structname>EVTPARAM_CmpAppPrepareLoadBootproject</structname>
<category>Event parameter</category>
<element name="pszAppName" type="IN">Name of the application</element>
<rawdata>
typedef struct
{
	char *pszAppName;
} EVTPARAM_CmpAppPrepareLoadBootproject;
</rawdata>
</element>
<element typedefinition="1">
<name>EVTPARAM_CmpAppException</name>
<structname>EVTPARAM_CmpAppException</structname>
<category>Event parameter</category>
<element name="pApp" type="IN">Pointer to application object</element>
<element name="hIecTask" type="IN">Handle to IEC task</element>
<element name="ulException" type="IN">Exception number. See category "Exception code" in SysExceptItf.h</element>
<rawdata>
typedef struct
{
	struct tagAPPLICATION *pApp;
	RTS_HANDLE hIecTask;
	RTS_UI32 ulException;
} EVTPARAM_CmpAppException;
</rawdata>
</element>
<element typedefinition="1">
<name>EVTPARAM_CmpAppRegisterBootproject</name>
<structname>EVTPARAM_CmpAppRegisterBootproject</structname>
<category>Event parameter</category>
<element name="pszAppName" type="IN">Name of the application</element>
<rawdata>
typedef struct
{
	char *pszAppName;
} EVTPARAM_CmpAppRegisterBootproject;
</rawdata>
</element>
<element typedefinition="1">
<name>EVTPARAM_CmpAppOperatingStateChanged</name>
<structname>EVTPARAM_CmpAppOperatingStateChanged</structname>
<category>Event parameter</category>
<element name="pApp" type="IN">Pointer to application object. ulOpState contains the actual state!</element>
<element name="ulPrevOpState" type="IN">Previous operating state</element>
<rawdata>
typedef struct
{
	struct tagAPPLICATION *pApp;
	RTS_UI32 ulPrevOpState;
} EVTPARAM_CmpAppOperatingStateChanged;
</rawdata>
</element>
<element typedefinition="1">
<name>EVTPARAM_CmpAppSourceDownload</name>
<structname>EVTPARAM_CmpAppSourceDownload</structname>
<category>Event parameter</category>
<element name="pszArchiveName" type="IN">Name of the archive</element>
<element name="bBegin" type="IN">1: If source download started, 0: If source download ends</element>
<rawdata>
typedef struct
{
	char *pszArchiveName;
	char bBegin;
} EVTPARAM_CmpAppSourceDownload;
</rawdata>
</element>
<element typedefinition="1">
<name>EVTPARAM_CmpAppComm</name>
<structname>EVTPARAM_CmpAppComm</structname>
<category>Event parameter</category>
<element name="pApp" type="IN">Pointer to application object. ulOpState contains the actual state!</element>
<element name="ulSessionId" type="IN">Online sessionid on the deive. Can be used to get the actual logged in User on this channel!</element>
<element name="ulAppSessionId" type="IN">Online application sessionid that is provided during the client is logged in on the application</element>
<rawdata>
typedef struct
{
	struct tagAPPLICATION *pApp;
	RTS_UI32 ulSessionId;
	RTS_UI32 ulAppSessionId;
} EVTPARAM_CmpAppComm;
</rawdata>
</element>
<element typedefinition="1">
<name>EVTPARAM_CmpAppDeny</name>
<structname>EVTPARAM_CmpAppDeny</structname>
<category>Event parameter</category>
<element name="pApp" type="IN">Pointer to application object. ulOpState contains the actual state!</element>
<element name="bDeny" type="OUT">1: Operation is denied, 0: Operation can be executed</element>
<rawdata>
typedef struct
{
	struct tagAPPLICATION *pApp;
	int bDeny;
} EVTPARAM_CmpAppDeny;
</rawdata>
</element>
<element typedefinition="1">
<name>EVTPARAM_CmpAppDenyDelete</name>
<structname>EVTPARAM_CmpAppDenyDelete</structname>
<category>Event parameter</category>
<element name="pApp" type="IN">Pointer to application object. ulOpState contains the actual state!</element>
<element name="bShutdown" type="IN">1: Runtime is deleting the application during shutdown, 0: else</element>
<element name="bDeny" type="OUT">1: Operation is denied, 0: Operation can be executed</element>
<rawdata>
typedef struct
{
	struct tagAPPLICATION *pApp;
	int bShutdown;
	int bDeny;
} EVTPARAM_CmpAppDenyDelete;
</rawdata>
</element>
<element typedefinition="1">
<name>EVTPARAM_CmpApp_OEMServiceTag</name>
<structname>EVTPARAM_CmpApp_OEMServiceTag</structname>
<category>Event parameter</category>
<element name="pApp" type="IN">Pointer to application object. ulOpState contains the actual state!</element>
<element name="ulChannelId" type="IN">ChannelID of the actial online service</element>
<element name="ulToplevelTag" type="IN">ToplevelTag in the actial online service. NOTE: Highword must be the VendorID to have unique tags!</element>
<element name="pHeaderTag" type="IN">Header of the actual online service</element>
<element name="pReader" type="IN">Reader of the actual service to read OEM specific tags (some tags could be still consumed by the kernel)</element>
<element name="pWriter" type="IN">Writer of the actual service to send back a reply of the consumed OEM tag</element>
<element name="Result" type="OUT">Result of the tag handling. If an error is returned here, the download service will be cancelled!</element>
<rawdata>
typedef struct
{
	struct tagAPPLICATION *pApp;
	RTS_UI32 ulChannelId;
	RTS_UI32 ulToplevelTag;
	HEADER_TAG *pHeaderTag;
	BINTAGREADER *pReader;
	BINTAGWRITER *pWriter;
	RTS_RESULT Result;
} EVTPARAM_CmpApp_OEMServiceTag;
</rawdata>
</element>
<element typedefinition="1">
<name>EVTPARAM_CmpApp_OEMRegisteredIecFunction</name>
<structname>EVTPARAM_CmpApp_OEMRegisteredIecFunction</structname>
<category>Event parameter</category>
<element name="pApp" type="IN">Pointer to application object</element>
<element name="pInfo" type="IN">Pointer to function info.
NOTE:
The function pointer pointer can be retrieved with:

RTS_VOID_FCTPTR *ppfFunction = NULL;
unsigned char *pucArea;
RTS_RESULT Result = AppGetAreaPointer(pInfo->pApp, pInfo->usArea, &amp;pucArea);
if (Result == ERR_OK)
ppfFunction = (RTS_VOID_FCTPTR *)(pucArea + pInfo->ulOffset);
</element>
<element name="pszName" type="IN">Pointer to name of the function</element>
<rawdata>
typedef struct
{
	struct tagAPPLICATION *pApp;
	struct T_FUNCTION_INFO *pInfo;
	char *pszName;
} EVTPARAM_CmpApp_OEMRegisteredIecFunction;
</rawdata>
</element>
<element typedefinition="1">
<name>EVTPARAM_CmpApp_POUTable_Create</name>
<structname>EVTPARAM_CmpApp_POUTable_Create</structname>
<category>Event parameter</category>
<element name="pTable" type="IN">Pointer to a table of POU entries which is being added</element>
<rawdata>
typedef struct
{
	struct tagAREA_CALL_ENTRIES_TABLE*	pTable;
} EVTPARAM_CmpApp_POUTable_Create;
</rawdata>
</element>
<element typedefinition="1">
<name>EVTPARAM_CmpApp_POUTable_Build</name>
<structname>EVTPARAM_CmpApp_POUTable_Build</structname>
<category>Event parameter</category>
<element name="pTable" type="IN">Pointer to a table of POU entries which is being built</element>
<rawdata>
typedef struct
{
	struct tagAREA_CALL_ENTRIES_TABLE*	pTable;
} EVTPARAM_CmpApp_POUTable_Build;
</rawdata>
</element>
<element typedefinition="1">
<name>EVTPARAM_CmpApp_POUTable_Clear</name>
<structname>EVTPARAM_CmpApp_POUTable_Clear</structname>
<category>Event parameter</category>
<element name="pTable" type="IN">Pointer to a table of POU entries which is being cleared</element>
<rawdata>
typedef struct
{
	struct tagAREA_CALL_ENTRIES_TABLE*	pTable;
} EVTPARAM_CmpApp_POUTable_Clear;
</rawdata>
</element>
<element typedefinition="1">
<name>EVTPARAM_CmpApp_POUTable_Remove</name>
<structname>EVTPARAM_CmpApp_POUTable_Remove</structname>
<category>Event parameter</category>
<element name="pTable" type="IN">Pointer to a table of POU entries which is being deleted</element>
<rawdata>
typedef struct
{
	struct tagAREA_CALL_ENTRIES_TABLE*	pTable;
} EVTPARAM_CmpApp_POUTable_Remove;
</rawdata>
</element>
<element typedefinition="1">
<name>EVTPARAM_CmpApp_POUTable_AddElement</name>
<structname>EVTPARAM_CmpApp_POUTable_AddElement</structname>
<category>Event parameter</category>
<element name="pTable" type="IN">Pointer to a table of POU entries to which a new element is being added</element>
<element name="pElement" type="IN">Pointer to an element which is being added</element>
<element name="Result" type="OUT">Returns ERR_OK if the element can be added</element>
<rawdata>
typedef struct
{
	struct tagAREA_CALL_ENTRIES_TABLE*	pTable;
	struct tagPOU_CALL_ENTRY*			pElement;
	RTS_RESULT							Result;
} EVTPARAM_CmpApp_POUTable_AddElement;
</rawdata>
</element>
<element typedefinition="1">
<name>EVTPARAM_CmpApp_POUTable_RemoveElement</name>
<structname>EVTPARAM_CmpApp_POUTable_RemoveElement</structname>
<category>Event parameter</category>
<element name="pTable" type="IN">Pointer to a table of POU entries from which an element is being removed</element>
<element name="pElement" type="IN">Pointer to an element which is being removed</element>
<rawdata>
typedef struct
{
	struct tagAREA_CALL_ENTRIES_TABLE*	pTable;
	struct tagPOU_CALL_ENTRY*			pElement;
} EVTPARAM_CmpApp_POUTable_RemoveElement;
</rawdata>
</element>
<element typedefinition="1">
<name>EVTPARAM_CmpApp_CommCycle</name>
<structname>EVTPARAM_CmpApp_CommCycle</structname>
<category>Event parameter</category>
<element name="ulParam1" type="IN">Type of the COMM_CYCLE_HOOK. See CMItf.h, CM_HOOK_TYPE types.</element>
<element name="ulParam2" type="IN">Second parameter. Hook dependant, typically 0</element>
<rawdata>
typedef struct
{
	RTS_UINTPTR ulParam1;
	RTS_UINTPTR ulParam2;
} EVTPARAM_CmpApp_CommCycle;
</rawdata>
</element>
<element typedefinition="1">
<name>EVTPARAM_CmpApp_StateChanged</name>
<structname>EVTPARAM_CmpApp_StateChanged</structname>
<category>Event parameter</category>
<element name="pApp" type="IN">Pointer to application object. pApp->ulState contains the actual state! See category "Application state" for details.</element>
<element name="ulPrevState" type="IN">Previous application state</element>
<rawdata>
typedef struct
{
	struct tagAPPLICATION *pApp;
	RTS_UI32 ulPrevState;
} EVTPARAM_CmpApp_StateChanged;
</rawdata>
</element>
<element typedefinition="1">
<name>POU_DESCRIPTOR</name>
<structname>POU_DESCRIPTOR</structname>
<description>
<p>POU Descriptor.</p>

<p>This type might be extending in future somehow
that's why CODE_INFO etc. are not used here.</p></description>
<rawdata>
typedef struct tagPOU_DESCRIPTOR
{
	POU offset from the start of the code segment
	RTS_SIZE	offset;

	POU size
	RTS_SIZE	size;

} POU_DESCRIPTOR;
</rawdata>
</element>
<element typedefinition="1">
<name>POU_CALL_ENTRY</name>
<structname>POU_CALL_ENTRY</structname>
<description>Descriptor for a callable entity.</description>
<rawdata>
typedef struct tagPOU_CALL_ENTRY
{
	for intrusive doubly-linked list
	struct tagPOU_CALL_ENTRY*	pNext;
	struct tagPOU_CALL_ENTRY* pPrev;

	POU information
	POU_DESCRIPTOR						pou;

	Optional target specific object that can be
	attached to this entry.
	void*								pTargetSpecificObject;

} POU_CALL_ENTRY;
</rawdata>
</element>
<element typedefinition="1">
<name>AREA_CALL_ENTRIES_TABLE</name>
<structname>AREA_CALL_ENTRIES_TABLE</structname>
<description>
<p>Table of POU entries.</p>

<p>The life-cycle of this object coincides with the life-cycle
of the corresponding code area.</p></description>
<rawdata>
typedef struct tagAREA_CALL_ENTRIES_TABLE
{
	Handle to the Table Manager
	RTS_HANDLE				hTablesManager;

	Link to the next table
	struct tagAREA_CALL_ENTRIES_TABLE* pNext;

	Code area start address
	RTS_UI8*				pCode;

	Code area size
	RTS_SIZE				size;

	Entries list
	POU_CALL_ENTRY*			pHead;
	POU_CALL_ENTRY*			pTail;

	Table size for quickening certain operations
	RTS_SIZE				elementsCount;

	Elements allocator (dynamic memory pool)
	RTS_HANDLE			hElementsPool;

	Table state flags
	RTS_SIZE				flags;

	Optional target specific object that can be
	attached to this table.
	union
	{
		void*		pPtrValue;
		RTS_SIZE	value;
	}						targetSpecificObject;

} AREA_CALL_ENTRIES_TABLE;
</rawdata>
</element>
<element typedefinition="1">
<name>PROJECT_INFO</name>
<structname>PROJECT_INFO</structname>
<category>Project information</category>
<description>
Contains the project information as specified in the project information dialog in CoDeSys. To use this, the checkbox
"Automatically generate POUs for property access" in the project information dialog be enabled.
</description>
<element name="stProjectName" type="OUT">Project name without ending</element>
<element name="stTitle" type="OUT">Title</element>
<element name="stVersion" type="OUT">Version as string in the format "x.x.x.x"</element>
<element name="stAuthor" type="OUT">Author</element>
<element name="stDescription" type="OUT">Description</element>
<rawdata>
typedef struct
{
	RTS_IEC_STRING stProjectName[81];
	RTS_IEC_STRING stTitle[81];
	RTS_IEC_STRING stVersion[81];
	RTS_IEC_STRING stAuthor[81];
	RTS_IEC_STRING stDescription[81];
} PROJECT_INFO;
</rawdata>
</element>
<element typedefinition="1">
<name>APPLICATION_INFO</name>
<structname>APPLICATION_INFO</structname>
<category>Application information</category>
<description>
Contains the application information as specified in the application property dialog in CoDeSys.
</description>
<element name="pstProjectName" type="OUT">Pointer project name</element>
<element name="pstAuthor" type="OUT">Pointer to author</element>
<element name="pstVersion" type="OUT">Pointer to version as string in the format "x.x.x.x"</element>
<element name="pstDescription" type="OUT">Pointer to description</element>
<element name="pstProfile" type="OUT">Pointer to used CoDeSys profile name</element>
<element name="dtLastChanges" type="OUT">Time and date of last modification of the application (UTC)</element>
<rawdata>
typedef struct
{
	RTS_IEC_STRING *pstProjectName;
	RTS_IEC_STRING *pstAuthor;
	RTS_IEC_STRING *pstVersion;
	RTS_IEC_STRING *pstDescription;
	RTS_IEC_STRING *pstProfile;
	RTS_IEC_DATE_AND_TIME dtLastChanges;
} APPLICATION_INFO;
</rawdata>
</element>
<element typedefinition="1">
<name>APP_MEMORY_SEGMENT</name>
<structname>APP_MEMORY_SEGMENT</structname>
<category>Application memory segment</category>
<description>
Describes a memory segment of an application.
</description>
<element name=" wType " type="IN">Type of the segment. See category "Area Types" in SysMemItf.h.</element>
<element name="wArea" type="IN">Area in whcih the segment is residing</element>
<element name="dwOffset" wType="IN">Offset in the area, in which the segment is residing</element>
<element name="dwSize" wType="IN">Size of the segment in bytes</element>
<element name="dwHighestUsedAddress" wType="IN">Highest used address in the segment (has no significance for input, output, memory)</element>
<rawdata>
typedef struct _APP_MEMORY_SEGMENT
{
	RTS_IEC_WORD wType;
	RTS_IEC_WORD wArea;
	RTS_IEC_DWORD dwOffset;
	RTS_IEC_DWORD dwSize;
	RTS_IEC_DWORD dwHighestUsedAddress;
} APP_MEMORY_SEGMENT;
</rawdata>
</element>
<element typedefinition="1">
<name>APP_MEMORY_SEGMENT_INFO</name>
<structname>APP_MEMORY_SEGMENT_INFO</structname>
<category>Application memory segment information</category>
<description>
Describes all memory segments of an application.
</description>
<element name="diSegments" type="IN">Number of segments</element>
<element name="pmsList" type="IN">Pointer to memory segment list</element>
<rawdata>
typedef struct _APP_MEMORY_SEGMENT_INFO
{
	RTS_IEC_DINT diSegments;
	APP_MEMORY_SEGMENT *pmsList;
} APP_MEMORY_SEGMENT_INFO;
</rawdata>
</element>
<element typedefinition="1">
<name>APPLICATION</name>
<structname>APPLICATION</structname>
<SIL2/>
<category>Application description</category>
<description>
ATTENTION: Allways add new elements at the end of the structure!!! This structure will be referred
to generated IEC task code!
</description>
<element name="pAppParent" type="IN">Pointer to parent application</element>
<element name="iId" type="IN">Id of the application. Is always unique.</element>
<element name="CodeGuid" type="IN">Unique identifier of the IEC code</element>
<element name="DataGuid" type="IN">Unique identifier of the IEC data</element>
<element name="ulState" type="IN">State of the application (see corresponding category)</element>
<element name="ulOpState" type="IN">Operating state of the application (see corresponding category)</element>
<element name="hBootproject" type="IN">Handle to the bootproject. Is valid, if actually bootproject will be loaded</element>
<element name="hDebugTask" type="IN">Handle of the debug task (if debugging is active)</element>
<element name="pfGlobalInit" type="IN">Function pointer to the global init routine</element>
<element name="pfGlobalExit" type="IN">Function pointer to the global exit routine</element>
<element name="hForcePool" type="IN">Handle a pool of force entries</element>
<element name="hBPPool" type="IN">Handle a pool of breakpoints</element>
<element name="bPersistentForce" type="IN">Flag to detect, if persistent force is active</element>
<element name="szName" type="IN">Application name</element>
<element name="szBootprojectName" type="IN">Bootproject name of the application</element>
<element name="ulPSVersion" type="IN">Version number of programming system (set in download)</element>
<element name="ulTargetSettingVersion" type="IN">Version number of Target settings used by PS (set in download)</element>
<element name="pcArea" type="IN">Pointer to data areas of this application</element>
<element name="ausAreaType" type="IN">Area types. See category "Area Types" in SysMemItf.h.</element>
<element name="aulAreaSize" type="IN">Area sizes</element>
<element name="byForcePool" type="IN">Force pool. Only used, if CmpAppForce is available</element>
<element name="byBPPool" type="IN">Breakpoint pool. Only used, if CmpAppBP is available</element>
<element name="flowControl" type="IN">Flow control structure. Only used, if CmpAppBP is available and flow control is activated</element>
<element name="SafedCodeGuid" type="IN">Safed GUID of IEC code from bootproject</element>
<element name="SafedDataGuid" type="IN">Safed GUID of IEC data from bootproject</element>
<element name="rtRetainType" type="IN">Retain type of retain application data</element>
<element name="ulException" type="IN">Actual exception, if an exception occurred. In this case, ulOpState is set to OS_EXCEPTION.</element>
<element name="ApplicationInfo" type="IN">Application info</element>
<element name="pouMemorySegmentInfo" type="IN">POU reference to the memory segment info</element>
<element name="pouAppInfo" type="IN">Data Location of the application content information</element>
<element name="ulCRCBootproject" type="IN">CRC of trhe bootproject. It is used temporary at creating the bootproject to calculate the CRC during the complete store process.</element>
<element name="aAreaCRC" type="IN">List of CRCs for every memory area. The CRC is calculated over the content of the area (e.g. if it is a retain area, the CRC is calculated
over the names and types of the retain variables). Additionally the CRC contains the application name to be always unique over all applications!</element>
<element name="hBPConditionPool" type="IN">Handle a pool of breakpoint conditions.</element>
<rawdata>
typedef struct tagAPPLICATION
{
	struct tagAPPLICATION *pAppParent;
	RTS_I32 iId;
	
	RTS_GUID CodeGuid;
	RTS_GUID DataGuid;

	RTS_UI32 ulState;
	RTS_UI32 ulOpState;
	RTS_HANDLE hBootproject;
	RTS_HANDLE hDebugTask;
	PF_GLOBAL_INIT pfGlobalInit;
	PF_GLOBAL_EXIT pfGlobalExit;

	RTS_HANDLE hDummy;		Was previously hSessionIdPool, but is removed. Because of backward compatibility, it must be remaining here!
	RTS_HANDLE hForcePool;
	RTS_HANDLE hBPPool;

	RTS_I32 bPersistentForce;

	char szName[MAX_LEN_APPLNAME];
	char szBootprojectName[MAX_PATH_LEN + MAX_LEN_APPLNAME];

	RTS_UI32 ulPSVersion;
	RTS_UI32 ulTargetSettingVersion;

	ATTENTION: The member variables above are exported via CmpApp.library in IEC! Don't do any changes in this area!!!

	RTS_UI8 *pcArea[APPL_NUM_OF_STATIC_AREAS];
	RTS_UI16 ausAreaType[APPL_NUM_OF_STATIC_AREAS];
	RTS_UI32 aulAreaSize[APPL_NUM_OF_STATIC_AREAS];

	RTS_UI8 byForcePool[MEM_GET_STATIC_LEN_(0,0)];
	RTS_UI8 byBPPool[MEM_GET_STATIC_LEN_(0,0)];
	FlowControl flowControl;
	
	RTS_GUID SafedCodeGuid;
	RTS_GUID SafedDataGuid;

	RetainType rtRetainType;

	RTS_UI32 ulException;
	RTS_I32 bInvalidateByRename;
	RTS_I32 bInvalidateBySetting;
	RTS_UINTPTR consistencyFlags;

	RTS_VOID_FCTPTR *ppfGetBooleanProperty;
	RTS_VOID_FCTPTR *ppfGetTextProperty;
	RTS_VOID_FCTPTR *ppfGetNumberProperty;
	RTS_VOID_FCTPTR *ppfGetVersionProperty;

	RTS_I32 bInitRetains;

	RTS_UI32 ulFlags;						Application flags. See corresponding category.
	RTS_UI32 ulOffsetExtRefFunctionPointer; Area must be area 0! Offset must be valid for SystemApplications. The offset where to find the function to link functions 

	APPLICATION_INFO ApplicationInfo;
	POU_REF pouMemorySegmentInfo;
	POU_REF pouAppInfo;
	RTS_UI32 ulCRCBootproject;
	RTS_UI32 aulAreaCRC[APPL_NUM_OF_STATIC_AREAS];
	RTS_HANDLE hBPConditionPool;

	ATTENTION: Always append new elements at the end of this structure!
} APPLICATION;
</rawdata>
</element>
<element typedefinition="1">
<name>COMPACT_CODE_HEADER</name>
<structname>COMPACT_CODE_HEADER</structname>
<SIL2/>
<category>Compact download header</category>
<description>
This header is sent right at the beginning of each compact download stream
</description>
<element name="ulHeaderTag" type="IN">Header tag = COMPACT_DOWNLOAD_HEADER_TAG</element>
<element name="ulHeaderVersion" type="IN">Header version = COMPACT_DOWNLOAD_HEADER_VERSION</element>
<element name="ulHeaderSize" type="IN">Header size</element>
<element name="ulTotalSize" type="IN">Header size including all download segments</element>
<element name="ulDeviceType" type="IN">Device type of the selected device</element>
<element name="ulDeviceId" type="IN">Device ID of the selected device</element>
<element name="ulDeviceVersion" type="IN">Device version of the selected device</element>
<element name="ulFlags" type="IN">Download flags (LOW Word), Application flags (HIGH Word). See corresponding categories.</element>
<element name="ulCompilerVersion" type="IN">Compiler version of used CoDeSys version</element>
<element name="ulCodeAreaSize" type="IN">Code area size</element>
<element name="usCodeAreaIndex" type="IN">Code area index</element>
<element name="usCodeAreaFlags" type="IN">Code area flags</element>
<element name="ulOffsetCode" type="IN">Offset in bytes, where the code segment begins</element>
<element name="ulSizeCode" type="IN">Size in bytes of the code segment</element>
<element name="ulOffsetApplicationInfo" type="IN">Offset in bytes, where the application info segment begins</element>
<element name="ulSizeApplicationInfo" type="IN">Size in bytes of the application info segment</element>
<element name="ulOffsetAreaTable" type="IN">Offset in bytes, where the area table segment begins</element>
<element name="ulSizeAreaTable" type="IN">Size in bytes of the area table segment</element>
<element name="ulOffsetFunctionTable" type="IN">Offset in bytes, where the function table segment begins, Here the link function are specified:
- CodeInit
- GlobalInit
- GlobalExit
- Reloc
- DownloadCode
- TargetInfo
</element>
<element name="ulSizeFunctionTable" type="IN">Size in bytes of the function table segment</element>
<element name="ulOffsetExternalFunctionTable" type="IN">Offset in bytes, where the external function table segment begins to link c functions against iec code</element>
<element name="ulSizeExternalFunctionTable" type="IN">Size in bytes of the external function table segment</element>
<element name="ulOffsetRegisterIecFunctionTable" type="IN">Offset in bytes, where the iec function table segment begins to link iec functions against the runtime system</element>
<element name="ulSizeRegisterIecFunctionTable" type="IN">Size in bytes of the external function table segment</element>
<element name="ulOffsetSourceCode" type="IN">Offset in bytes, where the optional sourcecode segment begins</element>
<element name="ulSizeSourceCode" type="IN">Size in bytes of the optional sourcecode segment</element>
<element name="ulCrc" type="IN">CRC32 of the complete download stream including the header with ulCRC written to 0!</element>
<rawdata>
typedef struct _COMPACT_CODE_HEADER
{
    RTS_UI32 ulHeaderTag;
    RTS_UI32 ulHeaderVersion;
    RTS_UI32 ulHeaderSize;
    RTS_UI32 ulTotalSize;
    RTS_UI32 ulDeviceType;
    RTS_UI32 ulDeviceId;
    RTS_UI32 ulDeviceVersion;
    RTS_UI32 ulFlags;
    RTS_UI32 ulCompilerVersion;
    RTS_UI32 ulCodeAreaSize;
    RTS_UI16 usCodeAreaIndex;
    RTS_UI16 usCodeAreaFlags;
    RTS_UI32 ulOffsetCode;
    RTS_UI32 ulSizeCode;
    RTS_UI32 ulOffsetApplicationInfo;
    RTS_UI32 ulSizeApplicationInfo;
    RTS_UI32 ulOffsetAreaTable;
    RTS_UI32 ulSizeAreaTable;
    RTS_UI32 ulOffsetFunctionTable;
    RTS_UI32 ulSizeFunctionTable;
    RTS_UI32 ulOffsetExternalFunctionTable;
    RTS_UI32 ulSizeExternalFunctionTable;
    RTS_UI32 ulOffsetRegisterIecFunctionTable;
    RTS_UI32 ulSizeRegisterIecFunctionTable;
    RTS_UI32 ulOffsetSourceCode;
    RTS_UI32 ulSizeSourceCode;
    RTS_UI32 ulCrc;
} COMPACT_CODE_HEADER;
</rawdata>
</element>
<element function="1">
<functionname returntype="void" parameters="(appnumofactivesessions_struct *p)">appnumofactivesessions</functionname>
<description>Retrieves the number of active sessions</description>
<param name="pApp" type="IN">Pointer to application.</param>
<param name="pulNumSessions" type="OUT">Number of active sessions.</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="APPLICATION*" parameters="(char* pszAppName, char* pszAppParentName, RTS_RESULT *pResult)">AppCreateApplication</functionname>
<description>Creates an application specified by name</description>
<param name="pszAppName" type="IN">Pointer to name of the application</param>
<param name="pszAppParentName" type="IN">Pointer to name of the parent application (if a child application should be created). Can be NULL.</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Pointer to the application description</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION* pApp, int bOnlineChange, int bCreateBootproject)">AppPrepareDownload</functionname>
<description>Prepares a new download or online-change</description>
<param name="pApp" type="IN">Pointer to the specified application description</param>
<param name="bOnlineChange" type="IN">1=Online change, 0=Download</param>
<param name="bCreateBootproject" type="IN">1=Create implicitly a bootproject, 0=Create no bootproject</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION *pApp, RTS_UI8 *pbyCode, RTS_SIZE ulCodeLen, RTS_SIZE ulCodeOffset, int bLoadBootproject)">AppAppendCode</functionname>
<description>Append IEC code for each code fragment.
NOTE: Actually only available for CmpAppEmbedded!
</description>
<param name="pApp" type="IN">Pointer to the specified application description</param>
<param name="pbyCode" type="IN">Pointer to code part</param>
<param name="ulCodeLen" type="IN">Code fragment length</param>
<param name="ulCodeOffset" type="IN">Code offset of the fragment, to write to</param>
<param name="bLoadBootproject" type="IN">1=Function is called at loading bootproject, 0=Else (e.g. at download sequence)</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION* pApp, int bOnlineChange, BINTAGWRITER *pWriter)">AppCompleteDownload</functionname>
<description>Complete the download and init application.
NOTE: Actually only available for CmpAppEmbedded!
</description>
<param name="pApp" type="IN">Pointer to the specified application description</param>
<param name="bOnlineChange" type="IN">1=Online change, 0=Download</param>
<param name="pWriter" type="IN">Pointer to the online writer. Can be NULL.</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="APPLICATION*" parameters="(char *pszAppName, RTS_RESULT *pResult)">AppFindApplicationByName</functionname>
<description>Retrieves an application by name</description>
<param name="pszAppName" type="IN" range="[NULL,VALID_APPNAME]">Pointer to name of the application</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<errorcode name="RTS_RESULT pResult" type="ERR_OK">Application successfully retrieved</errorcode>
<errorcode name="RTS_RESULT pResult" type="ERR_PARAMETER">Parameter pszAppName may not be null</errorcode>
<result>Pointer to the application description, null if no App could not be found</result>
</element>
<element function="1">
<functionname returntype="APPLICATION*" parameters="(char *pszBootprojectName, RTS_RESULT *pResult)">AppFindApplicationByBootproject</functionname>
<description>Retrieves an application by name</description>
<param name="pszBootprojectName" type="IN">Pointer to name of the bootproject. Must not be the application name!</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Pointer to the application description</result>
</element>
<element function="1">
<functionname returntype="APPLICATION*" parameters="(RTS_UI32 ulSessionId, RTS_RESULT *pResult)">AppFindApplicationBySessionId</functionname>
<description>Retrieves an application by session id. The session id is an unique id that is provided
from the login service. There is a relation between the communication channel and the session id.</description>
<param name="ulSessionId" type="IN">SessionId from login service</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Pointer to the application description</result>
</element>
<element function="1">
<functionname returntype="APPLICATION*" parameters="(int iId, RTS_RESULT *pResult)">AppFindApplicationById</functionname>
<description>Retrieves an application by its id.</description>
<param name="iId" type="IN">Id of the application</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Pointer to the application description</result>
</element>
<element function="1">
<functionname returntype="int" parameters="(void)">AppGetNumOfApplications</functionname>
<description>Retrieves the number of registered and loaded applications.</description>
<result>Number of registered applications</result>
</element>
<element function="1">
<functionname returntype="APPLICATION*" parameters="(int iIndex, RTS_RESULT *pResult)">AppGetApplicationByIndex</functionname>
<description>Retrieves an application description sepcified by index</description>
<param name="iIndex" type="IN" range="[0..APPL_NUM_OF_STATIC_APPLS-1,APPL_NUM_OF_STATIC_APPLS..INT_MAX]">Index of the application list.</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<errorcode name="RTS_RESULT pResult" type="ERR_OK">Application successfully retrieved</errorcode>
<errorcode name="RTS_RESULT pResult" type="ERR_PARAMETER">Application with index iIndex not found</errorcode>
<result>Pointer to the application description</result>
</element>
<element function="1">
<functionname returntype="APPLICATION *" parameters="(void *pAddress, RTS_RESULT *pResult)">AppGetApplicationByAreaAddress</functionname>
<description>Retrieves an application description specified by area address</description>
<param name="pAddress" type="IN">area address.</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Pointer to the application description</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION *pApp, int iArea, unsigned char **ppucArea)">AppGetAreaPointer</functionname>
<description>Retrieves the pointer to a memory area specified by index</description>
<param name="pApp" type="IN" range="[NULL,VALID_PAPP]">Pointer to the specified application description</param>
<param name="iArea" type="IN" range="[-1,VALID_AREA_TYPE,(APPL_NUM_OF_STATIC_AREAS - 1)]">Area index</param>
<param name="ppucArea" type="OUT">Pointer pointer to the area</param>
<errorcode name="RTS_RESULT Result" type="ERR_OK">Pointer to Area successfully retrieved</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_PARAMETER">Parameter pApp may not be null, iArea may not be out of range: 0 - APPL_NUM_OF_STATIC_AREAS - 1</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_FAILED">Pointer to Area could not be retrieved</errorcode>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION *pApp, RTS_I32 iArea, RTS_UI8 **ppbyArea, RTS_SIZE *pulSize)">AppGetAreaPointer2</functionname>
<description>Retrieves the pointer and size of a memory area specified by index</description>
<param name="pApp" type="IN" range="[NULL,VALID_PAPP]">Pointer to the specified application description</param>
<param name="iArea" type="IN" range="[-1,VALID_AREA_TYPE,(APPL_NUM_OF_STATIC_AREAS - 1)]">Area index</param>
<param name="ppucArea" type="OUT">Pointer pointer to the area. Can be NULL to get only the area size.</param>
<param name="pulSize" type="OUT">Pointer to size to return the area size. Can be NULL to get only the area address.</param>
<errorcode name="RTS_RESULT Result" type="ERR_OK">Pointer to Area successfully retrieved</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_PARAMETER">Parameter pApp may not be null, iArea may not be out of range: 0 - APPL_NUM_OF_STATIC_AREAS - 1</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_FAILED">Pointer to Area could not be retrieved</errorcode>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char* pszAppName, int iArea, RTS_UI16 usType, unsigned char **ppucArea)">AppGetAreaPointerByType</functionname>
<description>Retrieves a pointer to the memory area specified by type and index</description>
<param name="pszAppName" type="IN">Application name</param>
<param name="iArea" type="IN">Area index</param>
<param name="usType" type="IN">Area type. See category "Area Types" in SysMemItf.h.</param>
<param name="ppucArea" type="OUT">Pointer pointer to the area</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION* pApp, RTS_VOID_FCTPTR pAddress)">AppHasAddress</functionname>
<description>Function checks, if the address is a part of the specified application (resides in an area)</description>
<param name="pApp" type="IN">Application</param>
<param name="pAddress" type="IN">Pointer to check. Can be a data pointer or a function pointer.</param>
<result>ERR_OK: pAddress is part of the specified application
ERR_FAILED: pAddress is not a part of the specified application
</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION *pApp, int* pbProgramLoaded)">AppIsProgramLoaded</functionname>
<description>Returns the load state of an application</description>
<param name="pApp" type="IN" range="[NULL,VALID_PAPP]">Pointer to the specified application description</param>
<parampseudo name="pApp.ulOpState" type="IN" range="[OS_NONE,OS_PROGRAM_LOADED,OS_DOWNLOAD,OS_EXCEPTION]">Pointer to the specified application description</parampseudo>
<param name="pbProgramLoaded" type="OUT">Pointer to result. If the application contains
a loaded project: *pbProgramLoaded is set to 1, else 0</param>
<errorcode name="RTS_RESULT Result" type="ERR_OK">Load state of application successfully retrieved</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_PARAMETER">Parameter pApp and pbProgramLoaded may not be null</errorcode>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION *pApp, int bProgramLoaded)">AppSetProgramLoaded</functionname>
<description>Set the load state of an application</description>
<param name="pApp" type="IN">Pointer to the specified application description</param>
<param name="bProgramLoaded" type="IN">1=Application is loaded, 0=Application is not loaded</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION *pApp)">AppSingleCycle</functionname>
<description>Activate a single cycle on the specified application</description>
<param name="pApp" type="IN">Pointer to the specified application description</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION *pApp, unsigned long ulState)">AppSetState</functionname>
<description>Set the state of an application</description>
<param name="pApp" type="IN">Pointer to the specified application description</param>
<param name="ulState" type="IN">State to set. See above for state specifications (prefix: AS_)</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="unsigned long" parameters="(APPLICATION *pApp, RTS_RESULT *pResult)">AppGetState</functionname>
<description>Returns the state of an application</description>
<param name="pApp" type="IN" range="[NULL,VALID_PAPP]">Pointer to the specified application description</param>
<parampseudo name="pApp.ulState" type="IN" range="[AS_NONE,AS_RUN]">Pointer to the specified application description</parampseudo>
<param name="pResult" type="OUT">Pointer to error code</param>
<errorcode name="RTS_RESULT Result" type="ERR_OK">State of application successfully retrieved</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_PARAMETER">Parameter pApp may not be null</errorcode>
<result>State of the application. There could be several active states at the same time!
See above for state specifications (prefix: AS_)</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION *pApp, unsigned long ulOpState)">AppSetOperatingState</functionname>
<description>Set the operating state of an application</description>
<param name="pApp" type="IN">Pointer to the specified application description</param>
<param name="ulOpState" type="IN">Operating state of an application. This is an information, which job or
operating possibilities of the application are set actually. There could be several active opertating states
at the same time!</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION *pApp, unsigned long ulOpState)">AppResetOperatingState</functionname>
<description>Reset a single operating state of an application</description>
<param name="pApp" type="IN">Pointer to the specified application description</param>
<param name="ulOpState" type="IN">Operating state to reset</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="unsigned long" parameters="(APPLICATION *pApp, RTS_RESULT *pResult)">AppGetOperatingState</functionname>
<description>Get the operating state of an application</description>
<param name="pApp" type="IN" range="[VALID_PAPP,NULL]">Pointer to the specified application description</param>
<parampseudo name="pApp->ulOpState" type="IN" range="[OS_NONE,OS_PROGRAM_LOADED]">Application operating state</parampseudo>
<param name="pResult" type="OUT">Pointer to error code</param>
<errorcode name="RTS_RESULT Result" type="ERR_OK">Status retrieved successfully</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_PARAMETER">pApp may not be null</errorcode>
<result>Operating state of an application</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION *pApp, RTS_GUID *pCodeGuid)">AppSetCodeGuid</functionname>
<description>Sets the code id of the application. The code id is a unique number that
specifies the code content of an application.</description>
<param name="pApp" type="IN" range="[NULL,VALID_PAPP]">Pointer to the specified application description</param>
<param name="pCodeGuid" type="IN" range="[NULL,VALID_PCODEGUID]">Pointer to code guid</param>
<errorcode name="RTS_RESULT Result" type="ERR_OK">Code Guid was set successful</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_PARAMETER">Parameter may not be null</errorcode>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION *pApp, RTS_GUID *pCodeGuid)">AppGetCodeGuid</functionname>
<description>Retrieves the code id of the application. The code id is a unique number that
specifies the code content of an application.</description>
<param name="pApp" type="IN">Pointer to the specified application description</param>
<param name="pCodeGuid" type="OUT">Pointer to code guid</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION *pApp, RTS_GUID *pDataGuid)">AppSetDataGuid</functionname>
<description>Sets the data id of the application. The data id is a unique number that
specifies the data configuration of an application.</description>
<param name="pApp" type="IN" range="[NULL,VALID_PAPP]">Pointer to the specified application description</param>
<param name="pDataGuid" type="IN" range="[NULL,VALID_PDATAGUID]">Pointer to data guid</param>
<errorcode name="RTS_RESULT Result" type="ERR_OK">Code Guid was set successful</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_PARAMETER">Parameter may not be null</errorcode>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION *pApp, RTS_GUID *pDataGuid)">AppGetDataGuid</functionname>
<description>Retrieves the data id of the application. The data id is a unique number that
specifies the data configuration of an application.</description>
<param name="pApp" type="IN">Pointer to the specified application description</param>
<param name="pDataGuid" type="OUT">Pointer to data guid</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION *pApp, RTS_GUID *pCodeGuid, RTS_GUID *pDataGuid)">AppGetBootprojectGuids</functionname>
<description>Retrieves the code and data guid of the bootproject of the given application.
This function can be used to compare the guids of the loaded application with the bootproject.</description>
<param name="pApp" type="IN">Pointer to the specified application description</param>
<param name="pCodeGuid" type="OUT">Pointer to code guid</param>
<param name="pDataGuid" type="OUT">Pointer to data guid</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION *pApp, RTS_UI32 ulException, RegContext Context)">AppExceptionHandler</functionname>
<description>Exception handling of an application task. Must be called from another component, if an exception
occurred in an IEC task. This routine is called typically by the CmpIecTask.</description>
<param name="pApp" type="IN">Pointer to the specified application description, in which the exception
was generated.</param>
<param name="ulException" type="IN">Exception number to see, which exception was generated</param>
<param name="Context" type="IN">Context of the task. With this context it is possible to investigate
the complete callstack to the code position, where the exception occurred</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION* pApp, RTS_UI16 usResetOption, RTS_UI32 ulSessionId)">AppReset</functionname>
<description>Executes a reset on the specified application</description>
<param name="pApp" type="IN">Pointer to the specified application description</param>
<param name="usResetOption" type="IN">Reset option. See the category reset options for detailed information</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_UI16 usResetOption)">AppResetAllApplications</functionname>
<description>Resets all applications</description>
<param name="usResetOption" type="IN">Reset option. See the category reset options for detailed information</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(void)">AppLoadBootprojects</functionname>
<description>Load all registered bootprojects</description>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(void)">AppStartBootprojects</functionname>
<description>Start all registered bootprojects</description>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char *pszAppName, char *pszFilePath)">AppLoadBootproject</functionname>
<description>Load a bootproject with the specified application name</description>
<param name="pszAppName" type="IN">Pointer to the NUL terminated application name</param>
<param name="pszFilePath" type="IN">File path for the bootproject</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(void)">AppStartApplications</functionname>
<description>Start all applications</description>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION *pApp)">AppStartApplication</functionname>
<description>Start an application</description>
<param name="pApp" type="IN">Pointer to the application</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_UI32 ulTimeoutMs, RTS_UI32 ulStopReason)">AppStopApplications</functionname>
<description>Stop all applications</description>
<param name="ulTimeoutMs" type="IN">Timeout in milliseconds to wait for stop. RTS_TIMEOUT_DEFAULT can be used as the default value</param>
<param name="ulStopReason" type="IN">Stop reason, See corresponding category</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION *pApp, RTS_UI32 ulTimeoutMs, RTS_UI32 ulStopReason)">AppStopApplication</functionname>
<description>Stop an application</description>
<param name="pApp" type="IN">Pointer to the application</param>
<param name="ulTimeoutMs" type="IN">Timeout in milliseconds to wait for stop. RTS_TIMEOUT_DEFAULT can be used as the default value</param>
<param name="ulStopReason" type="IN">Stop reason, See corresponding category</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION *pApp, int bShutdown)">AppExitApplication</functionname>
<description>Exit an application (release all tasks, etc.). The application is not deleted!</description>
<param name="pApp" type="IN">Pointer to the application</param>
<param name="bShutdown" type="IN">1=Function called at shutdown of the runtime, 0=else</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION *pApp, int bShutdown, RTS_UI32 ulTimeoutMs)">AppExitApplication2</functionname>
<description>Exit an application (release all tasks, etc.). The application is not deleted!</description>
<param name="pApp" type="IN">Pointer to the application</param>
<param name="bShutdown" type="IN">1=Function called at shutdown of the runtime, 0=else</param>
<param name="ulTimeoutMs" type="IN">Timeout in milliseconds to to stop the application during exit. RTS_TIMEOUT_DEFAULT can be used as the default value</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(int bShutdown, RTS_UI32 ulTimeoutMs)">AppExitApplications</functionname>
<description>Exit all applications (release all tasks, etc.). The applications are not deleted!</description>
<param name="bShutdown" type="IN">1=Function called at shutdown of the runtime, 0=else</param>
<param name="ulTimeoutMs" type="IN">Timeout in milliseconds to stop the application during exit. RTS_TIMEOUT_DEFAULT can be used as the default value</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION *pApp, int bShutdown)">AppDeleteApplication</functionname>
<description>Delete an application. Bootproject will not deleted!</description>
<param name="pApp" type="IN">Pointer to the application</param>
<param name="bShutdown" type="IN">1=Function called at shutdown of the runtime, 0=else</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(int bShutdown)">AppDeleteApplications</functionname>
<description>Delete all applications. Bootprojects will not be deleted!</description>
<param name="bShutdown" type="IN">1=Function called at shutdown of the runtime, 0=else</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION *pApp)">AppDeleteBootproject</functionname>
<description>Delete a bootproject (corresponding loaded application will not be affected or deleted!)</description>
<param name="pApp" type="IN">Pointer to the application</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_UI32 ulSessionId, PEERADDRESS *pPeerAddr)">AppAddAddrDataSrv</functionname>
<description>Add the peer address of an existing data server. This can be used from clients, that wants to
get symbolic access to IEC variables. If the symbolic infromation is not available here on the controller,
the registered data server can be used for that.</description>
<param name="ulSessionId" type="IN">SessionId of the communication channel</param>
<param name="pPeerAddr" type="IN">Pointer to the peer address of the data server</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_UI32 ulSessionId)">AppRemoveAddrDataSrv</functionname>
<description>Remove a peer address of an existing data server that will be shutdown</description>
<param name="ulSessionId" type="IN">SessionId of the communication channel</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(PEERADDRESS **ppPeerAddr, RTS_RESULT *pResult)">AppGetFirstAddrDataSrv</functionname>
<description>Retrieves the peer address of the first registered data server</description>
<param name="ppPeerAddr" type="OUT">Pointer pointer to the peer address</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Handle to get the next peer addresse of a registered data server, RTS_INVALID_HANDLE if not available</result>
</element>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(RTS_HANDLE hAddr, PEERADDRESS **ppPeerAddr, RTS_RESULT *pResult)">AppGetNextAddrDataSrv</functionname>
<description>Retrieves the peer address of the first registered data server</description>
<param name="hAddr" type="IN">Handle, that was retrieved by the AppGetFirstAddrDataSrv() function</param>
<param name="ppPeerAddr" type="OUT">Pointer pointer to the peer address</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Handle to get the next peer addresse of a registered data server, RTS_INVALID_HANDLE if not available</result>
</element>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(APPLICATION *pApp, RTS_RESULT *pResult)">AppConsistencyCheckBegin</functionname>
<description>Begin a consistency sequence. This can be used to check, if any task of an IEC application
(or its father application) was active during this sequence. A typical usage is the task consistent
data monitoring during this sequence.
</description>
<param name="pApp" type="IN">Pointer to the application</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Return a handle to the consistency object</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hConsistency)">AppConsistencyCheckEnd</functionname>
<description>End a consistency sequence. This can be used to check, if any task of an IEC application
(or its father application) was active during this consistency sequence.
A typical usage is the task consistent data monitoring.
</description>
<param name="hConsistency" type="IN">Handle to the consistency object that is returned by AppConsistencyBegin()</param>
<result>ERR_OK: No task active during this consistency sequence,
ERR_FAILED: Any task of this application was active during this sequence</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(void)">AppConsistencyCheckAll</functionname>
<description>Check all applications for consistency, that are called with AppConsistencyCheckBegin()</description>
<result>ERR_OK: No task active during this consistency sequence,
ERR_FAILED: Any task of an application was active during this sequence</result>
</element>
<element function="1">
<functionname returntype="APPLICATION*" parameters="(RTS_RESULT *pResult)">AppGetFirstApp</functionname>
<description>Retrieves the application info of the first application</description>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Pointer to the first application</result>
</element>
<element function="1">
<functionname returntype="APPLICATION*" parameters="(APPLICATION *pAppPrev, RTS_RESULT *pResult)">AppGetNextApp</functionname>
<description>Retrieves the application info of the next application</description>
<param name="pAppPrev" type="IN">Pointer to the first application retrieved by the AppGetFirstApp()</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Pointer to the next application</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION *pApp, RTS_IEC_STRING* pszFileName)">AppStoreRetainsInFile</functionname>
<description>Stores the retains of an application in a file</description>
<param name="pApp" type="IN">Pointer to application</param>
<param name="pszFilename" type="OUT">Name of retain file</param>
<result>Error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION *pApp, RTS_IEC_STRING* pszFileName)">AppRestoreRetainsFromFile</functionname>
<description>Restores the retains of an application from a file</description>
<param name="pApp" type="IN">Pointer to application</param>
<param name="pszFilename" type="IN">Name of retain file</param>
<result>Error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION *pApp, RTS_IEC_STRING* pszFileName, int bGenerateException)">AppRestoreRetainsFromFile2</functionname>
<description>Restores the retains of an application from a file</description>
<param name="pApp" type="IN">Pointer to application</param>
<param name="pszFilename" type="IN">Name of retain file</param>
<param name="bGenerateException" type="IN">Select behaviour on retain mismatch: 1=Generate exception, 0=Only return error code</param>
<result>Error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION *pApp)">AppSaveRetainAreas</functionname>
<description>Store retain areas the standard way for the next reboot or reload</description>
<param name="pApp" type="IN">Pointer to application</param>
<result>Error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(void)">AppSaveAllRetainAreas</functionname>
<description>Store retain areas the standard way for the next reboot or reload of all applications</description>
<result>Error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION *pApp)">AppRestoreRetainAreas</functionname>
<description>Restore retain areas the standard way</description>
<param name="pApp" type="IN">Pointer to application</param>
<result>Error code</result>
</element>
<element function="1">
<functionname returntype="RTS_SIZE" parameters="(APPLICATION* pApp, RTS_UI16 usType, RTS_RESULT* pResult)">AppGetAreaSize</functionname>
<description>This function retuns the size of an application area</description>
<param name="pApp" type="IN">Pointer to Application</param>
<param name="usType" type="IN">Area type. See category "Area Types" in SysMemItf.h.</param>
<param name="pResult" type="OUT">Pointer to Result</param>
<result>Area size</result>
</element>
<element function="1">
<functionname returntype="RTS_UI8*" parameters="(APPLICATION* pApp, RTS_UI16 usType, RTS_RESULT* pResult)">AppGetAreaAddress</functionname>
<description>This function retuns the start address of an application area</description>
<param name="pApp" type="IN" range="[NULL,VALID_PAPP]">Pointer to the specified application description</param>
<param name="usType" type="IN" range="[DA_NONE,VALID_DA,INVALID_DA]">Area type. See category "Area Types" in SysMemItf.h.</param>
<param name="pResult" type="OUT">Pointer to Result</param>
<errorcode name="RTS_RESULT pResult" type="ERR_OK">Areapointer successfully retrieved</errorcode>
<errorcode name="RTS_RESULT pResult" type="ERR_PARAMETER">Parameter pApp may not be null</errorcode>
<errorcode name="RTS_RESULT pResult" type="ERR_FAILED">No Area for given type found</errorcode>
<result>Area start address</result>
</element>
<element function="1">
<functionname returntype="APP_MEMORY_SEGMENT *" parameters="(APPLICATION* pApp, RTS_UI16 usType, RTS_RESULT *pResult)">AppGetSegment</functionname>
<description>This function retuns the segment info specified by type</description>
<param name="pApp" type="IN">Pointer to Application</param>
<param name="usType" type="IN">Area type. See category "Area Types" in SysMemItf.h.</param>
<param name="pResult" type="OUT">Pointer to Result</param>
<result>Pointer to segment info</result>
</element>
<element function="1">
<functionname returntype="APP_MEMORY_SEGMENT *" parameters="(APPLICATION* pApp, void *pAddress, RTS_RESULT *pResult)">AppGetSegmentByAddress</functionname>
<description>This function retuns the segment info specified by address</description>
<param name="pApp" type="IN">Pointer to Application</param>
<param name="pAddress" type="IN">Pointer to segment data</param>
<param name="pResult" type="OUT">Pointer to Result</param>
<result>Pointer to segment info</result>
</element>
<element function="1">
<functionname returntype="RTS_SIZE" parameters="(APPLICATION* pApp, RTS_UI16 usType, RTS_RESULT* pResult)">AppGetSegmentSize</functionname>
<description>
This function retuns the start size of an IEC segment. All segments resides within an area.
This is used to get access for example to the size of the output processimage segment (%Q).
</description>
<param name="pApp" type="IN">Pointer to Application</param>
<param name="usType" type="IN">Area type. See category "Area Types" in SysMemItf.h.</param>
<param name="pResult" type="OUT">Pointer to Result</param>
<result>Segment size</result>
</element>
<element function="1">
<functionname returntype="RTS_UI8 HUGEPTR *" parameters="(APPLICATION* pApp, RTS_UI16 usType, RTS_RESULT* pResult)">AppGetSegmentAddress</functionname>
<description>
This function retuns the start address of an IEC segment. All segments resides within an area.
This is used to get access for example to the beginning of the output processimage segment (%Q).
</description>
<param name="pApp" type="IN">Pointer to Application</param>
<param name="usType" type="IN">Area type. See category "Area Types" in SysMemItf.h.</param>
<param name="pResult" type="OUT">Pointer to Result</param>
<result>Segment start address</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION* pApp, RTS_VOID_FCTPTR *ppfGetBooleanProperty, RTS_VOID_FCTPTR *ppfGetTextProperty, RTS_VOID_FCTPTR *ppfGetNumberProperty, RTS_VOID_FCTPTR *ppfGetVersionProperty)">AppRegisterPropAccessFunctions</functionname>
<description>This function registers the properties access functions</description>
<param name="pApp" type="IN" range="[NULL,VALID_PAPP]">Pointer to Application</param>
<param name="ppfGetBooleanProperty" type="IN" range="[NULL,VALID_PPFBPROP]">Pointer to Pointer to Boolean Function</param>
<param name="ppfGetTextProperty" type="IN" range="[NULL,VALID_PPFTPROP]">Pointer to Pointer to Text Function</param>
<param name="ppfGetNumberProperty" type="IN" range="[NULL,VALID_PPFNPROP]">Pointer to Pointer to Number Function</param>
<param name="ppfGetVersionProperty" type="IN" range="[NULL,VALID_PPFNPROP]">Pointer to Pointer to Version Function</param>
<errorcode name="RTS_RESULT pResult" type="ERR_OK">Functions successfully registered</errorcode>
<errorcode name="RTS_RESULT pResult" type="ERR_PARAMETER">Parameter pApp may not be null</errorcode>
<result>Error Code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION* pApp, PROJECT_INFO* pInfo)">AppGetProjectInformation</functionname>
<description>This function returns the project information</description>
<param name="pApp" type="IN">Pointer to Application</param>
<param name="pfGetBooleanProperty" type="IN">Pointer to PROJECT_INFORMATION</param>
<result>Error Code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION *pApp, BOOLEANPROPERTY *pBooleanProperty)">AppGetBooleanProperty</functionname>
<description>With this function you get access to the optional IEC function in the project, which contains boolean project infomration</description>
<param name="pApp" type="IN">Pointer to Application</param>
<param name="pBooleanProperty" type="INOUT">wszKey must be set with the key (RTS_IEC_WSTRING!), as defined in the project information dialog in CoDeSys.
See category "Property keys" for predefined property keys.
bBooleanProperty contains the bool property value.</param>
<result>Error Code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION *pApp, TEXTPROPERTY *pTextProperty)">AppGetTextProperty</functionname>
<description>With this function you get access to the optional IEC function in the project, which contains text project infomration</description>
<param name="pApp" type="IN">Pointer to Application</param>
<param name="pTextProperty" type="INOUT">wszKey must be set with the key (RTS_IEC_WSTRING!), as defined in the project information dialog in CoDeSys.
See category "Property keys" for predefined property keys.
wszTextProperty contains the string property value.</param>
<result>Error Code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION *pApp, NUMBERPROPERTY *pNumberProperty)">AppGetNumberProperty</functionname>
<description>With this function you get access to the optional IEC function in the project, which contains text project infomration</description>
<param name="pApp" type="IN">Pointer to Application</param>
<param name="pNumberProperty" type="INOUT">wszKey must be set with the key (RTS_IEC_WSTRING!), as defined in the project information dialog in CoDeSys.
See category "Property keys" for predefined property keys.
udiNumberProperty contains the number property value.</param>
<result>Error Code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION *pApp, VERSIONPROPERTY *pVersionProperty)">AppGetVersionProperty</functionname>
<description>With this function you get access to the optional IEC function in the project, which contains text project infomration</description>
<param name="pApp" type="IN">Pointer to Application</param>
<param name="pVersionProperty" type="INOUT">wszKey must be set with the key (RTS_IEC_WSTRING!), as defined in the project information dialog in CoDeSys.
See category "Property keys" for predefined property keys.
uiMajor, uiMinor, uiServicePack, uiPatch contains the version property values.</param>
<result>Error Code</result>
</element>
<element function="1">
<functionname returntype="APPLICATION*" parameters="(RTS_RESULT *pResult)">AppGetCurrent</functionname>
<description>Get the current application, in which task context the caller is located</description>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Pointer to application description</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION *pApp, RTS_RESULT *pBootprojectConsistency, RTS_RESULT *pArchiveConsistency)">AppCheckFileConsistency</functionname>
<description>Check the consistency of the specified application to the files of bootproject and project archive</description>
<param name="pApp" type="IN">Pointer to Application</param>
<param name="pBootprojectConsistency" type="OUT">Pointer to result of the bootproject consistency.
ERR_OK: Bootproject matches the specified application</param>
<param name="pArchiveConsistency" type="OUT">Pointer to result of the archive consistency.
ERR_OK: Archive matches the specified application</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION *pApp, RTS_UI32 ulException)">AppGenerateException</functionname>
<description>Generate an exception on the specified application.
NOTE: pApp can be NULL, so the current applicaiton in program download sequence is used!</description>
<param name="pApp" type="IN">Pointer to Application. Can be NULL!</param>
<param name="ulException" type="IN">Exception code. See SysExceptItf.h for details.</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char *pszBootproject)">AppRegisterBootproject</functionname>
<description>Function to register a bootproject to reload at the next startup</description>
<param name="pszAppName" type="IN">Name of the bootproject without ending or application name</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char *pszBootproject)">AppUnregisterBootproject</functionname>
<description>Function to unregister a bootproject to avoid reload at the next startup</description>
<param name="pszAppName" type="IN">Name of the bootproject without ending or application name</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(void *pInstance, RTS_VOID_FCTPTR *ppGetMethod, RTS_UI8 *pbyValue, RTS_SIZE ulSize)">AppCallGetProperty</functionname>
<description>Function call a property of a function block to get the value</description>
<param name="pInstance" type="IN">Pointer to the FB instance</param>
<param name="ppGetMethod" type="IN">Pointer to the get method of the property (ADR(__get[PropertyName])</param>
<param name="pbyValue" type="IN">Pointer to a value buffer to return the value of the property</param>
<param name="ulSize" type="IN">Size in bytes of the property type</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(void *pInstance, RTS_VOID_FCTPTR *ppSetMethod, RTS_UI8 *pbyValue, RTS_SIZE ulSize)">AppCallSetProperty</functionname>
<description>Function call a property of a function block to set the value</description>
<param name="pInstance" type="IN">Pointer to the FB instance</param>
<param name="ppSetMethod" type="IN">Pointer to the set method of the property (ADR(__get[PropertyName])</param>
<param name="pbyValue" type="IN">Pointer to a value buffer to set the value of the property</param>
<param name="ulSize" type="IN">Size in bytes of the property type</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION *pApp, RTS_UINTPTR ulAddress, RTS_UI16 *pusArea, RTS_SIZE *pulOffset)">AppGetAreaOffsetByAddress</functionname>
<description>Get area number and offset of an application specified by a memory address</description>
<param name="pApp" type="IN">Pointer to Application</param>
<param name="ulAddress" type="IN">Memory address</param>
<param name="pusArea" type="OUT">Pointer to return area number</param>
<param name="pulOffset" type="IN">Pointer to return area offset</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="APPLICATION*" parameters="(PROTOCOL_DATA_UNIT *pduSendBuffer, BINTAGREADER *preader, BINTAGWRITER *pwriter, RTS_UI32 ulSessionId)">AppSrvGetApplication</functionname>
<description>Returns the application specified in an online service</description>
<param name="pduSendBuffer" type="IN">Pointer to the sent data unit</param>
<param name="preader" type="IN">Pointer to the reader</param>
<param name="pwriter" type="IN">Pointer to the writer</param>
<param name="ulSessionId" type="IN">Session id of the given service</param>
<result>Pointer to the application description</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char *pszApplication, char *pszObject, RTS_UI32 ulRequestedRights, RTS_UI32 ulSessionId, BINTAGWRITER *pWriter)">AppHasAccessRights</functionname>
<description>Check the access rights to the specified object of the application</description>
<param name="pszApplication" type="IN">Name of the application</param>
<param name="pszObject" type="IN">Name of the object</param>
<param name="ulRequestedRights" type="IN">Requested rights on the object</param>
<param name="ulSessionId" type="IN">SessionID of the online service</param>
<param name="pWriter" type="IN">Pointer to the tag writer</param>
<result>Error code:
ERR_OK: Has access rights
ERR_FAILED: Operation failed
ERR_NO_ACCESS_RIGHTS: No access rights to the object
</result>
</element>
<element function="1">
<functionname returntype="APPLICATION_INFO *" parameters="(APPLICATION *pApp, RTS_RESULT *pResult)">AppGetApplicationInfo</functionname>
<description>Get the detail information of the specified application</description>
<param name="pApp" type="IN">Pointer to Application</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Pointer to application info structure</result>
</element>
</element>
</component>
<component>
<name>CmpBinTagUtil</name>
<description>
Provides a reader and a writer for the BinTag structured data format.
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element interface="1" name="CmpBinTagUtilItf">
<interfacename>CmpBinTagUtil</interfacename>
<description>
<p>Interface for the binary tag utility.</p>
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element typedefinition="1">
<name>BTAG_ALIGNMENT</name>
<structname>BTAG_ALIGNMENT</structname>
<description>
This struct defines an alignment property.
The meaning of the members is
"Align to an address for which the following equation holds:
address % sModulus = sRemainder"
Eg.:
(4,0) aligns to a 4 byte boundary
(4,1) aligns to a 4 byte boundary + 1 (1,5,9,13,...)
(2,0) aligns to an equal address
(2,1) aligns to an odd address
(1,0) aligns to any address
</description>
<rawdata>
typedef struct
{
	unsigned short usModulus;
	unsigned short usRemainder;
} BTAG_ALIGNMENT;
</rawdata>
</element>
<element typedefinition="1">
<name>BINTAGWRITER</name>
<structname>BINTAGWRITER</structname>
<description>
This struct holds the internal state of a writer and should be
treated as opaque by an application.
Do not alter!
</description>
<rawdata>
typedef struct
{
	RTS_UI8 *pBuffer;
	RTS_HANDLE hFile;
	RTS_UI32 ulBufferSize;
	RTS_UI32 ulPos;

	BTAG_WRITERTAGINFO tagStack[BTAG_MAX_NESTED_TAGS];

	int nStackPos; Points to the index of the current tag. Initially set to -1 (toplevel, no current tag).
	                   Must not exceed BTAG_MAX_NESTED_TAGS-1
	
	int iType;
	RTS_UI32 ulEndServicePos;
	int bSwapHeader;
	int	bBufferOverflow;
	PFUPDATECRC pfUpdateCRC;
	void *pParameterUpdateCRC;
}BINTAGWRITER;
</rawdata>
</element>
<element typedefinition="1">
<name>BINTAGREADER</name>
<structname>BINTAGREADER</structname>
<description>
This struct holds the internal state of a reader and should be
treated as opaque by an application.
Do not alter!
</description>
<rawdata>
typedef struct
{
	RTS_UI8 *pBuffer;
	RTS_UI32 ulBufferSize;
	RTS_HANDLE hFile;

	RTS_UI32 ulPos;

	BTAG_READERTAGINFO tagStack[BTAG_MAX_NESTED_TAGS];
	int nStackPos; Points to the index of the current tag. Initially set to -1 (toplevel, no current tag).
	                   Must not exceed BTAG_MAX_NESTED_TAGS-1
	int iType;
	RTS_UI32 ulStartServicePos;
}BINTAGREADER;
</rawdata>
</element>
<element function="1">
<functionname returntype="int" parameters="(HEADER_TAG_EXT* pHeader, int bSwap)">BTagSwapHeader</functionname>
<description>
Swap the header of a service.
</description>
<param name="pHeader" type="INOUT">
Pass in a HEADER_TAG_EXT struct that should be swapped.
</param>
<param name="bSwap" type="IN">
Determines, if the header should be swapped (1) or not (0).
</param>
</element>
<element function="1">
<functionname returntype="int" parameters="(BINTAGWRITER *pWriter, RTS_UI8 *pBuffer, RTS_UI32 ulBufferSize, int bSwapHeader)">BTagWriterInit2</functionname>
<description>
Initialize a writer.
</description>
<param name="pWriter" type="INOUT">
Pass in a BINTAGWRITER struct that will be initialized to a empty writer.
</param>
<param name="pBuffer" type="IN">
The buffer that the writer will write to.
The buffer should not be altered until the writer has finished.
</param>
<param name="ulBufferSize" type="IN">
The size of the buffer. The writer will fail if a write operation would exceed the buffer.
</param>
<param name="bSwapHeader" type="IN">
Clients have to set this flag, if the addressed server has a different byte order.
Must be always FALSE for server implementations or if the client has the same byte order as the server.
</param>
</element>
<element function="1">
<functionname returntype="int" parameters="(BINTAGWRITER *pWriter, RTS_UI8 *pBuffer, RTS_UI32 ulBufferSize)">BTagWriterInit</functionname>
<description>
Initialize a writer. Can be used by servers or if the client and the server have the same byte order.
</description>
<param name="pWriter" type="INOUT">
Pass in a BINTAGWRITER struct that will be initialized to a empty writer.
</param>
<param name="pBuffer" type="IN">
The buffer that the writer will write to.
The buffer should not be altered until the writer has finished.
</param>
<param name="ulBufferSize" type="IN">
The size of the buffer. The writer will fail if a write operation would exceed the buffer.
</param>
</element>
<element function="1">
<functionname returntype="int" parameters="(BINTAGWRITER *pWriter, RTS_UI32 ulSessionID, RTS_UI16 usHeaderTag, RTS_UI32 ulServiceGroup, RTS_UI16 usService)">BTagWriterStartService</functionname>
<description>
Start a new service. Must be called after BTagWriterInit.
</description>
<param name="pWriter" type="INOUT">
The writer.
</param>
<param name="ulSessionID" type="IN">
SessionID of the current session
</param>
<param name="usHeaderTag" type="IN">
HeaderTag to identify the protocol handler.
</param>
<param name="ulServiceGroup" type="IN">
ulServiceGroup = HIGHWORD: usCustomerId, LOWWORD: usServiceGroup;
</param>
<param name="usService" type="IN">
Service
</param>
</element>
<element function="1">
<functionname returntype="int" parameters="(BINTAGWRITER *pWriter, RTS_UI8 **ppBuffer, RTS_UI32 *pulSize)">BTagWriterFinishService</functionname>
<description>
Finishes the service.
It returns the buffer passed in to BTagWriterInit in ppBuffer and the number
of bytes written to the buffer in pulSize;
</description>
</element>
<element function="1">
<functionname returntype="int" parameters="(BINTAGWRITER *pWriter, RTS_UI32 ulTagId, BTAG_ALIGNMENT contentAlignment, RTS_UI32 ulMinLengthSize)">BTagWriterStartTag</functionname>
<description>
Start a new tag. A tag cannot be started within a data tag. Data tags are determined
by the id of the tag: If bit 7 (that is the highest bit of the least significant byte of the tagid)
is set then the tag contains only subtags, otherwise it contains no subtags but only content.
Every call to BTagWriterStartTag must be matched with a call to BTagWriterEndTag.
All subtags of a tag must be closed before the tag itself may be closed.
</description>
<param name="pWriter" type="INOUT">
The writer must have been initialized with a call to BTagWriterInit.
</param>
<param name="ulTagId" type="IN">
The id of the tag.
</param>
<param name="contentAlignment" type="IN">
How the content should be aligned within this tag. If the tag is not a data tag
then contentAlignment must always be (4,0).
In any case in this version of the data format the nModulus member must always be 4
since all alignment is done in respect to 4 byte boundaries.
</param>
<param name="ulMinLengthSize" type="IN">

</param>
</element>
<element function="1">
<functionname returntype="int" parameters="(BINTAGWRITER *pWriter, const char *pszString)">BTagWriterAppendString</functionname>
<description>
Append a C-string to the current tag. The string is written including
the trailing end of string char (NUL). The current tag must be a data tag.
</description>
<param name="pWriter" type="IN">Pointer to bintag writer</param>
<param name="pszString" type="IN">Pointer to NUL terminated string to append</param>
<result>TRUE=succeeded, FALSE=failed</result>
</element>
<element function="1">
<functionname returntype="int" parameters="(BINTAGWRITER *pWriter, const RTS_WCHAR *wszString)">BTagWriterAppendWString</functionname>
<description>
Append a UTF-16 (widechar) string to the current tag. The string is written including
the trailing end of string char (0x0000). The current tag must be a data tag.
</description>
</element>
<element function="1">
<functionname returntype="int" parameters="(BINTAGWRITER *pWriter, const RTS_UI8 *pBlob, RTS_UI32 ulSize)">BTagWriterAppendBlob</functionname>
<description>
Append ulSize bytes from the buffer pBlob to the current tag.
The current tag must be a data tag.
</description>
</element>
<element function="1">
<functionname returntype="int" parameters="(BINTAGWRITER *pWriter, RTS_UI8 **ppBuffer, RTS_UI32 ulSize)">BTagWriterAppendRaw</functionname>
<description>
Returns a pointer to the current content position and forwards the write position for ulSize bytes.
This function provides a buffer of length ulSize within the content of the current tag, in effect giving
the caller random access to this buffer.
This function is especially usefull, if that buffer has to be passed to another function, that fills it.
(see example).
ATTENTION: The returned pointer is valid only until the next operation on the bintagwriter is executed.
After that the pointer must not be used any more! Do not store that pointer permanently.
The current tag must be a data tag.
</description>
<param name="ppBuffer" type="OUT">Is set to point to the buffer, if the function succeeds</param>
<pre>
// Store a number as hexadecimal string in a bintag writer
unsigned char *pBuffer;
unsigned char **ppBuffer;
int nNumber = 1234;
*ppBuffer = pBuffer;
if (ERR_OK == CAL_BTagWriterAppendRaw(pWriter, ppBuffer, 5)) // 4 digits + an additional byte for a trailing zero
sprintf(pBuffer, "%04x", nNumber);
pBuffer = NULL; // Avoid accidentally writing on that buffer again
</pre>
</element>
<element function="1">
<functionname returntype="int" parameters="(BINTAGWRITER *pWriter, RTS_UI8 byFillByte, BTAG_ALIGNMENT alignment)">BTagWriterAppendFillBytes</functionname>
<description>
Add byFillByte to the content until the current content ends
on a position that satifies the desired alignment.
Eg. a tag must always be closed on a (4,0)-alignment, so after adding a variable length
string one should call:
<pre>
BTAG_ALIGNMENT align = {4,0};
...
BTagWriterAppendFillBytes(pWriter, 0, align);
BTagWriterEndTag(pWriter, TAG_ID);
</pre>
If the alignment property is already fullfilled nothing will be appended.
</description>
<param name="pWriter" type="IN"></param>
<param name="byFillByte" type="IN">
The byte to be appended until alignment is achieved.
</param>
<param name="alignment" type="IN">
The desired alignment of the next writer position.
</param>
</element>
<element function="1">
<functionname returntype="int" parameters="(BINTAGWRITER *pWriter, RTS_UI8 byFillByte, RTS_UI32 ulSize)">BTagWriterAppendDummyBytes</functionname>
<description>
Append byFillByte ulSize times.
</description>
</element>
<element function="1">
<functionname returntype="int" parameters="(BINTAGWRITER *pWriter, RTS_UI32 ulTagId)">BTagWriterEndTag</functionname>
<description>
Close the current tag. The current tag must have been started with the given tag id.
ulTagId is used only as an additional check that all tags are closed in the right order.
Since the only element that follows a tag must be a tag again and a tag must always start
on a 4 byte boundary the complete size of a tag (header + content) must be dividable by 4.
Taking a contentalignment of (4,x) then "contentsize == 4 - x (MOD 4) " must hold.
(eg. for (4,1): contentsize % 4 == 3)
If this condition does not hold, the function will fail.
</description>
</element>
<element function="1">
<functionname returntype="int" parameters="(BINTAGWRITER *pWriter, RTS_UI8 *pNewBuffer, RTS_UI32 ulNewSize, RTS_UI8 **ppOldBuffer)">BTagWriterSwitchBuffer</functionname>
<description>
Replaces the current writer buffer with a new one. All content in the current buffer
is copied to the new buffer. This also means that the size of the new buffer has to be
at least the current position of the writer.
The purpose of this function is to allow for extension of the buffer if an operation
returned a buffer overflow. Then the caller may allocate a new buffer, call
BTagWriterSwitchBuffer and retry the failed operation.
</description>
<param name="pWriter" type="IN"></param>
<param name="pNewBuffer" type="IN">
The buffer that is to replace the original buffer.
</param>
<param name="ulNewSize" type="IN">
Size of the new buffer. Must be greater or at least equal to the current postion
of the writer.
</param>
<param name="ppOldBuffer" type="OUT">
Is set to the previous buffer.
</param>
</element>
<element function="1">
<functionname returntype="int" parameters="(BINTAGWRITER *pWriter, BINTAGSAVEPOINT *pSavepoint)">BTagWriterCreateSavepoint</functionname>
<description>
Save the current state of the writer. A later call to BTagWriterRestoreSavepoint will
reset the writer and its buffer to that state. Any number of savepoints may be created.
The caller must use multiple savepoints in a stack-like fashion: If savepoints are
created in the order 1,2,3,4 then they must be restored in opposite order only. Not
every savepoint must be restored - but if one is restored all savepoints created after
that one MUST NOT BE USED any more.
Examples: ("sX"="create savepoint X", "rX"="Restore savepoint X",
"(x,y,z)"="stack of valid savepoints")
The following sequences are valid:
() s1 (1) s2 (1,2) s3 (1,2,3) r2 (1) r1 ()
() s1 (1) s2 (1,2) s3 (1,2,3) r2 (1) s4 (1,4) r4 (1)
whereas this one is invalid:
() s1 (1) s2 (1,2) s3 (1,2,3) r2 (1) r3 [3 is not valid at this point]

The writer does not track the stack of savepoints, therefore it cannot
detect errors in the restore order. It's the responsibility of the application
to ensure the correct restore order. Failure in doing so will lead to an
inconsistent state and may well corrupt the whole document.
Besides the restore order savepoints are independent of each other. The application
may delete/reuse a savepoint anytime it doesn't need it anymore.

Savepoints cannot be used to transfer the state of a writer to a second writer.
Any attempt in doing so will lead to undefined behaviour.
</description>
<param name="pWriter" type="IN"></param>
<param name="pSavePoint" type="OUT">
Will receive all information needed to restore the current state of the writer.
</param>
</element>
<element function="1">
<functionname returntype="int" parameters="(BINTAGWRITER *pWriter, BINTAGSAVEPOINT *pSavepoint)">BTagWriterRestoreSavepoint</functionname>
<description>
Restore the state of the writer to one previously saved using
BTagWriterCreateSavepoint. See there for a detailed description on how to use
these functions.
</description>
<param name="pWriter" type="IN">
Must be the same writer that the savepoint was created on.
</param>
<param name="pSavepoint" type="IN">
A previously created savepoint.
</param>
</element>
<element function="1">
<functionname returntype="RTS_UI32" parameters="(BINTAGWRITER *pWriter)">BTagWriterGetAvailableBuffer</functionname>
<description>
Reads the available bytes in writer buffer that can be used for data.
</description>
</element>
<element function="1">
<functionname returntype="int" parameters="(BINTAGWRITER *pWriter, RTS_UI8 **ppBuffer, RTS_UI32 *pulSize)">BTagWriterFinish</functionname>
<description>
Finishes the writer. If not all tags have been closed properly this function will fail.
Otherwise it returns the buffer passed in to BTagWriterInit in ppBuffer and the number
of bytes written to the buffer in pulSize;
</description>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(BINTAGWRITER *pWriter, RTS_UI32 ulTag, BTAG_ALIGNMENT align, int bFillBytes, void *pContent, RTS_UI32 ulSize)">BTagWriteSingleTag</functionname>
<description>Write a single tag</description>
<param name="pWriter" type="IN">Pointer to the writer stream</param>
<param name="ulTag" type="IN">Tag to write</param>
<param name="align" type="IN">Alignment of the tag</param>
<param name="pContent" type="IN">Pointer to the tag data</param>
<param name="ulSize" type="IN">Size in bytes of the tag data</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(BINTAGWRITER *pWriter, RTS_UI32 ulTag, BTAG_ALIGNMENT align, void **ppContentList, RTS_UI32 *paulSize)">BTagWriteSingleTag2</functionname>
<description>Write a single tag with more than one content</description>
<param name="pWriter" type="IN">Pointer to the writer stream</param>
<param name="ulTag" type="IN">Tag to write</param>
<param name="align" type="IN">Alignment of the tag</param>
<param name="pContent" type="IN">Pointer to the tag data</param>
<param name="ulSize" type="IN">Size in bytes of the tag data</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="int" parameters="(BINTAGREADER *pReader, RTS_UI8 *pBuffer, RTS_UI32 ulBufferSize)">BTagReaderInit</functionname>
<description>
Initialize a reader.
</description>
<param name="pReader" type="INOUT">
Pass in a BINTAGREADER structure that will be initialized to an empty reader.
</param>
<param name="pBuffer" type="IN">
The buffer that contains the bintag structure to be read. Do not alter the buffer
until the reader isn't used any more.
</param>
<param name="ulBufferSize" type="IN">
The size of pBuffer. It is expected that the whole buffer is in the bintag structure,
possibly containing multiple toplevel tags.
</param>
</element>
<element function="1">
<functionname returntype="int" parameters="(BINTAGREADER *pReader)">BTagReaderPeekNext</functionname>
<description>
Peek at the type of the next element as it would be returned by a call to BTagReaderMoveNext,
but do not actually move to it (ie. the readers state will not be changed).
</description>
<param name="pReader" type="IN">
An active reader.
</param>
<param name="pnElementType" type="OUT">
Will be set to the type of the current element:
<ul>
<li>BTAG_ET_STARTTAG: Reader entered a new tag.</li>
<li>BTAG_ET_ENDTAG: End of the current tag reached. New active tag is the surrounding tag</li>
<li>BTAG_ET_EOF: End of the buffer reached. No more content/tags can be read</li>
</ul>
</param>
</element>
<element function="1">
<functionname returntype="int" parameters="(BINTAGREADER *pReader, int *pnElementType)">BTagReaderMoveNext</functionname>
<description>
Let the reader move on to the next element.
</description>
<param name="pReader" type="IN">
An active reader.
</param>
<param name="pnElementType" type="OUT">
Will be set to the type of the current element:
<ul>
<li>BTAG_ET_STARTTAG: Reader entered a new tag.</li>
<li>BTAG_ET_ENDTAG: End of the current tag reached. New active tag is the surrounding tag</li>
<li>BTAG_ET_EOF: End of the buffer reached. No more content/tags can be read</li>
</ul>
</param>
</element>
<element function="1">
<functionname returntype="int" parameters="(BINTAGREADER *pReader)">BTagReaderSkipContent</functionname>
<description>
Jump to the end of the current tag. The next element that will be read by BTagReaderMoveNext
will be the ENDTAG of the current tag.
</description>
<param name="pReader">
</param>
</element>
<element function="1">
<functionname returntype="int" parameters="(BINTAGREADER *pReader, RTS_UI32 *pulTagId)">BTagReaderGetTagId</functionname>
<description>
Get the id of the current tag. Will fail if the reader is positioned at the toplevel.
</description>
<param name="pulTagId" type="OUT">
Will be set to the id of the current tag.
</param>
</element>
<element function="1">
<functionname returntype="int" parameters="(BINTAGREADER *pReader, RTS_UI32 *pulTagLen)">BTagReaderGetTagLen</functionname>
<description>
Get the tag length of the current tag. Will fail if the reader is positioned at the toplevel.
</description>
<param name="pulTagLen" type="OUT">
Will be set to the length of the current tag.
</param>
</element>
<element function="1">
<functionname returntype="int" parameters="(BINTAGREADER *pReader, int *pbIsDataTag)">BTagReaderIsDataTag</functionname>
<description>
Check if the current tag is a data tag (ie. contains raw content) or does contain
subtags. Will return an error if the reader is not positioned on a tag (ie. is at the
toplevel). However, in that case pbIsData will be set to FALSE.
</description>
<param name="pReader" type="IN">
</param>
<param name="pbIsDataTag" type="IN">
Is set to TRUE, if the current tag is a data tag, FALSE otherwise.
</param>
</element>
<element function="1">
<functionname returntype="int" parameters="(BINTAGREADER *pReader, RTS_UI8 **ppBuffer, RTS_UI32 *pulSize)">BTagReaderGetComplexContent</functionname>
<description>
Get a pointer on the content of the current tag.
</description>
<param name="pReader" type="IN">
</param>
<param name="ppBuffer" type="OUT">
Will be set to point at the content of the current tag.
</param>
<param name="pulSize" type="OUT">
Will contain the size of the content.
</param>
</element>
<element function="1">
<functionname returntype="int" parameters="(BINTAGREADER *pReader, RTS_UI8 **ppBuffer, RTS_UI32 *pulSize)">BTagReaderGetContent</functionname>
<description>
Get a pointer on the content of the current tag.
Will fail if the reader is on the toplevel
(no current tag) or the current tag is not a data tag.
</description>
<param name="pReader" type="IN">
</param>
<param name="ppBuffer" type="OUT">
Will be set to point at the content of the current tag.
</param>
<param name="pulSize" type="OUT">
Will contain the size of the content.
</param>
</element>
<element function="1">
<functionname returntype="int" parameters="(BINTAGREADER *pReader, char **ppString, RTS_UI32 *pulSize, int bAddEndOfString)">BTagReaderGetString</functionname>
<description>
Like BTagReaderGetContent but treats the content as a string. If a '\0' is found
before the end of the tag, pulSize is set to the length up to (and including) the zero.
If bAddEndOfString is set, then '\0' is written at the last byte, if '\0' is not found.
</description>
<note>
If the length of the tag is 0 then no '\0' can be written into the buffer without overwriting
other content. In that case a reference to a static empty string is returned.
</note>
<param name="pReader" type="IN">
</param>
<param name="ppString" type="Out">
Will be set to the start of the string. Will not necessarily point into the readers buffer.
(see note).
</param>
<param name="pulSize" type="IN">
The length of the string INCLUDING the trailing '\0',
ie. "strlen(ppString)+1".
</param>
<param name="bAddEndOfString" type="IN">
Force a trailing zero byte to be added, if it doesn't exist within the bounds of the tag.
Will overwrite the last char of the string.
Note: This option will alter the content of the buffer!
</param>
</element>
<element function="1">
<functionname returntype="int" parameters="(BINTAGREADER *pReader, BINTAGREADERSAVEPOINT *pSavepoint)">BTagReaderCreateSavepoint</functionname>
<description>
Save the current state of the reader. A later call to BTagReaderRestoreSavepoint will
reset the reader and its buffer to that state. Any number of savepoints may be created.
The caller must use multiple savepoints in a stack-like fashion: If savepoints are
created in the order 1,2,3,4 then they must be restored in opposite order only. Not
every savepoint must be restored - but if one is restored all savepoints created after
that one MUST NOT BE USED any more.
Examples: ("sX"="create savepoint X", "rX"="Restore savepoint X",
"(x,y,z)"="stack of valid savepoints")
The following sequences are valid:
() s1 (1) s2 (1,2) s3 (1,2,3) r2 (1) r1 ()
() s1 (1) s2 (1,2) s3 (1,2,3) r2 (1) s4 (1,4) r4 (1)
whereas this one is invalid:
() s1 (1) s2 (1,2) s3 (1,2,3) r2 (1) r3 [3 is not valid at this point]

The reader does not track the stack of savepoints, therefore it cannot
detect errors in the restore order. It's the responsibility of the application
to ensure the correct restore order. Failure in doing so will lead to an
inconsistent state and may well corrupt the whole document.
Besides the restore order savepoints are independent of each other. The application
may delete/reuse a savepoint anytime it doesn't need it anymore.

Savepoints cannot be used to transfer the state of a reader to a second reader.
Any attempt in doing so will lead to undefined behaviour.
</description>
<param name="pReader" type="IN"></param>
<param name="pSavePoint" type="OUT">
Will receive all information needed to restore the current state of the reader.
</param>
</element>
<element function="1">
<functionname returntype="int" parameters="(BINTAGREADER *pReader, BINTAGREADERSAVEPOINT *pSavepoint)">BTagReaderRestoreSavepoint</functionname>
<description>
Restore the state of the reader to one previously saved using
BTagReaderCreateSavepoint. See there for a detailed description on how to use
these functions.
</description>
<param name="pReader" type="IN">
Must be the same reader that the savepoint was created on.
</param>
<param name="pSavepoint" type="IN">
A previously created savepoint.
</param>
</element>
<element function="1">
<functionname returntype="void*" parameters="(BINTAGREADER *pReader, RTS_UI32 *pulToplevelTag, RTS_UI32 *pulTag, RTS_UI32 *pulSize, RTS_RESULT *pResult)">BTagReaderGetFirstTag</functionname>
<description>Get the first tag out of a stream</description>
<param name="pReader" type="IN">Pointer to the reader stream</param>
<param name="pulToplevelTag" type="OUT">Returns the toplevel tag. -1, if no complex tag</param>
<param name="pulTag" type="OUT">Returns the tag</param>
<param name="pulSize" type="OUT">Size of the tag</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Pointer to the content</result>
</element>
<element function="1">
<functionname returntype="void*" parameters="(BINTAGREADER *pReader, RTS_UI32 *pulToplevelTag, RTS_UI32 *pulTag, RTS_UI32 *pulSize, RTS_RESULT *pResult)">BTagReaderGetNextTag</functionname>
<description>Get the first tag out of a stream</description>
<param name="pReader" type="IN">Pointer to the reader stream</param>
<param name="pulToplevelTag" type="OUT">Returns the toplevel tag. -1, if no complex tag</param>
<param name="pulTag" type="OUT">Returns the tag</param>
<param name="pulSize" type="OUT">Size of the tag</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Pointer to the content</result>
</element>
</element>
</component>
<component>
<name>CmpBlkDrvUdp</name>
<description>
A block driver for udp networks. It assumes that all node addresses are within the same
subnet and thus uses only the last ip component for addressing. It is able to
communicate with nodes listening on one of up to four ports, which allows for more then
one runtime system running on a single host.
Detected devices are named "ether 0" through "ether n" where n+1 is the number of detected
network interfaces.
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element tasks="1" name="Tasks">
<element task="1">
<name>BlkDrvUdp</name>
<category>Task</category>
<priority>TASKPRIO_HIGH_END</priority>
<description>Block driver communication task.</description>
</element>
</element>
<element interface="1" name="CmpBlkDrvItf">
<interfacename>CmpBlkDrv</interfacename>
<description>
Block driver interface. This interface could be implemented by different components.
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element define="1">
<name>BLKDRVCOM_MAX_SER_READSIZE</name>
<key>1</key>
<condition>BLKDRVCOM_MAX_SER_READSIZE</condition>
<category>Static defines</category>
<description>
Maximum number of bytes that are read with one call to SysComRead. Can be set to a bigger
value on embedded systems, to minimize the number of calls to SysComRead. Example: 256.
Only for BlkDrvCom.
</description>
</element>
<element define="1">
<name>MAX_UDP_DEVICES</name>
<key>5</key>
<condition>MAX_UDP_DEVICES</condition>
<category>Static defines</category>
<description>
Max number of devices (interfaces), which are used by the CmpBlkDrvUdp.
New setting BLKDRVUDPKEY_INT_MAX_INTERFACES_DEFAULT should be used instead.
</description>
</element>
<element define="1">
<name>UDP_BIND_ADDRESS</name>
<key>0</key>
<category>Static defines</category>
<description> Socket bind option for the CmpBlkDrvUdp. </description>
</element>
<element define="1">
<name>UDP_PACKET_SORT_NONE</name>
<key>0</key>
<category>Static defines</category>
<description>
Options for the CmpBlkDrvUdp to sort packages after receiving or before sending. Sorting for incoming and
outgoing packages can be used seperately or in combination.
</description>
</element>
</element>
</component>
<component>
<name>CmpChannelMgrEmbedded</name>
<description>
This component manages layer 4 communication (splitting and reassembling of messages,
retransmission, ...).
To achieve its tasks it needs either a channel server component.
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element interface="1" name="CmpChannelMgrItf">
<interfacename>CmpChannelMgr</interfacename>
<description>
Interface for the channel manager.
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element define="1">
<name>PKG_LOG_NONE</name>
<key>UINT32_C</key>
<category>Package logfilter</category>
<description>Package info log entry filters for the CmpChannelMgr</description>
<element name="PKG_LOG_NONE" type="Log nothing"></element>
<element name="PKG_LOG_DUPLICATE" type="Log duplicate received blocks"></element>
<element name="PKG_LOG_RX" type="Log all received packages"></element>
<element name="PKG_LOG_TX" type="Log all sent packages"></element>
<element name="PKG_LOG_ACK_TRIG_NUM" type="Log sent ACKs, triggerd by the number of privious received data packages"></element>
<element name="PKG_LOG_ACK_TRIG_TO" type="Log sent ACKs, triggerd by timeout"></element>
<element name="PKG_LOG_IN_ORDER_BLOCK" type="Log in order received blocks"></element>
<element name="PKG_LOG_COMPRESS_BLOCK" type="Log compressing of blocks, if a missing block was received"></element>
<element name="PKG_LOG_OUT_OF_ORDER_BLOCK" type="Log out of order received blocks"></element>
</element>
<element function="1">
<functionname returntype="int" parameters="(CHANNELBUFFER *pChBuffer, RTS_UI16 *pusStatus, RTS_UI8 *pbyScalingFactor, RTS_I32 *pnItemsComplete, RTS_I32 *pnTotalItems)">NetworkGetStatus</functionname>
<description>
Get the current status of an active channel.
</description>
<param name="pChBuffer" type="IN">
The Channel for which to retrieve the status
</param>
<param name="pusStatus" type="OUT">
Is set to the current progress state. The PROGRESS_xxx constants define valied values.
</param>
<param name="pbyScalingFactor" type="OUT">
Provides the scaling factor for pnItemsComplete and pnTotalItems. These values have been scaled
down by dividing them through 2^ScalingFactor
(i.e. they have been right shifted by ScalingFactor bits).
</param>
<param name="pnItemsComplete" type="OUT">
Number of items completed (eg. the number of bytes transfered).
</param>
<param name="pnTotalItems" type="OUT">
Total number of item. Is set to -1 if unknown.

 *  </param>
</element>
<element function="1">
<functionname returntype="RTS_UI32" parameters="( RTS_UI32 dwCommBufferSize, unsigned short wMaxBlockSize, int *pnNumBlocks)">NetworkGetChBufferSize</functionname>
<description>
Given a fixed size for the communication buffer return the required size of the
channel buffer.
</description>
<param name="dwCommBufferSize" type="IN">Requested size of the communication buffer</param>
<param name="wMaxBlockSize" type="IN">
Maximum size of a layer4 block (as returned by RouterGetMaxBlockSize)
</param>
<param name="pnNumBlocks" type="OUT">Required number of block buffers</param>
<result>
The size of the channel buffer in bytes.
</result>
</element>
<element function="1">
<functionname returntype="RTS_UI32" parameters="(CHANNELBUFFER *pChBuffer, RTS_HANDLE hRouter, RTS_UI32 dwBufferSize, unsigned short wChannelId, PEERADDRESS addrSender, unsigned char byChFlags, RTS_UI32 dwMaxCommBuffer)">NetworkInitChannelBuffer</functionname>
<description>
Initialize the provided channelbuffer.
</description>
<param name = "pChBuffer" type="IN"></param>
<param name = "dwBufferSize" type="IN"> Size of pChBuffer. </param>
<param name = "wChannelId" type="IN"> The id of the channel.</param>
<param name = "addrSender" type="IN"> The 3S-address of this channels peer. </param>
<param name = "byFlags" type="IN">
Initial channel flags (CF_SERVERCHANNEL for a serverchannel, CF_SENDMODE for a clientchannel)
</param>
<param name = "dwMaxCommBuffer" type="IN">
Maximum size of the communication buffer to use (usually the requested communication buffer)
</param>
<result>
The size of the communication buffer for this channelbuffer.
</result>
</element>
<element function="1">
<functionname returntype="RTS_UI32" parameters="(CHANNELBUFFER *pChBuffer, RTS_HANDLE hRouter, RTS_UI32 dwBufferSize, unsigned short wChannelId, PEERADDRESS addrSender, unsigned char byChFlags, RTS_UI32 dwMaxCommBuffer, unsigned short wMaxBlockSize)">NetworkInitChannelBuffer2</functionname>
<description>
Initialize the provided channelbuffer with a given maximum Blocksize.
</description>
<param name = "pChBuffer" type="IN"></param>
<param name = "dwBufferSize" type="IN"> Size of pChBuffer. </param>
<param name = "wChannelId" type="IN"> The id of the channel.</param>
<param name = "addrSender" type="IN"> The 3S-address of this channels peer. </param>
<param name = "byFlags" type="IN">
Initial channel flags (CF_SERVERCHANNEL for a serverchannel, CF_SENDMODE for a clientchannel)
</param>
<param name = "dwMaxCommBuffer" type="IN">
Maximum size of the communication buffer to use (usually the requested communication buffer)
</param>
<param name = "wMaxBlockSize" type="IN">
Maximum size of one block
</param>
<result>
The size of the communication buffer for this channelbuffer.
</result>
</element>
<element function="1">
<functionname returntype="int" parameters="(RTS_HANDLE hRouter, PEERADDRESS addrReceiver, L4METAPACKAGE *pMetaPkg, int nPkgSize)">NetworkSendMetaPkg</functionname>
<description>
Send metaPkg to addrReceiver. Sets the checksum field of the metaPkg before sending.
</description>
<param name="addrReceiver" type="IN"> Address of the receiver </param>
<param name="pMetaPkg" type="IN"> The package to be sent</param>
<param name="nPkgSize" type="IN"> Size of pMetaPkg</param>
<result>
An error code.
</result>
</element>
<element function="1">
<functionname returntype="int" parameters="(CHANNELBUFFER *pChBuffer, PROTOCOL_DATA_UNIT pduData)">NetworkSendMessage</functionname>
<description>
Send a message over the provided channel.
A channel can't be receiving and sending at the same time. Thus this function
will fail with ERR_CHANNELMODE if the channel is currently in receive mode.
</description>

<result>
<ul>
<li>ERR_CHANNELMODE if the channel is in receive mode.</li>
<li>ERR_CHC_MESSAGESIZE/ERR_CHS_MESSAGESIZE if the size of the data is greater then the CommBuffer size.</li>
</ul>
</result>
</element>
</element>
</component>
<component>
<name>CmpChannelServer</name>
<description>
A layer4 server component. This component is needed by the network component and by applications
that want to act as a channel server.
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element interface="1" name="CmpChannelServerItf">
<description>
<p>
Interface for the channel server.
</p>
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element define="1">
<name>EVT_ChSChannelClosed</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent when a channel is closed.</description>
<param name="pEventParam" type="IN">EVTPARAM_ChannelClosed</param>
</element>
<element typedefinition="1">
<name>EVTPARAM_ChannelClosed</name>
<structname>EVTPARAM_ChannelClosed</structname>
<category>Event parameter</category>
<element name="ulChannelHandle" type="IN">
The channelhandle is always a combination of two words (16 bit).
The low word (ulChannelHandle masked with 0xFFFF) is the id of
the "physical" channel. The highword is the id of the client using this channel
(multiple clients may use the same channel in a round robbin manner).
A highword of 0xFFFF indicates, that the channel is completely closed
and all clients have disconnected. In all other cases the channel is still
open, only that client has disconnected.
When attaching any resources to a specific channel (eg. open files, logins, ...)
the component should release the resource when the client detaches as
well as release all clients resources when the channel is completely closed.
</element>
<element name="errReason" type="IN">
An error code describing the reason for closing the channel
</element>
<rawdata>
typedef struct
{
	RTS_UI32   ulChannelHandle;
	RTS_RESULT  errReason;
} EVTPARAM_ChannelClosed;
</rawdata>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_UI32 ulChannelHandle, RTS_UI32 ulSessionId)">NetServerSetSessionId</functionname>
<description>
Stores the session id in the channel server status structure.
</description>
<param name="ulChannelHandle" type="IN">Id of the channel for which the session id should be set.</param>
<param name="ulSessionId" type="IN">New session id fo the channel.</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_UI32 ulChannelHandle, RTS_UI32 *pulSessionId)">NetServerGetSessionId</functionname>
<description>
Retrieves the stored session id from the channel server status structure.
</description>
<param name="ulChannelHandle" type="IN">Id of the channel for which the session id should be read.</param>
<param name="pulSessionId" type="OUT">Pointer to return the session id.</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="int" parameters="(PEERADDRESS addrPeer, unsigned short wChannelId, CHANNELBUFFER **ppChBuffer)">NetServerGetChannel</functionname>
<description>
Get the buffer for the specified channel id.

NOTE:
After usage the channelbuffer MUST be released by
calling NetServerReleaseChannel. Failing to do so will prevent the channel
from being closed and the server will eventually run out of channels.
Nevertheless, this function DOES NOT provide exclusive access to the channel.
The L4Base component must use appropriate semaphores to ensure exclusive access.
</description>
<param name = "addrPeer" type="IN">The second endpoint of the channel</param>
<param name="wChannelId" type = "IN">The id of the channel.</param>
<param name="ppChBuffer" type = "OUT">Is set to the channelbuffer, if the channel exists.</param>
</element>
<element function="1">
<functionname returntype="int" parameters="(CHANNELBUFFER *pChBuffer)">NetServerReleaseChannel</functionname>
<description>
Release a channel buffer returned by NetServerGetChannel. This buffer may not be used
after calling this function. Use NetServerGetChannel to acquire access to this channel again.
</description>
<param name="pChBuffer" type = "IN">The channel buffer to release</param>
</element>
<element function="1">
<functionname returntype="int" parameters="(CHANNELBUFFER *pChBuffer, PROTOCOL_DATA_UNIT pduData)">NetServerMessageReceived</functionname>
<description>Called by the L4Base component whenever a complete L7 message arrived on a server channel</description>
<param name="pChBuffer" type="IN">Pointer to the channel buffer</param>
<param name="pduData" type="IN">Content of the message. The server must copy the contents of the message
before sending the next message, since the data pointed to by pData will be valid only until the next
message has been sent or the channel is closed.</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="int" parameters="(RTS_HANDLE hRouter, CHANNELBUFFER *pChBuffer, PROTOCOL_DATA_UNIT pduData)">NetServerMessageReceived2</functionname>
<description>
<p>Obsolete: Use NetServerMessageReceived instead. Will be removed in future versions!</p>
<p>Called by the L4Base component whenever a complete L7 message arrived on a server channel</p></description>
<param name="hRouter" type="IN">Obsolete parameter, should be set to RTS_INVALID_HANDLE.</param>
<param name="pChBuffer" type="IN">Pointer to the channel buffer</param>
<param name="pduData" type="IN">Content of the message. The server must copy the contents of the message
before sending the next message, since the data pointed to by pData will be valid only until the next
message has been sent or the channel is closed.</param>
<result>error code</result>
</element>
</element>
</component>
<component>
<name>CmpChecksum</name>
<description>
Provides functions to calculate CRC-Checksums (CRC-16, CRC-32) etc.
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element define="1">
<name>INIT_VAL32</name>
<key></key>
<condition>UINT32_C</condition>
<description>Initial CRC32 value</description>
</element>
<element interface="1" name="CmpChecksumItf">
<interfacename>CmpChecksum</interfacename>
<description>
Interface for the checksum utility component.
</description>

<copyright>(c) 2003-2011 3S-Smart Software Solutions</copyright>
<element typedefinition="1">
<name>crc16finish_struct</name>
<structname>crc16finish_struct</structname>
<description>crc16finish</description>
<rawdata>
typedef struct tagcrc16finish_struct
{
	RTS_IEC_WORD ulCRC;					VAR_INPUT
	RTS_IEC_WORD CRC16Finish;			VAR_OUTPUT
} crc16finish_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>crc32update2_struct</name>
<structname>crc32update2_struct</structname>
<description>crc32update2</description>
<rawdata>
typedef struct tagcrc32update2_struct
{
	RTS_IEC_DWORD ulCRC;				VAR_INPUT
	RTS_IEC_BYTE *pData;				VAR_INPUT
	RTS_IEC_DWORD ulSize;				VAR_INPUT
	RTS_IEC_DWORD CRC32Update2;			VAR_OUTPUT
} crc32update2_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>crc16init_struct</name>
<structname>crc16init_struct</structname>
<description>crc16init</description>
<rawdata>
typedef struct tagcrc16init_struct
{
	RTS_IEC_WORD CRC16Init;				VAR_OUTPUT
} crc16init_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>crc16update_struct</name>
<structname>crc16update_struct</structname>
<description>crc16update</description>
<rawdata>
typedef struct tagcrc16update_struct
{
	RTS_IEC_WORD ulCRC;					VAR_INPUT
	RTS_IEC_BYTE *pData;				VAR_INPUT
	RTS_IEC_DWORD ulSize;				VAR_INPUT
	RTS_IEC_WORD CRC16Update;			VAR_OUTPUT
} crc16update_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>crc32update_struct</name>
<structname>crc32update_struct</structname>
<description>crc32update</description>
<rawdata>
typedef struct tagcrc32update_struct
{
	RTS_IEC_DWORD ulCRC;				VAR_INPUT
	RTS_IEC_BYTE *pData;				VAR_INPUT
	RTS_IEC_DWORD ulSize;				VAR_INPUT
	RTS_IEC_DWORD CRC32Update;			VAR_OUTPUT
} crc32update_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>crc32init_struct</name>
<structname>crc32init_struct</structname>
<description>crc32init</description>
<rawdata>
typedef struct tagcrc32init_struct
{
	RTS_IEC_DWORD CRC32Init;			VAR_OUTPUT
} crc32init_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>crc32finish_struct</name>
<structname>crc32finish_struct</structname>
<description>crc32finish</description>
<rawdata>
typedef struct tagcrc32finish_struct
{
	RTS_IEC_DWORD ulCRC;				VAR_INPUT
	RTS_IEC_DWORD CRC32Finish;			VAR_OUTPUT
} crc32finish_struct;
</rawdata>
</element>
<element function="1">
<functionname returntype="unsigned short" parameters="(void)">CRC16Init</functionname>
<description>
Implementation of a 16-Bit CRC. The CRC is based on the
CCITT polynom x^16 + x^12 + x^5 + 1.
Since there seem to be different opinions about "the" CCITT CRC-16,
here a description of the options used in this api:
- Bits are shifted in with MSB first
- Input bytes are NOT reversed
- The final CRC is NOT reversed
- Initial value is 0xFFFF
- 16 Zero-bits are implicitly appended to the end of the message
- The "checkvalue" is 0xE5CC (ie. the CRC of the ASCII string '123456789')
</description>
</element>
<element function="1">
<functionname returntype="unsigned short" parameters="(unsigned short usCRC, const unsigned char * pData, RTS_SIZE ulSize)">CRC16Update</functionname>
<description>
Update the CRC with a block of data. Before the first call you have to initialize the
CRC by calling CRC16Init.
</description>
<param name="usCRC" type="IN">
The previous value of the crc as returned by the last call to CRC16Init or
CRC16Update.
</param>
<param name="pData" type="IN">
Points at the data which should be added to the crc.
</param>
<param name="ulSize" type="IN">
The number of bytes in pData.
</param>
<result>
Returns the updated crc.
</result>
</element>
<element function="1">
<functionname returntype="unsigned short" parameters="(unsigned short usCRC)">CRC16Finish</functionname>
<description>
For the CRC to be valid it has to be finished after it is updated with all data.
Use this as the last step during calculating your CRC.
</description>
<param name="usCRC" type="IN">
The current value of the crc to be finished.
</param>
<result>
The checksum over all data passed in via CRC16Update.
</result>
</element>
<element function="1">
<functionname returntype="RTS_UI32" parameters="(void)">CRC32Init</functionname>
<description>Implementation of a initial 32-Bit CRC. Initial value is 0xFFFFFFFF.</description>
<parampseudo name="InitValue" type="IN" range="[INIT_VAL32]">Define that sets the Initial Value</parampseudo>
<result>Returns the initial CRC value.</result>
</element>
<element function="1">
<functionname returntype="RTS_UI32" parameters="(RTS_UI32 ulCRC, const unsigned char *pData, RTS_SIZE ulSize)">CRC32Update</functionname>
<description>
<p>Obsolete: Use CRC32Update2 instead!</p>
<p>Update the CRC with a block of data. Before the first call you have to initialize the
crc by calling CRC32Init. Must only be used, if the CRC is calculated in one step and not
using several calls of CRC32Update for adding data to the CRC.</p>
<p>ATTENTION: You have to finish the CRC with the function CRC32Finish()!</p>
</description>
<param name="ulCRC" type="IN">
The previous value of the crc as returned by the last call to CRC32Init.
</param>
<param name="pData" type="IN">
Points at the data for which the CRC should be calculated.
</param>
<param name="ulSize" type="IN">
The number of bytes in pData.
</param>
<result>
Returns the updated CRC.
</result>
</element>
<element function="1">
<functionname returntype="RTS_UI32" parameters="(RTS_UI32 ulCRC)">CRC32Finish</functionname>
<description>
<p>Obsolete: Use CRC32Finish2 instead!</p>
<p>For the CRC to be valid it has to be finished after it is updated with all data.
Use this as the last step during calculating your CRC.</p>
<p>In opposite to the other CRC algorithms, the resulting CRC is swapped to IntelByteOrder.</p>
</description>
<param name="ulCRC" type="IN">
The current value of the CRC to be finished.
</param>
<result>
The checksum over all data passed in via CRC32Update.
</result>
</element>
<element function="1">
<functionname returntype="RTS_UI32" parameters="(RTS_UI32 ulCRC, const unsigned char *pData, RTS_SIZE ulSize)">CRC32Update2</functionname>
<description>
Update the CRC with a block of data. Before the first call you have to initialize the
CRC by calling CRC32Init.
ATTENTION: You have to finish the CRC with the function CRC32Finish2()!
</description>
<param name="ulCRC" type="IN" range="[0,VALID_CRC32]">
The previous value of the CRC as returned by the last call to CRC32Init or
CRC32Update2.
</param>
<param name="pData" type="IN" range="[VALID_DATA_POINTER]">
Points at the data which should be added to the CRC.
</param>
<param name="ulSize" type="IN" range="[0,VALID_CRC32SIZE]">
The number of bytes in pData.
</param>
<result>
Returns the updated CRC.
</result>
</element>
<element function="1">
<functionname returntype="RTS_UI32" parameters="(RTS_UI32 ulCRC)">CRC32Finish2</functionname>
<description>
For the CRC to be valid it has to be finished after it is updated with all data.
Use this as the last step during calculating your CRC.
</description>
<param name="ulCRC" type="IN" range="[0,VALID_CRC32]">
The current value of the CRC to be finished.
</param>
<result>
The checksum over all data passed in via CRC32Update.
</result>
</element>
</element>
</component>
<component>
<name>CmpCommunicationLib</name>
<description>
Provides basic functions and definitions for the communication system.
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element interface="1" name="CmpCommunicationLibItf">
<interfacename>CmpCommunicationLib</interfacename>
<description>
Interface for the communication library.
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element function="1">
<functionname returntype="int" parameters="(NODEADDRESS addr1, NODEADDRESS addr2)">AddrEquals</functionname>
<description>
</description>
<result>
Returns TRUE if addr1 == addr2, FALSE else
</result>
</element>
<element function="1">
<functionname returntype="int" parameters="(NODEADDRESS addr1, ADDRESSCOMPONENT *pBufAddr2, RTS_UI32 nLenAddr2)">AddrEqualsBuffer</functionname>
<description>
</description>
<result>
Returns TRUE, if addr1 equals the address described by pBufAddr2 and nlenAddr2
</result>
</element>
</element>
</component>
<component>
<name>CmpDevice</name>
<description>
</description>

<copyright>(c) 2003-2012 3S-Smart Software Solutions</copyright>
<element interface="1" name="CmpDeviceItf">
<interfacename>CmpDevice</interfacename>
<description>
<p>Interface for the device component. This is the first component, that contacts a client to get
online access to the target.
Here for example the target identification is checked.</p>
</description>

<copyright>(c) 2003-2012 3S-Smart Software Solutions</copyright>
<element define="1">
<name>SRV_DEV_GET_TARGET_IDENT</name>
<key>0x01</key>
<category>Online services</category>
</element>
<element define="1">
<name>TAG_DEV_REPLY_IDENTIFICATION</name>
<key>0x01</key>
<category>Online service tags</category>
</element>
<element define="1">
<name>SETTINGS_FLAG_KILLTASKONRESET</name>
<key>0x01</key>
<category>Settings flags</category>
<description>Setings flags that re returned by the runtime system</description>
</element>
<element define="1">
<name>USERDB_OBJECT_DEVICE</name>
<key>Device</key>
<category>Static defines</category>
<description>Predefined objects in the runtime</description>
</element>
<element typedefinition="1">
<name>TargetIdent</name>
<structname>TargetIdent</structname>
<category>Target identification</category>
<description>
These values identifies a target completely unique!
</description>
<element name="ulTargetType" type="IN">Target type. See category "Device Types" in SysTargetItf.h.</element>
<element name="ulTargetId" type="IN">ID: HiWord = VendorID, LowWord = ID</element>
<element name="ulTargetVersion" type="IN">Version of the target</element>
<rawdata>
typedef struct
{
	RTS_UI32 ulTargetType;
	RTS_UI32 ulTargetId;
	RTS_UI32 ulTargetVersion;
} TargetIdent;
</rawdata>
</element>
<element typedefinition="1">
<name>DeviceIdentification</name>
<structname>DeviceIdentification</structname>
<category>Device description</category>
<description>
</description>
<element name="targetIdent" type="IN">Target identification</element>
<element name="pwszDeviceName" type="IN">Pointer to device name</element>
<element name="nMaxDeviceNameLen" type="IN">Maximum length of the device name buffer in unicode characters (not bytes!)</element>
<element name="pwszVendorName" type="IN">Pointer to vendor name</element>
<element name="nMaxVendorNameLen" type="IN">Maximum length of the vendor name buffer in unicode characters (not bytes!)</element>
<element name="pwszNodeName" type="IN">Pointer to node name</element>
<element name="nMaxNodeNameLen" type="IN">Maximum length of the node name buffer in unicode characters (not bytes!)</element>
<rawdata>
typedef struct
{
	TargetIdent targetIdent;
	RTS_WCHAR *pwszDeviceName;
	RTS_SIZE nMaxDeviceNameLen;
	RTS_WCHAR *pwszVendorName;
	RTS_SIZE nMaxVendorNameLen;
	RTS_WCHAR *pwszNodeName;
	RTS_SIZE nMaxNodeNameLen;
} DeviceIdentification;
</rawdata>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(DeviceIdentification *pDevIdent)">DevGetIdent</functionname>
<description>Retrieves the target identification</description>
<param name="pDevIdent" type="OUT">Pointer to identification. Is filled by the function. If string pointer are NULL,
the real size of the strings is returned.</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(TargetIdent *pTargetIdentReq, TargetIdent *pTargetIdent)">DevCheckTargetIdent</functionname>
<description>Checks the compatibility between a requested identification and the target identification</description>
<param name="pTargetIdentReq" type="IN">Requested target identification to check</param>
<param name="pTargetIdent" type="IN">Own target identity. Can be NULL, then the built in target identification is used</param>
<result>error code</result>
<errorcode name="RTS_RESULT" type="ERR_OK">Target identifications matched</errorcode>
<errorcode name="RTS_RESULT" type="ERR_TYPE_MISMATCH">Type mismatch</errorcode>
<errorcode name="RTS_RESULT" type="ERR_ID_MISMATCH">ID mismatch</errorcode>
<errorcode name="RTS_RESULT" type="ERR_VERSION_MISMATCH">Version mismatch. Versions not compatible!</errorcode>
</element>
</element>
</component>
<component>
<name>CmpEventMgr</name>
<description>
Manager for all kind of events int the runtime system.
Event manager call registered callback functions on the events
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element interface="1" name="CmpEventMgrItf">
<interfacename>CmpEventMgr</interfacename>
<description>
<p>This is the interface of the event manager. The manager is responsible to handle all events in the
runtime system and to call special registered functions (callbacks) if an event occurred. An event can be
sent in any situation, when a state will be changed in the runtime system. An event can be e.g. stop of
an Iec application, download of an Iec application, exception occurred in a component, etc.</p>

<p>Typically an event will be sent before a state changed (xxxPrepare) and if the state has changed (xxxDone)</p>

<p>The component that provides and sends an event is called the provider. The component that receives the event
is called the consumer of an event.</p>

<p>Each component can define its own event ID. Such an event ID consists of two numbers:
<ul>
<li>Event class:	16 bit number that specifies the class of the event</li>
<li>Event:			16 bit number that specifies the event</li>
</ul>
The event class and the event is matched to one 32 bit number that is called the event ID. The event,
event class and the component ID of the provider makes an event unique. So every provider has
to specify at least these three things to sent an event.</p>

<p>Each provider can specify additional parameters for each event that is transferred to the consumer. This is
event specific and can be specified by the consumer. Such an optional event parameter must be specified by a
component specific parameter ID and with a parameter version number. With this information, a consumer can
check, which parameter in which version the provider is sending.</p>

<p>To use an event, first of all the provider has to register the event. After that, the consumer can open this
event and can attach its callback routine to this event. Such a callback routine can be:</p>
<ul>
<li>C-Function</li>
<li>Iec-Function</li>
<li>Iec-Method of a function block</li>
<li>C++-Method of a C++ class</li>
</ul>

<p>IMPLEMENTATION NOTE: A provider typically registers its event in the CH_INIT2 hook. The consumer typically
registers its callback to special events in the CH_INIT3 hook.</p>
<p>If a provider only wants to register an event if it is really needed by a consumer, the CmpEventMgr sents
a special event, if a consumer tries to open an event (see EVT_EventOpen). In this event, the provider
can register the event and the consumer can open a valid event.</p>
<p>In opposite, if a consumer wants to register a callback on an event, an event is sent if a provider
registers its event (see EVT_EventCreate).</p>
<p>If an event is unregistred by a provider, the event EVT_EventDelete is sent. If an event is closed by
a consumer, the event EVT_EventClose is sent.</p>
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element define="1">
<name>EVENTMGR_NUM_OF_STATIC_EVENTS</name>
<key>50</key>
<condition>EVENTMGR_NUM_OF_STATIC_EVENTS</condition>
<category>Static defines</category>
<description>Maximum number of static allocated events</description>
</element>
<element define="1">
<name>EVENTMGR_NUM_OF_STATIC_CALLBACKS</name>
<key>10</key>
<condition>EVENTMGR_NUM_OF_STATIC_CALLBACKS</condition>
<category>Static defines</category>
<description>Maximum number of static allocated callback routines to be registered</description>
</element>
<element define="1">
<name>EVENTMGR_NUM_OF_STATIC_IECCALLBACKS</name>
<key>5</key>
<condition>EVENTMGR_NUM_OF_STATIC_IECCALLBACKS</condition>
<category>Static defines</category>
<description>Maximum number of static allocated iec callback routines to be registered</description>
</element>
<element define="1">
<name>MAKE_EVENTID</name>
<key>Class</key>
<condition>Event</condition>
<category>Convert macro</category>
<description>Macro to create an event ID with the event class and the event</description>
</element>
<element define="1">
<name>EVTPROVIDER_NONE</name>
<key>0</key>
<category>Provider component ids</category>
<description>Special priovider ids</description>
</element>
<element define="1">
<name>EVTCLASS_NONE</name>
<key>0</key>
<category>Event classes</category>
<description><p>All possible event classes:</p>
<ul>
<li>EVTCLASS_NONE: No class or invalid</li>
<li>EVTCLASS_ALL: All classes</li>
<li>EVTCLASS_INFO: Information</li>
<li>EVTCLASS_WARNING: Warning</li>
<li>EVTCLASS_ERROR: Error</li>
<li>EVTCLASS_EXCEPTION: Exception</li>
<li>EVTCLASS_VENDOR_SPEC: Vendor specific. Can be used for own event classes</li>
</ul>
</description>
</element>
<element define="1">
<name>EVT_NONE</name>
<key>0</key>
<category>Special Events</category>
<description>
<ul>
<li>EVT_NONE: No event or invalid</li>
<li>EVT_ALL: All events</li>
</ul>
</description>
</element>
<element define="1">
<name>EVENT_CALLBACKS_NO_LIMIT</name>
<key>UINT32_MAX</key>
<category>Callback limit</category>
<description>No limit of callbacks possible per event</description>
</element>
<element define="1">
<name>EVT_EventCreate</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent after a provider creates a new event</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpEventMgr</param>
</element>
<element define="1">
<name>EVT_EventDelete</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent before a provider deletes an event</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpEventMgr</param>
</element>
<element define="1">
<name>EVT_EventOpen</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent before a consumer tries to open an event</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpEventMgr</param>
</element>
<element define="1">
<name>EVT_EventClose</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent before a consumer closes an event</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpEventMgr</param>
</element>
<element define="1">
<name>EVT_EventCommCycle</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent in every call of the CH_COMM_CYCLE. Can be used for IEC background jobs.</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpEventMgr</param>
</element>
<element typedefinition="1">
<name>EVTPARAM_CmpEventMgr</name>
<structname>EVTPARAM_CmpEventMgr</structname>
<category>Event parameter</category>
<element name="EventId" type="IN">EventID of the event. Contains the class and the event</element>
<element name="CmpIdProvider" type="IN">Component ID of the provider</element>
<rawdata>
typedef struct
{
	EVENTID EventId;
	CMPID CmpIdProvider;
} EVTPARAM_CmpEventMgr;
</rawdata>
</element>
<element typedefinition="1">
<name>EventParam2</name>
<structname>EventParam2</structname>
<description>EventParam2</description>
<rawdata>
typedef struct tagEventParam2
{
	RTS_IEC_DWORD EventId;
	RTS_IEC_DWORD CmpIdProvider;
	RTS_IEC_WORD usParamId;
	RTS_IEC_WORD usVersion;
	RTS_IEC_BYTE *pParameter;
	RTS_IEC_BYTE *pUserParameter;
} EventParam2;
</rawdata>
</element>
<element typedefinition="1">
<name>icmpeventcallback_eventcallback_struct</name>
<structname>icmpeventcallback_eventcallback_struct</structname>
The interface ICmpEventCallback must be registered for an event. If this event is posted, this callback method is called.
<rawdata>
typedef struct tagicmpeventcallback_eventcallback_struct
{
	icmpeventcallback_struct *pInstance;	VAR_INPUT    
	EventParam *pEventParam;			VAR_INPUT    Pointer to the event parameters, see Struct EventParam
	RTS_IEC_RESULT EventCallback;		VAR_OUTPUT    
} icmpeventcallback_eventcallback_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>eventclose_struct</name>
<structname>eventclose_struct</structname>
Close an event specified by handle
<rawdata>
typedef struct tageventclose_struct
{
	RTS_IEC_HANDLE hEvent;				VAR_INPUT    Event handle
	RTS_IEC_RESULT EventClose;			VAR_OUTPUT    Error code
} eventclose_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>eventcreate_struct</name>
<structname>eventcreate_struct</structname>
Creates a new event object. If event still exists, a handle to this object will be returned.
An IEC event is typically created by the provider in FB_Init of a function block
<rawdata>
typedef struct tageventcreate_struct
{
	RTS_IEC_UDINT EventId;				VAR_INPUT    Event ID of the event. Contains the class and the event
	RTS_IEC_UDINT CmpIdProvider;		VAR_INPUT    Component ID of the provider
	RTS_IEC_RESULT *Result;				VAR_IN_OUT    Error code
	RTS_IEC_HANDLE EventCreate;			VAR_OUTPUT    Handle to created event
} eventcreate_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>eventcreate2_struct</name>
<structname>eventcreate2_struct</structname>
Creates a new event object. If event still exists, a handle to this object will be returned.
An IEC event is typically created by the provider in FB_Init of a function block
<rawdata>
typedef struct tageventcreate2_struct
{
	RTS_IEC_UDINT EventId;				VAR_INPUT    Event ID of the event. Contains the class and the event
	RTS_IEC_UDINT CmpIdProvider;		VAR_INPUT    Component ID of the provider
	RTS_IEC_UDINT nCallbacksPossible;	VAR_INPUT    Maximum number of callbacks possible on this event or EVENT_CALLBACKS_NO_LIMIT for no limit
	RTS_IEC_RESULT *Result;				VAR_IN_OUT    Error code
	RTS_IEC_HANDLE EventCreate2;		VAR_OUTPUT    Handle to created event
} eventcreate2_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>eventdelete_struct</name>
<structname>eventdelete_struct</structname>
Deletes an event specified by handle.
<rawdata>
typedef struct tageventdelete_struct
{
	RTS_IEC_HANDLE hEvent;				VAR_INPUT    Event handle
	RTS_IEC_RESULT EventDelete;			VAR_OUTPUT    Error code
} eventdelete_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>eventgetclass_struct</name>
<structname>eventgetclass_struct</structname>
Extract the event class from eventid. Return value is the event class
<rawdata>
typedef struct tageventgetclass_struct
{
	RTS_IEC_UDINT EventId;				VAR_INPUT    Event id
	RTS_IEC_UINT EventGetClass;			VAR_OUTPUT    
} eventgetclass_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>eventgetevent_struct</name>
<structname>eventgetevent_struct</structname>
Extract the event from eventid. Return value ist the event
<rawdata>
typedef struct tageventgetevent_struct
{
	RTS_IEC_UDINT EventId;				VAR_INPUT    Event ID
	RTS_IEC_UINT EventGetEvent;			VAR_OUTPUT    
} eventgetevent_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>eventopen_struct</name>
<structname>eventopen_struct</structname>
Opens an existing event object. Can be used to check, if the event was created by the provider.
If the event does not exist, an error code is returned.
<rawdata>
typedef struct tageventopen_struct
{
	RTS_IEC_UDINT EventId;				VAR_INPUT    EventID of the event. Contains the class and the event
	RTS_IEC_UDINT CmpIdProvider;		VAR_INPUT    Component ID of the provider
	RTS_IEC_RESULT *Result;				VAR_IN_OUT    Error code
	RTS_IEC_HANDLE EventOpen;			VAR_OUTPUT    Handle to opened event
} eventopen_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>eventpost_struct</name>
<structname>eventpost_struct</structname>
Post or sent an event
<rawdata>
typedef struct tageventpost_struct
{
	RTS_IEC_HANDLE hEvent;				VAR_INPUT    Event handle
	EventParam *pEventParam;			VAR_INPUT    Pointer to the event parameters
	RTS_IEC_RESULT EventPost;			VAR_OUTPUT    Error code
} eventpost_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>eventpostbyevent_struct</name>
<structname>eventpostbyevent_struct</structname>
Post an event direct without the event handle
<rawdata>
typedef struct tageventpostbyevent_struct
{
	RTS_IEC_UDINT EventId;				VAR_INPUT    Event ID of the event. Contains the class and the event
	RTS_IEC_UDINT CmpIdProvider;		VAR_INPUT    Component ID of the provider
	EventParam *pEventParam;			VAR_INPUT    Pointer to the event parameters
	RTS_IEC_RESULT EventPostByEvent;	VAR_OUTPUT    Error code
} eventpostbyevent_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>eventregistercallback_struct</name>
<structname>eventregistercallback_struct</structname>
Register an callback method to an event. The callback must be an interface from an Iec function block!
<rawdata>
typedef struct tageventregistercallback_struct
{
	RTS_IEC_HANDLE hEvent;				VAR_INPUT    Handle to event
	ICmpEventCallback *pICallback;		VAR_INPUT    Interface ICmpEventCallback
	RTS_IEC_RESULT *Result;				VAR_IN_OUT    Error code
	RTS_IEC_HANDLE EventRegisterCallback;	VAR_OUTPUT    Handle to the callback that must be used to unregister with EventUnregisterCallback!
} eventregistercallback_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>eventregistercallback2_struct</name>
<structname>eventregistercallback2_struct</structname>
Register an callback method to an event. The callback must be an interface from an Iec function block!
<rawdata>
typedef struct tageventregistercallback2_struct
{
	RTS_IEC_HANDLE hEvent;				VAR_INPUT    Handle to event
	ICmpEventCallback *pICallback;		VAR_INPUT    Interface ICmpEventCallback
	RTS_IEC_BYTE *pUserParameter;		VAR_INPUT    Pointer to user parameter, that is transmitted to the callback (see EventParam)
	RTS_IEC_RESULT *Result;				VAR_IN_OUT    Error code
	RTS_IEC_HANDLE EventRegisterCallback2;	VAR_OUTPUT    Handle to the callback that must be used to unregister with EventUnregisterCallback!
} eventregistercallback2_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>eventregistercallbackfunction_struct</name>
<structname>eventregistercallbackfunction_struct</structname>
Register a callback function to an event. Callback is the address of an Iec function: ADR(function)
<rawdata>
typedef struct tageventregistercallbackfunction_struct
{
	RTS_IEC_HANDLE hEvent;				VAR_INPUT    Handle to event
	RTS_IEC_BYTE *pfCallbackFunction;	VAR_INPUT    Address of callback function. Prototype: same as ICmpEventCallback::EventCallback method
															  Function pointer is retrieved by the ADR operator: ADR(function)
	RTS_IEC_RESULT EventRegisterCallbackFunction;	VAR_OUTPUT    Error code
} eventregistercallbackfunction_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>eventregistercallbackfunction2_struct</name>
<structname>eventregistercallbackfunction2_struct</structname>
Register a callback function to an event. Callback is the address of an Iec function: ADR(function)
<rawdata>
typedef struct tageventregistercallbackfunction2_struct
{
	RTS_IEC_HANDLE hEvent;				VAR_INPUT    Handle to event
	RTS_IEC_BYTE *pfCallbackFunction;	VAR_INPUT    Address of callback function. Prototype: same as ICmpEventCallback::EventCallback method
															  Function pointer is retrieved by the ADR operator: ADR(function)
	RTS_IEC_BYTE *pUserParameter;		VAR_INPUT    Pointer to user parameter, that is transmitted optional to the callback (see EventParam)
	RTS_IEC_RESULT EventRegisterCallbackFunction2;	VAR_OUTPUT    Error code
} eventregistercallbackfunction2_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>eventregisteredcallbacks_struct</name>
<structname>eventregisteredcallbacks_struct</structname>
Returns the number of registered callbacks on the event
<rawdata>
typedef struct tageventregisteredcallbacks_struct
{
	RTS_IEC_HANDLE hEvent;				VAR_INPUT    Event handle
	RTS_IEC_RESULT *Result;				VAR_IN_OUT    Error code
	RTS_IEC_UDINT EventRegisteredCallbacks;	VAR_OUTPUT    
} eventregisteredcallbacks_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>eventunregistercallback_struct</name>
<structname>eventunregistercallback_struct</structname>
Unregister a callback interface from an event specified by handle and callback interface
<rawdata>
typedef struct tageventunregistercallback_struct
{
	RTS_IEC_HANDLE hEvent;				VAR_INPUT    Event handle
	RTS_IEC_HANDLE hInterface;			VAR_INPUT    Callback handle is returned by EventRegisterCallback() or EventRegisterCallback2()!!!
	RTS_IEC_RESULT EventUnregisterCallback;	VAR_OUTPUT    Error code
} eventunregistercallback_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>eventunregistercallbackfunction_struct</name>
<structname>eventunregistercallbackfunction_struct</structname>
Unregister a callback function from an event specified by handle and callback
<rawdata>
typedef struct tageventunregistercallbackfunction_struct
{
	RTS_IEC_HANDLE hEvent;				VAR_INPUT    Handle to event
	RTS_IEC_BYTE *pfCallbackFunction;	VAR_INPUT    Address of callback function. Function pointer is retrieved by the ADR operator: ADR(function)
	RTS_IEC_RESULT EventUnregisterCallbackFunction;	VAR_OUTPUT    Error code
} eventunregistercallbackfunction_struct;
</rawdata>
</element>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(EVENTID EventId, CMPID CmpIdProvider, RTS_RESULT *pResult)">EventCreate</functionname>
<description>Creates a new event object. If event still exists, a handle to this object will be returned.
An event is typically created by the provider of an event in the CH_INIT_DONE hook.</description>
<param name="EventId" type="IN">Event ID of the event. Contains the class and the event</param>
<param name="CmpIdProvider" type="IN">Component ID of the provider</param>
<param name="pResult" type="OUT">Pointer to the error code</param>
<result>Handle to the event object</result>
</element>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(EVENTID EventId, CMPID CmpIdProvider, RTS_UI32 nCallbacksPossible, RTS_RESULT *pResult)">EventCreate2</functionname>
<description>Creates a new event object. If event still exists, a handle to this object will be returned.
An event is typically created by the provider of an event in the CH_INIT_DONE hook.</description>
<param name="EventId" type="IN">Event ID of the event. Contains the class and the event</param>
<param name="CmpIdProvider" type="IN">Component ID of the provider</param>
<param name="nCallbacksPossible" type="IN">Maximum number of callbacks possible on this event or EVENT_CALLBACKS_NO_LIMIT for no limit</param>
<param name="pResult" type="OUT">Pointer to the error code</param>
<result>Handle to the event object</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hEvent)">EventDelete</functionname>
<description>Deletes an event specified by handle </description>
<param name="hEvent" type="IN">Handle to event</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(void)">EventDeleteAll</functionname>
<description>Delete all registered events and the registered callbacks</description>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(EVENTID EventId, CMPID CmpIdProvider, RTS_RESULT *pResult)">EventOpen</functionname>
<description><p>Opens an existing event object. Can be used to check, if the event was created by the provider.
If the event does not exist, an error code is returned.</p>
Typically an event is opened by the consumer of an event in the CH_INIT_DONE2 hook.</description>
<param name="EventId" type="IN">Event ID of the event. Contains the class and the event</param>
<param name="CmpIdProvider" type="IN">Component ID of the provider</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Handle to the event object</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hEvent)">EventClose</functionname>
<description>Close an event specified by handle</description>
<param name="hEvent" type="IN">Handle to the event</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="unsigned short" parameters="(EVENTID EventId)">EventGetEvent</functionname>
<description>Extract the event from eventid</description>
<param name="EventId" type="IN">Event ID</param>
<result>Event. Is specified in the interface of each component</result>
</element>
<element function="1">
<functionname returntype="unsigned short" parameters="(EVENTID EventId)">EventGetClass</functionname>
<description>Extract the event class from eventid</description>
<param name="EventId" type="IN">Event ID</param>
<result>Event class</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hEvent, ICmpEventCallback *pICallback)">EventRegisterCallback</functionname>
<description>Register an interface callback function to an event. The interface can be from a C object,
a C++ class or a wrapper class for an Iec function block</description>
<param name="hEvent" type="IN">Handle to event</param>
<param name="pICallback" type="IN">Pointer to callback interface</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hEvent, ICmpEventCallback *pICallback, void *pUserParameter)">EventRegisterCallback2</functionname>
<description>Register an interface callback function to an event. The interface can be from a C object,
a C++ class or a wrapper class for an Iec function block</description>
<param name="hEvent" type="IN">Handle to event</param>
<param name="pICallback" type="IN">Pointer to callback interface</param>
<param name="pUserParameter" type="IN">Pointer to user parameter, that is transmitted to the callback (see EventParam)</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hEvent, ICmpEventCallback *pICallback, int bIec, void *pUserParameter)">EventRegisterCallback3</functionname>
<description>Register an interface callback function to an event. The interface can be from a C object,
a C++ class or a wrapper class for an Iec function block</description>
<param name="hEvent" type="IN">Handle to event</param>
<param name="pICallback" type="IN">Pointer to callback interface</param>
<param name="bIec" type="IN">1=Iec interface behind the C interface, 0=C interface</param>
<param name="pUserParameter" type="IN">Pointer to user parameter, that is transmitted to the callback (see EventParam)</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hEvent, ICmpEventCallback *pICallback)">EventUnregisterCallback</functionname>
<description>Unregister a callback interface from an event specified by handle and callback interface</description>
<param name="hEvent" type="IN">Handle to event</param>
<param name="pICallback" type="IN">Pointer to callback interface</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hEvent, PFEVENTCALLBACKFUNCTION pfCallbackFunction, int bIec)">EventRegisterCallbackFunction</functionname>
<description>Register a callback function to an event. Callback function can be a C or Iec function</description>
<param name="hEvent" type="IN">Handle to event</param>
<param name="pfCallbackFunction" type="IN">Pointer to callback function</param>
<param name="bIec" type="IN">1=Iec function, 0=C function</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hEvent, PFEVENTCALLBACKFUNCTION pfCallbackFunction, int bIec, void *pUserParameter)">EventRegisterCallbackFunction2</functionname>
<description>Register a callback function to an event. Callback function can be a C or Iec function</description>
<param name="hEvent" type="IN">Handle to event</param>
<param name="pfCallbackFunction" type="IN">Pointer to callback function</param>
<param name="bIec" type="IN">1=Iec function, 0=C function</param>
<param name="pUserParameter" type="IN">Pointer to user parameter, that is transmitted to the callback (see EventParam)</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hEvent, PFEVENTCALLBACKFUNCTION pfCallbackFunction)">EventUnregisterCallbackFunction</functionname>
<description>Unregister a callback function from an event specified by handle and callback </description>
<param name="hEvent" type="IN">Handle to event</param>
<param name="pfCallbackFunction" type="IN">Pointer to callback function</param>
<result>Error code</result>
</element>
<element function="1">
<functionname returntype="unsigned long" parameters="(RTS_HANDLE hEvent, RTS_RESULT *pResult)">EventRegisteredCallbacks</functionname>
<description>Unregister a callback function from an event specified by handle and callback </description>
<param name="hEvent" type="IN">Handle to event</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Number of regis</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hEvent, EventParam *pEventParam)">EventPost</functionname>
<description>Post or sent an event</description>
<param name="hEvent" type="IN">Handle to event</param>
<param name="pEventParam" type="IN">Pointer to the event parameters</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hEvent, unsigned short usParamId, unsigned short usVersion, void* pParameter)">EventPost2</functionname>
<description>Sent an event and call synchronously all registered callback handler</description>
<param name="hEvent" type="IN">Handle to event</param>
<param name="usParamId" type="IN">Id of the parameter</param>
<param name="usVersion" type="IN">Version of the parameter</param>
<param name="pParameter" type="IN">Pointer to the event specific parameter, that is specified by Id</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(EVENTID EventId, CMPID CmpIdProvider, EventParam *pEventParam)">EventPostByEvent</functionname>
<description>Post an event direct without opening the event</description>
<param name="EventId" type="IN">Event ID of the event. Contains the class and the event</param>
<param name="CmpIdProvider" type="IN">Component ID of the provider</param>
<param name="pEventParam" type="IN">Pointer to the event parameters</param>
<result>error code</result>
</element>
</element>
</component>
<component>
<name>CmpIecTask</name>
<description>
Component for IEC task management
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element interface="1" name="CmpIecTaskItf">
<interfacename>CmpIecTask</interfacename>
<description>
<p>The component CmpIecTask provides an interface to create an handle all
task of one or more IEC applications.</p>
<p>The following drawing describes the dependencies between the structures
of this and other components in this context:</p>
<pre>
+-----------+ 1   1 +-----------+ 1   n +---------+
| Task_Desc | ----- | Task_Info | ----- | SlotPOU |
+-----------+       +-----------+       +---------+
| n   | 1
|     '--------------.
| 1                  | 1
+-------------+     +-----------+
| Application |     | SchedTask |
+-------------+     +-----------+
</pre>
<p>Depending on the Scheduler, the task might furthermore be mapped to
a hardware ressource or another operating system object.</p>
<p>CmpSchedule (Multitasking):</p>
<pre>
+-----------+ 1   1 +---------------+ 1   1 +----------------+
| SchedTask | ----- | SYS_TASK_INFO | ----- | OS Task Handle |
+-----------+       +---------------+       +----------------+
</pre>
<p>CmpScheduleTimer:</p>
<pre>
+-----------+ 1   1 +----------------+ 1   1 +-----------------+
| SchedTask | ----- | SYS_TIMER_INFO | ----- | HW Timer Handle |
+-----------+       +----------------+       +-----------------+
</pre>
<p>CmpScheduleEmbedded:</p>
<pre>
+-----------+
| SchedTask |
+-----------+
</pre>
<p>The Task_Info structure is created and allocated in the IEC data area of
the application, while everything else is allocated in the runtime.</p>
<p>Beside the handling of tasks, this component manages also the slots for
the tasks, that might be registered by C or IEC code. Those slots are stored
within a memory pool, from which they are called at some specific points
before and after the IEC task cycle code.</p>
<p>For SIL2 certified systems, those slots are denied, because they
potentially cause a call to an unsafe context from the safe context of
the IEC task. So we allow those calls only in debug mode.</p>
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element define="1">
<name>EVT_AfterReadingInputs</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent after reading inputs</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpIecTask</param>
</element>
<element define="1">
<name>EVT_BeforeWritingOutputs</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent before writing outputs</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpIecTask</param>
</element>
<element define="1">
<name>EVT_BeforeReadingInputs</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent before reading inputs</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpIecTask</param>
</element>
<element define="1">
<name>EVT_AfterWritingOutputs</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent after writing outputs</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpIecTask</param>
</element>
<element define="1">
<name>EVT_IecTask_ReloadInit</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent at reload of an IOEC task right after the task is deleted</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpIecTask</param>
</element>
<element define="1">
<name>EVT_IecTaskCreateDone</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent, after an IEC-task was created at application download</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpIecTask</param>
</element>
<element define="1">
<name>EVT_IecTaskPrepareDelete</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent, before an IEC-task will be deleted (e.g. delete of the application)</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpIecTask</param>
</element>
<element define="1">
<name>EVT_IecTaskDebugLoop</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent cyclically in the debug loop, if the IEC task is halted on a breakpoint</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpIecTask</param>
</element>
<element define="1">
<name>TaskCyclic</name>
<key>0x0000</key>
<category>IEC task types</category>
<description></description>
</element>
<element define="1">
<name>TS_WATCHDOG_ENABLE</name>
<key>0x0040</key>
<category>Task status definitions</category>
<description></description>
</element>
<element define="1">
<name>TF_WATCHDOG_ENABLE</name>
<key>6</key>
<category>Task status bits</category>
<description></description>
</element>
<element define="1">
<name>ITF_VISU_TASK</name>
<key>0x00000001</key>
<category>Iec Task Flags</category>
<element name="ITF_VISU_TASK" type="IN">This task is a visu task</element>
</element>
<element define="1">
<name>IECTASK_TASK_INFO_VERSION</name>
<key>2</key>
<category>Task Info</category>
<description><p>Currently supported version number of the task info strcuture.</p></description>
</element>
<element define="1">
<name>IECTASK_TASK_MAX_PRIO</name>
<key>255</key>
<category>Task Info</category>
<description><p>Currently supported max number of task priority.</p></description>
</element>
<element typedefinition="1">
<name>EVTPARAM_CmpIecTask</name>
<structname>EVTPARAM_CmpIecTask</structname>
<category>Event parameter</category>
<element name="pTaskDesc" type="IN">Pointer to task description</element>
<rawdata>
typedef struct
{
	struct tagTask_Desc *pTaskDesc;
} EVTPARAM_CmpIecTask;
</rawdata>
</element>
<element typedefinition="1">
<name>Task_Desc</name>
<structname>Task_Desc</structname>
<description>Local Task Description</description>
<SIL2/>
<rawdata>
typedef struct tagTask_Desc
{
	int iId;
	int bIgnoreWatchdogInCycle;
	RTS_HANDLE hSlotPOUPool;
	RTS_HANDLE hIecTask;
	RTS_HANDLE hSched;
	APPLICATION* pAppl;
	struct tagTask_Info *pInfo;
	RegContext Context;
	RTS_SYSTIME tCycleStart;
	RTS_SYSTIME tAccumulatedCycleTime;
	RTS_UI32 ulStackSize;
	unsigned char StaticSlotPool[MEM_GET_STATIC_LEN(NUM_OF_STATIC_IEC_SLOTS, SlotPOU)];
	void *pCppInstance;
	RTS_UI32 ulWatchdogCycleCount;
	RTS_UI32 ulFlags;
	int iWatchdogHitCount;
#ifdef RTS_ENABLE_TASK_TRACE	
	RTS_HANDLE hTracePacket;
	RTS_HANDLE hTraceRecord;
#endif
} Task_Desc;
</rawdata>
</element>
<element typedefinition="1">
<name>LDATAREF_TYPE</name>
<structname>LDATAREF_TYPE</structname>
<description>LDATAREF_TYPE</description>
<rawdata>
typedef struct tagLDATAREF_TYPE
{
	RTS_IEC_UINT POURef;
	RTS_IEC_UDINT Offset;
	RTS_IEC_UDINT Size;
} LDATAREF_TYPE;
</rawdata>
</element>
<element typedefinition="1">
<name>SYSIECTASKCONFENTRY</name>
<structname>SYSIECTASKCONFENTRY</structname>
<description>SYSIECTASKCONFENTRY</description>
<rawdata>
typedef struct tagSYSIECTASKCONFENTRY
{
	RTS_IEC_USINT byTaskNr;
	RTS_IEC_USINT byPriority;
	RTS_IEC_DINT lInterval;
	LDATAREF_TYPE ldrEvent;
	RTS_IEC_UINT wIndex;
	RTS_IEC_UDINT ulNameLen;
	RTS_IEC_STRING szName[81];
} SYSIECTASKCONFENTRY;
</rawdata>
</element>
<element typedefinition="1">
<name>SYSIECTASKINFO</name>
<structname>SYSIECTASKINFO</structname>
<description>SYSIECTASKINFO</description>
<rawdata>
typedef struct tagSYSIECTASKINFO
{
	RTS_IEC_DWORD dwCount;
	RTS_IEC_DWORD dwCycleTime;
	RTS_IEC_DWORD dwCycleTimeMin;
	RTS_IEC_DWORD dwCycleTimeMax;
	RTS_IEC_DWORD dwCycleTimeAvg;
	RTS_IEC_WORD wStatus;
	RTS_IEC_WORD wMode;
} SYSIECTASKINFO;
</rawdata>
</element>
<element typedefinition="1">
<name>iectaskgetconfig_struct</name>
<structname>iectaskgetconfig_struct</structname>
<description>This function return the iec task configuration </description>
<rawdata>
typedef struct tagiectaskgetconfig_struct
{
	RTS_IEC_UDINT udiTaskId;			VAR_INPUT
	SYSIECTASKCONFENTRY *pTaskConfig;	VAR_INPUT
	RTS_IEC_UDINT IecTaskGetConfig;		VAR_OUTPUT
} iectaskgetconfig_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>iectaskgetinfo_struct</name>
<structname>iectaskgetinfo_struct</structname>
<description>iectaskgetinfo</description>
<rawdata>
typedef struct tagiectaskgetinfo_struct
{
	RTS_IEC_STRING *stTaskName;			VAR_INPUT
	SYSIECTASKINFO *pTaskInfo;			VAR_INPUT
	RTS_IEC_UDINT IecTaskGetInfo;		VAR_OUTPUT
} iectaskgetinfo_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>Jitter_Distribution</name>
<structname>Jitter_Distribution</structname>
<description>Jitter_Distribution</description>
<SIL2/>
<rawdata>
typedef struct tagJitter_Distribution
{
	RTS_IEC_WORD wRangeMax;
	RTS_IEC_WORD wCountJitterNeg;
	RTS_IEC_WORD wCountJitterPos;
} Jitter_Distribution;
</rawdata>
</element>
<element typedefinition="1">
<name>iectaskgetprofiling_struct</name>
<structname>iectaskgetprofiling_struct</structname>
<description>iectaskgetprofiling</description>
<rawdata>
typedef struct tagiectaskgetprofiling_struct
{
	RTS_IEC_BOOL IecTaskGetProfiling;	VAR_OUTPUT
} iectaskgetprofiling_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>iectaskgetcurrent_struct</name>
<structname>iectaskgetcurrent_struct</structname>
<description>iectaskgetcurrent</description>
<rawdata>
typedef struct tagiectaskgetcurrent_struct
{
	RTS_IEC_UDINT *pResult;				VAR_INPUT
	RTS_IEC_BYTE *IecTaskGetCurrent;	VAR_OUTPUT
} iectaskgetcurrent_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>iectaskenablewatchdog_struct</name>
<structname>iectaskenablewatchdog_struct</structname>
<description>iectaskenablewatchdog</description>
<rawdata>
typedef struct tagiectaskenablewatchdog_struct
{
	RTS_IEC_BYTE *hIecTask;				VAR_INPUT
	RTS_IEC_UDINT IecTaskEnableWatchdog;	VAR_OUTPUT
} iectaskenablewatchdog_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>iectaskgetinfo2_struct</name>
<structname>iectaskgetinfo2_struct</structname>
<description>iectaskgetinfo2</description>
<rawdata>
typedef struct tagiectaskgetinfo2_struct
{
	RTS_IEC_BYTE *hIecTask;				VAR_INPUT
	RTS_IEC_UDINT *pResult;				VAR_INPUT
	Task_Info *IecTaskGetInfo2;			VAR_OUTPUT
} iectaskgetinfo2_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>iectaskgetnext_struct</name>
<structname>iectaskgetnext_struct</structname>
<description>iectaskgetnext</description>
<rawdata>
typedef struct tagiectaskgetnext_struct
{
	RTS_IEC_STRING *pszAppName;			VAR_INPUT
	RTS_IEC_BYTE *hPrevIecTask;			VAR_INPUT
	RTS_IEC_UDINT *pResult;				VAR_INPUT
	RTS_IEC_BYTE *IecTaskGetNext;		VAR_OUTPUT
} iectaskgetnext_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>iectaskgetfirst_struct</name>
<structname>iectaskgetfirst_struct</structname>
<description>iectaskgetfirst</description>
<rawdata>
typedef struct tagiectaskgetfirst_struct
{
	RTS_IEC_STRING *pszAppName;			VAR_INPUT
	RTS_IEC_UDINT *pResult;				VAR_INPUT
	RTS_IEC_BYTE *IecTaskGetFirst;		VAR_OUTPUT
} iectaskgetfirst_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>iectaskreload_struct</name>
<structname>iectaskreload_struct</structname>
<description>Reload a specified IEC task. Reload means here: Delete the task at the actual position and create it newly.</description>
<param name="hIecTask" type="IN">Handle to the task to reload</param>
<param name="udiTimeoutMs" type="IN">Timeout in milliseconds to wait, until the task deleted itself. Timeout can be one of the following predefined values:
RTS_TIMEOUT_DEFAULT: Default timeout to delete the task
RTS_TIMEOUT_NO_WAIT: Immediate deletion of the task
See SysTypes.library for details.
</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Handle to the new created task </result>
<rawdata>
typedef struct tagiectaskreload_struct
{
	RTS_IEC_BYTE *hIecTask;				VAR_INPUT
	RTS_IEC_UDINT udiTimeoutMs;			VAR_INPUT
	RTS_IEC_UDINT *pResult;				VAR_INPUT
	RTS_IEC_BYTE *IecTaskReload;		VAR_OUTPUT
} iectaskreload_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>iectaskdisablewatchdog_struct</name>
<structname>iectaskdisablewatchdog_struct</structname>
<description>iectaskdisablewatchdog</description>
<rawdata>
typedef struct tagiectaskdisablewatchdog_struct
{
	RTS_IEC_BYTE *hIecTask;				VAR_INPUT
	RTS_IEC_UDINT IecTaskDisableWatchdog;	VAR_OUTPUT
} iectaskdisablewatchdog_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>iectaskenablescheduling_struct</name>
<structname>iectaskenablescheduling_struct</structname>
<description>iectaskenablescheduling</description>
<rawdata>
typedef struct tagiectaskenablescheduling_struct
{
	RTS_IEC_HANDLE hIecTask;			VAR_INPUT
	RTS_IEC_RESULT IecTaskEnableScheduling;	VAR_OUTPUT
} iectaskenablescheduling_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>iectaskdisablescheduling_struct</name>
<structname>iectaskdisablescheduling_struct</structname>
<description>iectaskdisablescheduling</description>
<rawdata>
typedef struct tagiectaskdisablescheduling_struct
{
	RTS_IEC_HANDLE hIecTask;			VAR_INPUT
	RTS_IEC_RESULT IecTaskDisableScheduling;	VAR_OUTPUT
} iectaskdisablescheduling_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>iectaskresetstatistics_struct</name>
<structname>iectaskresetstatistics_struct</structname>
<description>iectaskresetstatistics</description>
<rawdata>
typedef struct tagiectaskresetstatistics_struct
{
	RTS_IEC_HANDLE hIecTask;			VAR_INPUT
	RTS_IEC_RESULT IecTaskResetStatistics;	VAR_OUTPUT
} iectaskresetstatistics_struct;
</rawdata>
</element>
<element function="1">
<functionname returntype="void" parameters="(sys_setup_tasks_struct* p)">__sys__setup__tasks</functionname>
<description>
<p>External function is called by internal plc code to setup a plc task.
If a task can not be created, an exception is thrown.</p>
</description>
<param name="p" type="IN" range="[VALID_SETUP_TASKS_PARAM]">Pointer to task configuration entry. Is an implicit generated plc data structure.</param>
<parampseudo name="p.pszApplicationName" type="IN" range="[NULL,VALID_APPNAME]">Application name</parampseudo>
<parampseudo name="p.wNumOfTasks" type="IN" range="[0..NUM_OF_STATIC_IEC_TASKS-1,NUM_OF_STATIC_IEC_TASKS..INT_MAX]">Nmber of configured tasks</parampseudo>
<parampseudo name="p.pptaskinfo" type="IN" range="[VALID_TASKINFO_LIST]">Only valid info structures are allowed.</parampseudo>
<parampseudo name="OperationMode" type="IN" range="[RTS_SIL2_OPMODE_SAFE,RTS_SIL2_OPMODE_DEBUG]">Operation mode</parampseudo>
<parampseudo name="bException" type="OUT">Indicates if the function call generated an exception</parampseudo>
<parampseudo name="bTaskCreated" type="OUT">Indicates if the task could be created</parampseudo>
<result>no result</result>
</element>
<element function="1">
<functionname returntype="void" parameters="(sys_register_slot_pou_struct* p)">__sys__register__slot__pou</functionname>
<description>
<p>Register an IEC function function to a specific slot.</p>
<p>Slots are called in numbered order at specific positions in the task cycle</p>
<p>On SIL2 Runtimes, this call is only allowed in safety mode.</p>
</description>
<param name="p" type="IN" range="[VALID_REGISTER_SLOT_POU_PARAM]">IEC function call parameters.</param>
<parampseudo name="p.szApplicationName" type="IN" range="[NULL,VALID_APPNAME]">Application name</parampseudo>
<parampseudo name="p.szTaskName" type="IN" range="[NULL,VALID_TASKNAME]">Task name</parampseudo>
<parampseudo name="p.pFunctionPointer" type="IN" range="[NULL,VALID_SLOTFUNCTION]">Pointer to slot function</parampseudo>
<parampseudo name="p.nSlotNr" type="IN" range="[RTS_RANGE_OF_INT]">Slot number</parampseudo>
<parampseudo name="p.nReturnValue" type="OUT">Error Code</parampseudo>
<result>Error code</result>
<errorcode name="RTS_RESULT" type="ERR_OK">Registration was successfull</errorcode>
<errorcode name="RTS_RESULT" type="ERR_FAILED">Call was not allowed in this context or registration failed</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">Application- or function pointer was NULL</errorcode>
</element>
<element function="1">
<functionname returntype="void" parameters="(sys_register_slot_pou_struct* p)">__sys__unregister__slot__pou</functionname>
<description>
<p>Unregister an IEC function function from a specific slot.</p>
<p>On SIL2 Runtimes, this call is only allowed in safety mode.</p>
</description>
<param name="p" type="IN" range="[VALID_UNREGISTER_SLOT_POU_PARAM]">IEC function call parameters.</param>
<parampseudo name="p.szApplicationName" type="IN" range="[NULL,VALID_APPNAME]">Application name</parampseudo>
<parampseudo name="p.szTaskName" type="IN" range="[NULL,VALID_TASKNAME]">Task name</parampseudo>
<parampseudo name="p.pFunctionPointer" type="IN" range="[NULL,VALID_SLOTFUNCTION]">Pointer to slot function</parampseudo>
<parampseudo name="p.nSlotNr" type="IN" range="[RTS_RANGE_OF_INT]">Slot number</parampseudo>
<parampseudo name="p.nReturnValue" type="OUT">Error Code</parampseudo>
<result>Error code</result>
<errorcode name="RTS_RESULT" type="ERR_OK">Deregistration was successfull</errorcode>
<errorcode name="RTS_RESULT" type="ERR_FAILED">Call was not allowed in this context or deregistration failed</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">Application- or function pointer was NULL</errorcode>
</element>
<element function="1">
<functionname returntype="void" parameters="(sys_rts_cycle_struct* p)">__sys__rts__cycle</functionname>
<description>
<p>This function is obsolete and may not be used in SIL2 Runtime! (SIL2 Note: An Exception is generated if function is called in SIL2 Runtime!) </p>
<p>If supported for backward compatibility, it executes the
callbacks from a specific slot.</p>
</description>
<param name="p" type="IN" range="[VALID_RTS_CYCLE_PARAM]">IEC function call parameters.</param>
<parampseudo name="bException" type="OUT">Indicates if the function call generated an exception</parampseudo>
<result>Error code</result>
</element>
<element function="1">
<functionname returntype="void" parameters="(sys_rts_cycle_2_struct* p)">__sys__rts__cycle__2</functionname>
<description>
<p>This function executes a specific range of registered slots.</p>
</description>
<param name="p" type="IN" range="[VALID_RTS_CYCLE_2_PARAM]">IEC function call parameters.</param>
<parampseudo name="p.hTask" type="IN" range="[NULL,RTS_INVALID_HANDLE,VALID_TASKHANDLE]">Task Handle</parampseudo>
<parampseudo name="p.slotLower" type="IN" range="[RTS_RANGE_OF_INT]">Lower slot limit</parampseudo>
<parampseudo name="p.slotUpper" type="IN" range="[RTS_RANGE_OF_INT]">Upper slot limit</parampseudo>
<parampseudo name="bException" type="OUT">Indicates if the function call generated an exception</parampseudo>
<result>nothing</result>
</element>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(APPLICATION *pApp, Task_Info *pTaskInfo, RTS_RESULT *pResult)">IecTaskCreate</functionname>
<description>
<p>Create a new IEC Task</p>
<p>IEC Tasks itself are used by the scheduler of the runtime. They don't
essentially need a corresponding OS task or timer. They might be handled
by the scheduler in a completely different way.</p>
<p>For example: The embedded scheduler calls the task code directly in
the comm-cycle.</p>
<p>The Task registers itself at the scheduler, by calling the function
SchedAddTask().</p>
<p>When the define RTS_COMPACT is set, no semaphores are used.</p>
<p>When the define RTS_SIL2 is set, no dynamic memory allocation is used.</p>
</description>
<param name="pApp" type="IN" range="[NULL,VALID_APPLICATION]">Pointer to application that contains the task</param>
<parampseudo name="pApp.iId" type="IN" range="[0..APPL_NUM_OF_STATIC_APPLS-1,APPL_NUM_OF_STATIC_APPLS..INT_MAX]">Application ID</parampseudo>
<parampseudo name="s_hIecTaskPool" type="IN" range="[0,NUM_OF_STATIC_IEC_TASKS]">Number of already allocated tasks</parampseudo>
<param name="pTaskInfo" type="IN" range="[NULL,INVALID_TASKINFO,VALID_TASKINFO]">Pointer to task information</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Handle to newly created task</result>
<errorcode name="pResult" type="ERR_OK">The new task was successfully created.</errorcode>
<errorcode name="pResult" type="ERR_FAILED">There was an error in a subsystem (e.g. the scheduler could not allocate his task handle).</errorcode>
<errorcode name="pResult" type="ERR_PARAMETER">Invalid application- or task info pointer</errorcode>
<errorcode name="pResult" type="ERR_OUT_OF_LIMITS">Maximum number of Tasks reached (target specific)</errorcode>
<errorcode name="pResult" type="ERR_NOMEMORY">Unable to allocate the memory, that is necessary for the task description</errorcode>
</element>
<element function="1">
<functionname returntype="Task_Desc *" parameters="(RTS_HANDLE hIecTask)">IecTaskGetDesc</functionname>
<description>
<p>Return task description for a task, specified by it's task handle.
</p>
</description>
<param name="hIecTask" type="IN" range="[RTS_INVALID_HANDLE,NULL,VALID_TASKHANDLE]">Handle to task</param>
<result>Task Description or NULL if task handle was NULL or invalid</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hIecTask)">IecTaskDebugLoop</functionname>
<description>Is called in debug loop, when IEC task is halted on breakpoint</description>
<param name="hIecTask" type="IN">Handle to IEC task</param>
<result>ERR_OK</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hIecTask)">IecTaskDebugEnter</functionname>
<description>Is called before entering debug loop, when IEC task is halted on breakpoint</description>
<param name="hIecTask" type="IN">Handle to IEC task</param>
<result>ERR_OK</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hIecTask)">IecTaskDebugLeave</functionname>
<description>Is called after leaving debug loop, when IEC task was halted on breakpoint</description>
<param name="hIecTask" type="IN">Handle to IEC task</param>
<result>ERR_OK</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hIecTask, RegContext *pContext)">IecTaskSetContext</functionname>
<description>Set context of the actual task</description>
<param name="hIecTask" type="IN">Handle to IEC task</param>
<param name="pContext" type="IN">Pointer to register context</param>
<result>ERR_OK</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hIecTask, RegContext *pContext)">IecTaskGetContext</functionname>
<description>Get context of the actual task</description>
<param name="hIecTask" type="IN">Handle to IEC task</param>
<param name="pContext" type="IN">Pointer to register context</param>
<result>ERR_OK</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hIecTask, RTS_UI32 ulException, RegContext Context)">IecTaskExceptionHandler</functionname>
<description>Exception handler for the specified Iec task</description>
<param name="hIecTask" type="IN">Handle to IEC task</param>
<param name="ulException" type="IN">Exception</param>
<param name="pContext" type="IN">Pointer to register context</param>
<result>ERR_OK</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hIecTask)">IecTaskEnableScheduling</functionname>
<description>
<p>Enable scheduling for one specified task.</p>
</description>
<param name="hIecTask" type="IN" range="[RTS_INVALID_HANDLE,VALID_TASKHANDLE]">Handle of task to enable scheduling</param>
<result>Error code</result>
<errorcode name="RTS_RESULT" type="ERR_OK">The task was enabled</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">The task handle was invalid</errorcode>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hIecTask)">IecTaskDisableScheduling</functionname>
<description>Disable scheduling for the specified task</description>
<param name="hIecTask" type="IN">Handle of task to disable scheduling</param>
<result>Error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hIecTask)">IecTaskEnableWatchdog</functionname>
<description>
<p>Enable watchdog for the specified task</p>
</description>
<param name="hIecTask" type="IN" range="[RTS_INVALID_HANDLE,VALID_TASKHANDLE]">Handle of the task</param>
<result>Error code</result>
<errorcode name="RTS_RESULT" type="ERR_OK">The watchdog for the task was enabled</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">The task handle was invalid</errorcode>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hIecTask)">IecTaskDisableWatchdog</functionname>
<description>
<p>Disable watchdog for the specified task</p>
</description>
<param name="hIecTask" type="IN" range="[RTS_INVALID_HANDLE,VALID_TASKHANDLE]">Handle of the task</param>
<result>Error code</result>
<errorcode name="RTS_RESULT" type="ERR_OK">The watchdog for the task was disabled</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">The task handle was invalid</errorcode>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hIecTask, RTS_SYSTIME *ptActUs)">IecTaskCheckWatchdog</functionname>
<description>
<p>Check if the watchdog of a task expired.</p>
<p>This function is called by the scheduler, as well as from the
task context.</p>
<p>If the watchdog expired, an exception is generated and (depending
on the scheduler) the function will return ERR_FAILED. Note, that
this function does not essentially return, because some schedulers
are not able to recover from this error in a way that the function
can return.</p>
<p>Handling of the Sensitivity:
<ul>
<li>0,1,2: Exception in first cycle if it exceeds WD time * sensitivity</li>
<li>3-MAX_INT: Exception in (sensitivity-1)'th cycle if time exceeded, or in first if time exceeded by WD time * sensitivity</li>
</ul>
</p>
</description>
<param name="hIecTask" type="IN" range="[RTS_INVALID_HANDLE,VALID_TASKHANDLE]">Handle of the task</param>
<param name="ptActUs" type="IN" range="[0,PT1,PT2,PT3,PT4]">Optional pointer to actual time tick in microseconds. Can be NULL.</param>
<parampseudo name="hIecTask.watchdogtime" type="IN" range="[0..400000000,400000001..INT_MAX]">Configured WD time</parampseudo>
<parampseudo name="hIecTask.sensitivity" type="IN" range="[0,1,2,3..10,11..INT_MAX]">Configured WD sensitivity</parampseudo>
<parampseudo name="hIecTask.iWatchdogHitCount" type="IN" range="[0,1,2,3]">Specifies how often the watchdog exceeded already</parampseudo>
<result>Error code</result>
<errorcode name="RTS_RESULT" type="ERR_OK">The watchdog did not expire or it is currently disabled for this task</errorcode>
<errorcode name="RTS_RESULT" type="ERR_FAILED">The watchdog expired and the scheduler returned from the exception</errorcode>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION *pApp)">IecFreeTasks</functionname>
<description> Frees all IEC tasks </description>
<param name="pApp" type="IN">Pointer to specified application</param>
<result>Error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION *pApp, RTS_UI32 ulTimeoutMs)">IecFreeTasks2</functionname>
<description> Frees all IEC tasks </description>
<param name="pApp" type="IN">Pointer to specified application</param>
<param name="ulTimeoutMs" type="IN">Timeout in milliseconds to release the tasks. RTS_TIMEOUT_DEFAULT can be used as the default value</param>
<result>Error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(Task_Desc* pTask)">IecTaskCycle</functionname>
<description>
<p>Main cycle of an Iec task</p>
<p>Adopts the "running state" of the task, based on the current state of
it's application and starts the IEC task cycle:</p>
<ul>
<li>ITF_DONT_SCHEDULE: Return ERR_PENDING</li>
<li>OS_PROGRAM_LOADED: If not set, ERR_FAILED is returned</li>
<li>AS_SINGLE_CYCLE: if task has TS_SINGLE_CYCLE flag set, set also TS_STOP</li>
<li>AS_RUN: reset TS_STOP</li>
<li>Application status != AS_RUN, AS_SINGLE_CYCLE: set TS_STOP</li>
</ul>
<p>Additionally this functions measures the time around the IEC task
cycle and calls IecTaskCheckWatchdog() to create a watchdog exception
if the time exceeded.</p>
<p>Note: This function may throw an exception, when program for the task was not, yet, loaded,
or when the task configuration contains no pointer for the cycle code.</p>
</description>
<param name="pTask" type="IN" range="[NULL,INVALID_TASK,VALID_TASK,VALID_TASK_NO_ENTRY]">Pointer to task description</param>
<parampseudo name="AppState" type="IN" range="[AS_NONE,AS_RUN,AS_STOP,AS_SINGLE_CYCLE]">The state of the task depends on the state of the corresponding application.</parampseudo>
<parampseudo name="AppOpState" type="IN" range="[OS_NONE,OS_PROGRAM_LOADED]">The state of the task depends on the state of the corresponding application.</parampseudo>
<parampseudo name="TaskFlags" type="IN" range="[0,ITF_DONT_SCHEDULE]">Defines the task flags before the call.</parampseudo>
<parampseudo name="TaskStatus" type="INOUT" range="[0,TS_SINGLE_CYCLE,TS_STOP,TS_SINGLE_CYCLE|TS_STOP]">Defines the task flags before the call.</parampseudo>
<parampseudo name="bException" type="OUT">Indicates if the function call generated an exception</parampseudo>
<result>Error code</result>
<errorcode name="RTS_RESULT" type="ERR_OK">Task was called</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PENDING">Task was not called, but intentionally.</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">Task pointer was NULL or task was not valid.</errorcode>
<errorcode name="RTS_RESULT" type="ERR_FAILED">Program didn't finish load, or task-entry function pointer is not correctly relocated.</errorcode>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(Task_Desc* pTask, RTS_SYSTIME *ptNow)">IecTaskUpdateJitterTime</functionname>
<description> Calculate jitter time of task </description>
<param name="pTask" type="IN">Pointer to task description</param>
<param name="ptNow" type="IN">Pointer to actual microsecond time tick</param>
<result>Error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(Task_Desc* pTask, RTS_SYSTIME *ptActUs)">IecTaskUpdateCycleTime</functionname>
<description>Calculate cycle time of task.</description>
<param name="pTask" type="IN" range="[NULL,VALID_TASK]">Pointer to task description</param>
<param name="ptActUs" type="IN" range="[ACT_TIME]">Pointer to actual time tick in microseconds</param>
<parampseudo name="bIgnoreWatchdogInCycle" type="IN" range="[TRUE,FALSE]">Ignore watchdog in cycle</parampseudo>
<result>Error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION *pApp)">IecTasksResetAllowed</functionname>
<description> FUnction to check, if reset is allowed in the actual state on this application </description>
<param name="pApp" type="IN">Pointer to specified application</param>
<result>ERR_OK: Reset allowed, ERR_NOT_SUPPORTED: Not allowed (e.g. if one task is halted on a breakpoint)</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION *pApp, int bResetOrigin)">IecTasksPrepareReset</functionname>
<description> Prepare reset for all IEC tasks specified by application </description>
<param name="pApp" type="IN">Pointer to specified application</param>
<result>Error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION *pApp, int bResetOrigin)">IecTasksResetDone</functionname>
<description> Initialize all IEC tasks after reset specified by application </description>
<param name="pApp" type="IN">Pointer to specified application</param>
<result>Error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION *pApp, RTS_UI32 ulTimeoutMs, unsigned long ulStopReason)">IecTasksWaitForStop</functionname>
<description>Wait, if all Iec-Tasks has recognized the stop status of the application</description>
<param name="pApp" type="IN">Pointer to specified application</param>
<param name="ulTimeoutMs" type="IN">Timeout in milliseconds to wait for stop.
Some timeouts are predefined (see CmpStd.h):
<ul>
<li>RTS_TIMEOUT_INFINITE: Endless wait</li>
<li>RTS_TIMEOUT_DEFAULT: Use default wait time</li>
<li>RTS_TIMEOUT_NO_WAIT: No wait</li>
</ul>
</param>
<param name="ulStopReason" type="IN">Stop reason. See corresponding category in CmpAppItf.h</param>
<result>Error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION *pApp)">IecTaskInitOutputs</functionname>
<description>Init all outputs and write to the periphery.
NOTE: Application must be in stop before calling this function!</description>
<param name="pApp" type="IN">Pointer to specified application</param>
<result>Error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(void)">IecTaskEnterExclusiveSection</functionname>
<description>After this call no IEC task will be rescheduled, that is
if it is not already running. May be used for executing onlinechange code.
Each call must be matched with a call to TaskLeaveExclusiveSection.
</description>
<result>Error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(void)">IecTaskLeaveExclusiveSection</functionname>
<description>Leave an exclusiv section, that has been started by TaskEnterExclusiveSection</description>
<result>Error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION *pApp)">IecTaskEnterExclusiveSection2</functionname>
<description>Enter an exolusive section.
After this call, no IEC task will be rescheduled of the specified application, if it is not already running.
Each call must be matched with a call to TaskLeaveExclusiveSection.
</description>
<result>Error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION *pApp)">IecTaskLeaveExclusiveSection2</functionname>
<description>Leave an exclusive section of the specified application, that has been entered by TaskEnterExclusiveSection</description>
<result>Error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION *pApp, RTS_I32 nSlotNr, PF_SLOT_CALLBACK pfSlotCallback, int bIecCallback)">IecTaskRegisterSlotCallbacks</functionname>
<description>
<p>Register the given callback to all existing tasks of the application</p>
<p>On SIL2 Runtimes, this call is ignored in safety mode.</p>
</description>
<param name="pApp" type="IN" range="[NULL,VALID_APPLICATION]">Pointer to an application</param>
<param name="nSlotNr" type="IN" range="[RTS_RANGE_OF_INT]">Slotnumber</param>
<param name="pfSlotCallback" type="IN" range="[NULL,VALID_SLOTFUNCTION]">Pointer to Slot Callback</param>
<param name="bIecCallback" type="IN" range="[0,1]">Defines if the function pointer is an IEC or a C function</param>
<result>Error code</result>
<errorcode name="RTS_RESULT" type="ERR_OK">Registration was successfull</errorcode>
<errorcode name="RTS_RESULT" type="ERR_FAILED">Call was not allowed in this context or registration failed</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">Application- or function pointer was NULL</errorcode>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION *pApp, RTS_I32 nSlotNr, PF_SLOT_CALLBACK pfSlotCallback, int bIecCallback)">IecTaskUnregisterSlotCallbacks</functionname>
<description>
<p>Unregister the given callback from all existing tasks of the application</p>
<p>On SIL2 Runtimes, this call is ignored in safety mode.</p>
</description>
<param name="pApp" type="IN" range="[NULL,VALID_APPLICATION]">Pointer to an application</param>
<param name="nSlotNr" type="IN" range="[RTS_RANGE_OF_INT]">Slotnumber</param>
<param name="pfSlotCallback" type="IN" range="[NULL,VALID_SLOTFUNCTION]">Pointer to Slot Callback</param>
<param name="bIecCallback" type="IN" range="[0,1]">Defines if the function pointer is an IEC or a C function</param>
<result>Error code</result>
<errorcode name="RTS_RESULT" type="ERR_OK">Deregistration was successfull</errorcode>
<errorcode name="RTS_RESULT" type="ERR_FAILED">Call was not allowed in this context or deregistration failed</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">Application- or function pointer was NULL</errorcode>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(Task_Desc *pTask, RTS_I32 nSlotNr, PF_SLOT_CALLBACK pfSlotCallback, int bIecCallback)">IecTaskRegisterSlotCallback</functionname>
<description>
<p>Register the given callback to one specific IEC task.</p>
<p>On SIL2 Runtimes, this call throws an exception in safety mode.</p>
</description>
<parampseudo name="OperationMode" type="IN" range="[RTS_SIL2_OPMODE_SAFE,RTS_SIL2_OPMODE_DEBUG]">Operation mode</parampseudo>
<param name="pTask" type="IN" range="[NULL,VALID_TASK]">Handle IEC Task</param>
<param name="nSlotNr" type="IN" range="[RTS_RANGE_OF_INT]">Slotnumber</param>
<param name="pfSlotCallback" type="IN" range="[NULL,VALID_SLOTFUNCTION]">Pointer to Slot Callback</param>
<param name="bIecCallback" type="IN" range="[0,1]">Defines if the function pointer is an IEC or a C function</param>
<result>Error code</result>
<errorcode name="RTS_RESULT" type="ERR_OK">Registration was successfull</errorcode>
<errorcode name="RTS_RESULT" type="ERR_FAILED">Call was not allowed in this context or registration failed</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">Application- or function pointer was NULL</errorcode>
<errorcode name="RTS_RESULT" type="ERR_NOMEMORY">New slot could not be registered</errorcode>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(Task_Desc *pTask, RTS_I32 nSlotNr, PF_SLOT_CALLBACK pfSlotCallback, int bIecCallback)">IecTaskUnregisterSlotCallback</functionname>
<description>
<p>Unregister the given callback from the specific IEC task.</p>
<p>On SIL2 Runtimes, this call allows only IEC tasks in safety mode.</p>
</description>
<parampseudo name="OperationMode" type="IN" range="[RTS_SIL2_OPMODE_SAFE,RTS_SIL2_OPMODE_DEBUG]">Operation mode</parampseudo>
<param name="pTask" type="IN" range="[NULL,VALID_TASK]">Handle IEC Task</param>
<param name="nSlotNr" type="IN" range="[RTS_RANGE_OF_INT]">Slotnumber</param>
<param name="pfSlotCallback" type="IN" range="[NULL,VALID_SLOTFUNCTION]">Pointer to Slot Callback</param>
<param name="bIecCallback" type="IN" range="[0,1]">Defines if the function pointer is an IEC or a C function</param>
<result>Error code</result>
<errorcode name="RTS_RESULT" type="ERR_OK">Registration was successfull</errorcode>
<errorcode name="RTS_RESULT" type="ERR_FAILED">Call was not allowed in this context or deregistration failed</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">Application- or function pointer was NULL</errorcode>
</element>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(char *pszAppName, char *pszTaskName, RTS_RESULT *pResult)">IecTaskGetHandle</functionname>
<description>
<p>Get task, based on the application- and the task name.</p>
</description>
<param name="pszAppName" type="IN" range="[NULL,VALID_APPNAME,INVALID_APPNAME]">Pointer to application name</param>
<param name="pszTaskName" type="IN" range="[NULL,VALID_TASKNAME,INVALID_TASKNAME]">Pointer to task name</param>
<param name="pResult" type="OUT">Result of operation</param>
<errorcode name="pResult" type="ERR_OK">Task was found</errorcode>
<errorcode name="pResult" type="ERR_PARAMETER">Application- or task name where not valid</errorcode>
<errorcode name="pResult" type="ERR_FAILED">Application or task was not found</errorcode>
<result>Task handle</result>
</element>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(RTS_RESULT *pResult)">IecTaskGetCurrent</functionname>
<description>Is called to get the task description of the current running task</description>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Task handle</result>
</element>
<element function="1">
<functionname returntype="Task_Desc *" parameters="(APPLICATION* pApp, int iIndex, RTS_RESULT *pResult)">IecTaskGetByIndex</functionname>
<description>
<p>Get Task Description of a task by it's application ID
and it's task index.</p>
<p>Searches in the pool of all created tasks for the task,
with the given index in the specified application.</p>
</description>
<param name="pApp" type="IN" range="[NULL,VALID_APPLICATION]">Application object</param>
<parampseudo name="bTaskExists" type="IN" range="[FALSE,TRUE]">Defines whether the task exists or not</parampseudo>
<param name="iIndex" type="IN" range="[VALID_INDEX,INVALID_INDEX]">Index of task within the application</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Pointer to task description, NULL if failed</result>
<errorcode name="pResult" type="ERR_OK">Task was found and description returned</errorcode>
<errorcode name="pResult" type="ERR_NO_MEMORY">No task pool was found</errorcode>
<errorcode name="pResult" type="ERR_PARAMETER">Application pointer was NULL</errorcode>
</element>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(APPLICATION* pApp, int iIndex, RTS_RESULT *pResult)">IecTaskGetHandleByIndex</functionname>
<description>Returns task handle of the task specified by index in an application</description>
<param name="pApp" type="IN">APPLICATION object</param>
<param name="iIndex" type="IN">Index of task in the task list of the application</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Handle to the task or RTS_INVALID_HANDLE if failed</result>
</element>
<element function="1">
<functionname returntype="Task_Desc*" parameters="(APPLICATION* pappl, int iId, RTS_RESULT *pResult)">IecTaskGetById</functionname>
<description>Returns task handle of the task specified by its unique Id</description>
<param name="pApp" type="IN">APPLICATION object</param>
<param name="iId" type="IN">Unique Id of the task</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Handle to the task or RTS_INVALID_HANDLE if failed</result>
</element>
<element function="1">
<functionname returntype="int" parameters="(APPLICATION* pAppl, RTS_RESULT *pResult)">IecTaskGetNumOfTasks</functionname>
<description>Returns the number of tasks of the specified applciation</description>
<param name="pAppl" type="IN">APPLICATION object</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION *pApp)">IecTaskEnableSchedulingAll</functionname>
<description>
<p>Enable scheduling for all tasks of the specified application</p>
</description>
<param name="pApp" type="IN" range="[NULL,VALID_APPLICATION]">APPLICATION object</param>
<result>Error code</result>
<errorcode name="RTS_RESULT" type="ERR_OK">All tasks where enabled</errorcode>
<errorcode name="RTS_RESULT" type="ERR_FAILED">The scheduler returned an error when trying to start the application</errorcode>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION *pApp, RTS_HANDLE hIecTaskToExclude)">IecTaskDisableSchedulingAll</functionname>
<description>
<p>Disable scheduling for all tasks of the specified application except the specified task.
Typically this interface is used to disable all tasks except the debug task.
</p>
</description>
<param name="pApp" type="IN">APPLICATION object</param>
<param name="hIecTaskToExclude" type="IN" range="[RTS_INVALID_HANDLE,VALID_TASKHANDLE]">Handle of task to exclude from scheduling.
RTS_INVALID_HANDLE means, that all tasks are disabled</param>
<parampseudo name="s_hIecTaskPool" type="IN" range="[0,NUM_OF_STATIC_IEC_TASKS]">Number of already allocated tasks</parampseudo>
<parampseudo name="DisabledTasks" type="OUT" range="[WHICH_TAKS_ALL,WHICH_TASKS_ONE,WHICH_TASKS_NONE]">Defines, which tasks are disabled after this call</parampseudo>
<result>Error code</result>
</element>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(char *pszAppName, RTS_RESULT *pResult)">IecTaskGetFirst</functionname>
<description>Get the first IEC task in the specified application</description>
<param name="pszAppName" type="IN">Application name, to which the task is bound</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<errorcode name="pResult" type="ERR_OK">Task found</errorcode>
<errorcode name="pResult" type="ERR_NO_OBJECT">No task found</errorcode>
<errorcode name="pResult" type="ERR_PARAMETER">Application name was NULL</errorcode>
<result>Handle to the task or RTS_INVALID_HANDLE if failed</result>
</element>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(char *pszAppName, RTS_HANDLE hPrevIecTask, RTS_RESULT *pResult)">IecTaskGetNext</functionname>
<description>
<p>Get the successor of an IEC task.</p>
<p>Return the successor of an IEC task, based on an
application and a predecessor.</p>
</description>
<param name="pszAppName" type="IN" range="[VALID_APPNAME,INVALID_APPNAME]">Application name, to which the task is bound</param>
<param name="hPrevIecTask" type="IN" range="[RTS_INVALID_HANDLE,VALID_TASKHANDLE]">Handle to previous task provided by IecTaskGetFirst()</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<errorcode name="pResult" type="ERR_OK">Task found</errorcode>
<errorcode name="pResult" type="ERR_NO_OBJECT">No task found</errorcode>
<errorcode name="pResult" type="ERR_PARAMETER">Application name was NULL, or handle to prev task was invalid</errorcode>
<errorcode name="pResult" type="ERR_NOTINITIALIZED">The component was not correctly initialized</errorcode>
<result>Handle to the task or RTS_INVALID_HANDLE if failed</result>
</element>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(APPLICATION *pApp, RTS_RESULT *pResult)">IecTaskGetFirst2</functionname>
<description>
<p>Get the first IEC task of the specified application</p>
</description>
<param name="pApp" type="IN" range="[NULL,VALID_APPLICATION]">Handle of the application that contains the task</param>
<parampseudo name="bTaskExists" type="IN" range="[FALSE,TRUE]">Defines whether the task exists or not</parampseudo>
<param name="pResult" type="OUT">Pointer to error code</param>
<errorcode name="pResult" type="ERR_OK">Task found</errorcode>
<errorcode name="pResult" type="ERR_NO_OBJECT">No task found</errorcode>
<errorcode name="pResult" type="ERR_PARAMETER">Application pointer was NULL</errorcode>
<errorcode name="pResult" type="ERR_NOTINITIALIZED">Component was not initialized</errorcode>
<result>Handle to the task or RTS_INVALID_HANDLE if failed</result>
</element>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(APPLICATION *pApp, RTS_HANDLE hPrevIecTask, RTS_RESULT *pResult)">IecTaskGetNext2</functionname>
<description>
<p>Get the successor of an IEC task.</p>
<p>Return the successor of an IEC task, based on an
application and a predecessor.</p>
</description>
<param name="pApp" type="IN" range="[NULL,VALID_APPLICATION]">Handle of the application that contains the task</param>
<param name="hPrevIecTask" type="IN" range="[RTS_INVALID_HANDLE,VALID_TASKHANDLE]">Handle to previous task provided by IecTaskGetFirst2()</param>
<parampseudo name="bSuccessorExists" type="IN" range="[FALSE,TRUE]">Defines if a successor to hPrevIecTask exists or not.</parampseudo>
<param name="pResult" type="OUT">Pointer to error code</param>
<errorcode name="pResult" type="ERR_OK">Task found</errorcode>
<errorcode name="pResult" type="ERR_NO_OBJECT">No task found</errorcode>
<errorcode name="pResult" type="ERR_PARAMETER">Application name was NULL, or handle to prev task was invalid</errorcode>
<errorcode name="pResult" type="ERR_NOTINITIALIZED">The component was not correctly initialized</errorcode>
<result>Handle to the task or RTS_INVALID_HANDLE if failed</result>
</element>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(RTS_HANDLE hIecTask, RTS_UI32 ulTimeoutMs, RTS_RESULT *pResult)">IecTaskReload</functionname>
<description>Reload a specified IEC task. Reload means here: Delete the task at the actual position and create it newly.</description>
<param name="hIecTask" type="IN">Handle to the task to reload</param>
<param name="ulTimeoutMs" type="IN">Timeout in milliseconds to wait, until the task deleted itself. Timeout can be one of the following predefined values:
RTS_TIMEOUT_DEFAULT: Default timeout to delete the task
RTS_TIMEOUT_NO_WAIT: Immediate deletion of the task</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Handle to the new created task </result>
</element>
<element function="1">
<functionname returntype="int" parameters="(APPLICATION *pApp, int iIndex, RTS_RESULT *pResult)">IecTaskCalculateId</functionname>
<description>
<p>Calculate a task ID based on an application index and a task index.</p>
<p>This ID corresponds directly to the IDs that are used in the CoDeSys
programming system to identify a task.</p>
<p>The valid range of iIndex depends on the cpu. The limit is always
the square route of UINT_MAX, because the upper half of the datatype
is used for the application ID, and the lower half for the task index.</p>
</description>
<param name="pApp" type="IN" range="[NULL,VALID_APPLICATION]">Pointer to the application of the task.</param>
<parampseudo name="pApp.iId" type="IN" range="[-1,0..MAX_APPINDEX,MAX_APPINDEX+1..INT_MAX]">Application ID.</parampseudo>
<param name="iIndex" type="IN" range="[-1,0..MAX_TASKINDEX,MAX_TASKINDEX+1..INT_MAX]">Index of the task within it's application</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Unique Id of the task</result>
<errorcode name="pResult" type="ERR_OK">The ID was successfully calculated</errorcode>
<errorcode name="pResult" type="ERR_PARAMETER">Application pointer was null or IDs where out of range</errorcode>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION *pApp, RTS_UI32 ulTimeoutMs)">IecTaskWaitTasksActive</functionname>
<description>Function to make a busy wait, while at least one task of the specified application is active</description>
<param name="pApp" type="IN">Handle of the application that contains the tasks to check. If pApp == NULL, all IEC tasks are checked.</param>
<param name="ulTimeoutMs" type="IN">Timeout in milliseconds to wait for deleting the task</param>
<result>Error code:</result>
<errorcode name="RTS_RESULT" type="ERR_OK">No task is active</errorcode>
<errorcode name="RTS_RESULT" type="ERR_FAILED">At least one task is active after timeout</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">Application name was NULL</errorcode>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION *pApp)">IecTaskSingleCycle</functionname>
<description>Activates a single cycle on every cyclic and freewheeling task of the specified application</description>
<param name="pApp" type="IN">Handle of the application to do a single cycle</param>
<result>Error code</result>
<errorcode name="RTS_RESULT" type="ERR_OK">No task is active</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">Application name was NULL</errorcode>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hIecTask)">IecTaskResetStatistics</functionname>
<description>Reset the task statistics of a task (see Task_Info member e.g. dwCycleTime, dwAverageCycleTime, etc.)</description>
<param name="hIecTask" type="IN">Handle to the task</param>
<result>Error code</result>
<errorcode name="RTS_RESULT" type="ERR_OK">No task is active</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">Application name was NULL</errorcode>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hIecTask)">IecTaskDelete</functionname>
<description> Delete an IEC task </description>
<param name="hIecTask" type="IN">Handle to task</param>
<result>Error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hIecTask, RTS_UI32 ulTimeoutMs)">IecTaskDelete2</functionname>
<description> Delete an IEC task with timeout </description>
<param name="ulTimeoutMs" type="IN">Timeout in milliseconds to wait for deleting the task
Some timeouts are predefined (see CmpStd.h):
<ul>
<li>RTS_TIMEOUT_DEFAULT: Use default wait time</li>
<li>RTS_TIMEOUT_NO_WAIT: No wait</li>
</ul>
</param>
<result>Error code</result>
</element>
</element>
</component>
<component>
<name>CmpIoDrvIec</name>
<description>
<p>Wrapper component for an IEC driver</p>
<p>Every IEC driver is encapsulated by this wrapper, because
calling the IEC functions must be done with
SysCpuCallIecFuncWithParams().</p>
<p>The IoMgr uses the wrapper interface. And internally the
wrapper calls the FB interface methods.</p>
<pre>
o- IoDrvIec:
Base.hInstance -> pIIoDrvIec

o- IoDrvFB:
hInterface -> pIBase
BaseIec.hInstance -> pFBInstance
</pre>

</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element interface="1" name="CmpIoDrvIecItf">
<interfacename>CmpIoDrvIec</interfacename>
<description>
<p>Wrapper to access the interface functions of an IEC driver from C.</p>
<p>The registration of a new IEC driver instance is going like this:</p>
<pre>
.   +--------------+   +--------+   +-----------+
.   |IEC Driver Lib|   |CmpIoMgr|   |CmpIoDrvIec|
.   +--------------+   +--------+   +-----------+
.          |               |              |
.         +-+ Register     |              |
.         | |   Instance   |              |
.         | |-------------+-+ Register    |
.         | |             | |   Instance  |
.         | |             | |------------+-+
.         | |             | |            | |
.         | |             | |            | |
.         | |             |+++-----------| |
.         | |             || |           | |
.         | |             || |           | |
.         | |             || |           | |
.         | |             || |           | |
.         | |             |+++...........| |
.         | |             | |            | |
.         | |             | |            | |
.         | |             | |............+-+
.         | |.............+-+
.         +-+
</pre>
<p>The handle of the I/O driver wrapper looks like this:</p>
<pre>
.                +------------------------+
.                |CCmpIoDrvIec            |
.                +------------------------+
.                |hInstance               | ----.
.                +------------------------+     |
.              . |IoDrvGetInfo            |     |
.             /  |IoDrvGetModuleDiagnosis |     |
.            /   |IoDrvIdentify           |     |
.            |   |IoDrvReadInputs         |     |
. C-Wrapper -'   |IoDrvScanModules        |     |
.            |   |IoDrvStartBusCycle      |     |
.            |   |IoDrvUpdateConfiguration|     |     +-------------+
.            \   |IoDrvUpdateMapping      |     '---- |I/O Drv FB   |
.             \  |IoDrvWatchdogTrigger    |           +-------------+
.              ' |IoDrvWriteOutputs       |           |ITF_ICmpIoDrv|
.                +------------------------+           +-------------+
.                |IoDrvGetInfo            | .         |pvftable[4]  |
.                |IoDrvGetModuleDiagnosis |  \        |pvftable[5]  |
.                |IoDrvIdentify           |   \       |pvftable[6]  |
.                |IoDrvReadInputs         |   |       |pvftable[7]  |
.                |IoDrvScanModules        |   '------ |pvftable[8]  |
.                |IoDrvStartBusCycle      |   |       |pvftable[9]  |
.                |IoDrvUpdateConfiguration|   |       |pvftable[10] |
.                |IoDrvUpdateMapping      |   /       |pvftable[11] |
.                |IoDrvWatchdogTrigger    |  /        |pvftable[12] |
.                |IoDrvWriteOutputs       | '         |pvftable[13] |
.                +------------------------+           +-------------+
</pre>
<p>The main difference between the registration with IoDrvRegisterInstance()
vs. IoDrvRegisterInstance2() is, that the first one was initializing all IEC
function pointers by itself and the second is using BaseUpdateConfiguration()
for this purpose. IoDrvRegisterInstance is now depricated.</p>
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(iodrviecregisterinstance_struct *p)">IoDrvRegisterInstance</functionname>
<description>
<p>Obsolete! This interface is not used anymore.</p>
<p>Note: On SIL2 Runtimes, this call leads to an exception.</p>
</description>
<result>Error code</result>
<errorcode name="RTS_RESULT" type="ERR_NOTIMEPLEMENTED">The function is obsolete and not available anymore</errorcode>
<errorcode name="RTS_RESULT" type="ERR_FAILED">The function was called in a SIL2 runtime and the exception handling returned</errorcode>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(iodrviecregisterinstance2_struct *p)">IoDrvRegisterInstance2</functionname>
<description>
<p>Register an IEC I/O driver.</p>
<p>A call to this function creates a new instance of the CmpIoDrvIec
component, which acts as a wrapper for the registered IEC I/O driver.
It will, by itself, call IoMgrRegisterInstance2() to register the
newly created C-Wrapper Interface at the I/O Manager.
</p>
</description>
<param name="p" type="IN" range="[VALID_REGISTERINSTANCE_PARAMETER]">IEC Parameter structure</param>
<parampseudo name="p.pInterface" type="IN" range="[NULL,VALID_INTERFACE]">IEC Interface Pointer</parampseudo>
<parampseudo name="p.pInterface" type="IN" range="[NULL,VALID_INTERFACE]">IEC Interface Pointer</parampseudo>
<result>Error code</result>
<errorcode name="RTS_RESULT" type="ERR_OK">Registration was successfull</errorcode>
<errorcode name="RTS_RESULT" type="ERR_NOMEMORY">Not enough memory to create a new instance</errorcode>
<errorcode name="RTS_RESULT" type="ERR_FAILED">No valid Interface</errorcode>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(iodrviecunregisterinstance_struct *p)">IoDrvUnregisterInstance</functionname>
<description>
<p>Unregister an IEC I/O driver.</p>
<p>Delete a driver instance and unregister it from the I/O Manager.</p>
<p>Note: On SIL2 runtimes, this function is only allowed in debug mode.
When it is called outside of the debug mode, it will throw an exception.</p>
</description>
<param name="p" type="IN" range="[VALID_UNREGISTERINSTANCE_PARAMETER]">IEC Parameter structure</param>
<parampseudo name="p.hInterface" type="IN" range="[RTS_INVALID_HANDLE,NULL,VALID_INTERFACE_HANDLE]">IEC Interface Pointer</parampseudo>
<parampseudo name="OperationMode" type="IN" range="[RTS_SIL2_OPMODE_SAFE,RTS_SIL2_OPMODE_DEBUG]">Operation mode</parampseudo>
<parampseudo name="bExceptionGenerated" type="OUT" range="[TRUE,FALSE]">Indicates, if an exception was thrown or not</parampseudo>
<result>Error code</result>
<errorcode name="RTS_RESULT" type="ERR_OK">Deregistration was successfull</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">pIBase was NULL</errorcode>
<errorcode name="RTS_RESULT" type="*">Internal error when trying to free the driver handle</errorcode>
</element>
<element function="1">
<functionname returntype="IBase*" parameters="(RTS_HANDLE hIoDrv, RTS_RESULT *pResult)">IoDrvGetIecInterface</functionname>
<description>
<p>Get an IEC I/O driver interface pointer, based on a handle
to it's corresponding C-Wrapper.</p>
</description>
<param name="hIoDrv" type="IN" range="[RTS_INVALID_HANDLE,NULL,VALID_IODRIVER]">Handle of a C-Wrapper</param>
<param name="Result" type="OUT">Result of the function</param>
<result>Pointer to the IEC base interface</result>
<errorcode name="RTS_RESULT" type="ERR_OK">Interface returned successfully</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">hIoDrv was NULL or invalid</errorcode>
</element>
</element>
<element interface="1" name="CmpIoDrvItf">
<interfacename>CmpIoDrv</interfacename>
<description>
<p>Standard IO-driver interface.</p>
<p>THis interface is used for I/O drivers written in C as well as I/O
drivers written in IEC. IEC I/O drivers are typically written as a function
block, which implementes the IIoDrv Interface.</p>
<p>To be able to access this IEC interface from C (which is for example
necessary for the IoMgr), the component CmpIoDrvIec acts as a wrapper
between C and IEC and implements exactly this interface.</p>
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element define="1">
<name>CT_PROGRAMMABLE</name>
<key>0x1000</key>
<category>Connector types</category>
<description>
<p>These are the connector types which are used most frequently. This list
is not complete.</p>
</description>
<element name="CT_PROGRAMMABLE">Programmable connector (can be programmed by CoDeSys)</element>
<element name="CT_PARAMETRIZABLE">Connector is only parametrizable</element>
<element name="CT_CAN_MASTER">CAN Master</element>
<element name="CT_CAN_SLAVE">CAN Slave</element>
<element name="CT_CAN_DEVICE">CAN Device</element>
<element name="CT_CANOPEN_SAFETY">Safety Master and Slave</element>
<element name="CT_J1939_MANAGER">J1939 Manager</element>
<element name="CT_J1939_ECU">J1939 ECU</element>
<element name="CT_PROFIBUS_MASTER">Profibus Master</element>
<element name="CT_PROFIBUS_SLAVE">Profibus Slave</element>
<element name="CT_PROFIBUS_DEVICE">Profibus Device</element>
<element name="CT_PROFIBUS_MOD_MASTER">Profibus modular Master</element>
<element name="CT_PROFIBUS_MOD_SLAVE">Profibus modular Slave</element>
<element name="CT_DEVICENET_MASTER">Profibus DeviceNet Master</element>
<element name="CT_DEVICENET_SLAVE">Profibus DeviceNet Slave</element>
<element name="CT_DEVICENET_DEVICE">Profibus DeviceNet Device</element>
<element name="CT_ETHERCAT_MASTER">EtherCAT Master</element>
<element name="CT_ETHERCAT_SLAVE">EtherCAT Slave</element>
<element name="CT_ETHERCAT_DEVICE">EtherCAT Device</element>
<element name="CT_SIL2_UNSAFE_BRIDGE_MASTER">IoDrvUnsafeBridge Master</element>
<element name="CT_SIL2_UNSAFE_BRIDGE_SLAVE">IoDrvUnsafeBridge Slave</element>
<element name="CT_PCI_MASTER">PCI Master</element>
<element name="CT_PCI_SLAVE">PCI Slave</element>
<element name="0x8000..0x8FFF">Special Connectors</element>
</element>
<element define="1">
<name>CF_ENABLE</name>
<key>0x0001</key>
<category>Connector flags</category>
<description>
Flags that specifies diagnostic informations of a connector
</description>
<element name="CF_ENABLE">Connector enabled</element>
<element name="CF_CONNECTOR_FOUND">Connector found (device detected)</element>
<element name="CF_CONNECTOR_CONFIGURED">Connector configured</element>
<element name="CF_CONNECTOR_ACTIVE">Connector active</element>
<element name="CF_CONNECTOR_BUS_ERROR">Bus error</element>
<element name="CF_CONNECTOR_ERROR">General connector error</element>
<element name="CF_CONNECTOR_DIAGNOSTIC_AVAILABLE">Diagnostic information available</element>
<element name="CF_CONNECTOR_PASSIVE">Passive mode of the second master in redundancy systems</element>
</element>
<element define="1">
<name>CO_NONE</name>
<key>0x0000</key>
<category>Connector options</category>
<description>
Options to specify properties of a connector
</description>
<element name="CO_SCAN_PENDING_SUPPORTED">Scan the IO-configuration with segmented transfer is supported. In this case, the call of IoDrvScanModules()
can return ERR_PENDING to get further calls to transmit more scan results.
</element>
</element>
<element define="1">
<name>PVF_FUNCTION</name>
<key>0x0001</key>
<category>Parameter value flags</category>
<description>
<p>Defines the type of the parameter</p>
<p>Actually only PVF_POINTER is currently supported by CoDeSys</p>
</description>
<element name="PVF_FUNCTION">Functional access to the parameter, Value is a function pointer.</element>
<element name="PVF_POINTER">Value is a pointer to the value</element>
<element name="PVF_VALUE">Obsolete: NOT USED. Value can be interpreted directly as a value (max. 32 Bit datatypes)</element>
<element name="PVF_READ">Parameter can be read</element>
<element name="PVF_WRITE">Parameter can be written</element>
</element>
<element define="1">
<name>FIP_NETX_DEVICE</name>
<key>0x70000000</key>
<category>Fieldbus independent parameters</category>
<description>
</description>
<element name="FIP_NETX_DEVICE">Parameter to identify netX devices.</element>
<element name="FIP_WATCHDOG">Master Watchdog time</element>
</element>
<element define="1">
<name>TMT_INPUTS</name>
<key>0x0001</key>
<category>Task map types</category>
<description>
<p>Types of IO-channels in a task map</p>
</description>
<element name="TMT_INPUTS">Input connector maps</element>
<element name="TMT_OUTPUTS">Output connector maps</element>
</element>
<element define="1">
<name>DRVPROP_CONSISTENCY</name>
<key>0x0001</key>
<category>Driver property flags</category>
<description>
</description>
<element name="DRVPROP_CONSISTENCY">
The io driver realizes bit-consistency by its own (atomar bit access).
If this flag is 0, the I/O Manager takes care about the consistency.
</element>
<element name="DRVPROP_WATCHTDOG">
The io driver needs a cyclic call to the IoDrvWatchdogTrigger interface
function. This property is deprecated.
</element>
<element name="DRVPROP_REDUNDANCY">
The I/O driver is running in redundancy mode (passive)
</element>
<element name="DRVPROP_ACTIVE">
The I/O driver is running in redundancy mode (active).
</element>
<element name="DRVPROP_ERROR_ACTIVE">
Inform the 3S redundancy Manager about an error of an active driver. This
will lead to a switch between active and passive PLC.
</element>
<element name="DRVPROP_ERROR_PASSIVE">
Inform the 3S redundancy Manager about an error of a passive driver.
</element>
<element name="DRVPROP_BACKGROUND_GETDIAG">
If this property is set, the interface function IoDrvGetModuleDiagnosis() of the driver is called cyclically from a background task.
NOTE:
In this case, IoDrvGetModuleDiagnosis is called with:	IoDrvGetModuleDiagnosis(hIoDrv, NULL);
This must be handled correctly in the IO-driver!
</element>
</element>
<element define="1">
<name>CMLSI_BaseTypeMask</name>
<key>0x00FF</key>
<category>Channel Map List Swapping Information</category>
<description>
<p>Every Io driver needs information on the base data type of an io channel
to perform a correct swapping operation.The basedata type and some
additional swapping information can be found in the wDummy Byte of the
ChannelMapList struct.</p>
</description>
<element name="CMLSI_BaseTypeMask">
This is the mask of the base type information
</element>
<element name="CMLSI_BaseDataTypeIsSet">
If this bit is set, the low byte of the wDummy word contains the base type
information. The base type is of type TypClass3 of component SysInternalLib.
</element>
<element name="CMLSI_SwappingEnabled">
If this bit is set, the driver has to determine, if the io channel must be
swapped.
</element>
</element>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(RTS_HANDLE hIIoDrv, CLASSID ClassId, int iId, RTS_RESULT *pResult)">IoDrvCreate</functionname>
<description>
<p>Create a new I/O driver instance.</p>
<p>This function is obsolete, because the instance has to be created
by the caller before he registers the I/O driver in the I/O Manager.</p>
</description>
<param name="hIIoDrv" type="IN">Handle to the IO-driver interface. Must be 0 and is filled automatically by calling the CAL_IoDrvCreate() macro!</param>
<param name="ClassId" type="IN">ClassID of the driver. See "Class IDs" section in CmpItf.h or in the Dep.h file of the IO-driver.</param>
<param name="iId" type="IN">Instance number of the IO-driver</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Should return RTS_INVALID_HANDLE</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hIoDrv, IoDrvInfo **ppIoDrv)">IoDrvGetInfo</functionname>
<description>
<p>Get a driver specific info structure.</p>
<p>This structure contains IDs and names of the driver.</p>
</description>
<param name="hIoDrv" type="IN" range="[RTS_INVALID_HANDLE,VALID_IODRIVER]">Handle to the IO-driver instance</param>
<param name="ppIoDrv" type="OUT" range="[NULL,VALID_IODRVIERINFO]">Pointer to pointer to the driver info. Pointer must be set by the driver to its internal driver info structure!</param>
<result>Error code</result>
<errorcode name="RTS_RESULT" type="ERR_OK">The info structure was returned successfully</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">hIoDrv was invalid or ppIoDrv was NULL</errorcode>
<errorcode name="RTS_RESULT" type="ERR_FAILED">Internal Error</errorcode>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hIoDrv, IoConfigConnector *pConnector)">IoDrvGetModuleDiagnosis</functionname>
<description>
<p>Update Connector Flags in the device tree.</p>
<p>The driver should write the current diagnostic information (available, no driver,
bus error,...) with the function IoDrvSetModuleDiagnosis() to the I/O connector.</p>
<p>This function can be used by other components or from the IEC application to
update the diagnostic flags of the connector. To update the status from the
driver, it has to call this function manually.</p>
</description>
<param name="hIoDrv" type="IN">Handle to the IO-driver instance</param>
<param name="pConnector" type="IN">Pointer to the connector, that the diagostic information is requested</param>
<result>Error code</result>
<errorcode name="RTS_RESULT" type="ERR_OK"></errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">...</errorcode>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hIoDrv, IoConfigConnector *pConnector)">IoDrvIdentify</functionname>
<description>
<p>Identify plugable I/O card or slave.</p>
<p>If the configurator supports scanning of modules, this
function can be used our of a communication service to
identify a module on the bus or locally on the PLC. This
This might be done by a blinking LED or whatever the hardware
supports.</p>
</description>
<param name="hIoDrv" type="IN">Handle to the IO-driver instance</param>
<param name="pConnector" type="IN">Pointer to the connector, that should identify itself physically</param>
<result>Error code</result>
<errorcode name="RTS_RESULT" type="ERR_OK">Identification was sent</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">hIoDrv was invalid or pConnector was NULL</errorcode>
<errorcode name="RTS_RESULT" type="ERR_FAILED">Service not enabled (e.g. bus not connected)</errorcode>
<errorcode name="RTS_RESULT" type="ERR_NOTIMPLEMENTED">Not provided by the driver</errorcode>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hIoDrv, IoConfigConnectorMap *pConnectorMapList, int nCount)">IoDrvReadInputs</functionname>
<description>
<p>Read inputs for one task</p>
<p>This function is called cyclically from every task
that is using inputs. A part of the task map list,
which contains only the data of one connector are passed
to the driver (called connector map list).</p>
<p>If a driver has registered one instance to more
than one connector, it might get more than one call with
a different subset of the task map list.</p>
<p>The I/O driver should read the data from the local
hardware or a buffer and write them to the corresponding
IEC variables.</p>
</description>
<param name="hIoDrv" type="IN">Handle to the IO-driver instance</param>
<param name="pConnectorMapList" type="IN">Pointer to the connector map list</param>
<param name="nCount" type="IN">Number of entries in the connector map list</param>
<result>Error code</result>
<errorcode name="RTS_RESULT" type="ERR_OK">ReadInputs was executed successfully.</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">hIoDrv was invalid or pConnectorList was NULL.</errorcode>
<errorcode name="RTS_RESULT" type="ERR_FAILED">Internal error</errorcode>
<errorcode name="RTS_RESULT" type="ERR_LICENSE_MISSING">No License</errorcode>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hIoDrv, IoConfigConnector *pConnector, IoConfigConnector **ppConnectorList, int *pnCount)">IoDrvScanModules</functionname>
<description>
<p>Scan for submodules of a connector.</p>
<p>This function is executed when the driver is downloaded. It
is called over a communication service.</p>
<p>The I/O driver should search for connected subumodules and
return them via ppConnectorList.</p>
<p>NOTE: This interface is called synchronously and the buffer for
the connector list has to be allocated by the driver.</p>
<p>The buffer might be freed at the next scan or at the next
UpdateConfiguration.</p>
</description>
<param name="hIoDrv" type="IN">Handle to the IO-driver instance</param>
<param name="pConnector" type="IN">Pointer to the connector, which layout should be scanned</param>
<param name="ppConnectorList" type="IN">Pointer to the scanned connectors (devices) to return</param>
<param name="pnCount" type="IN">Pointer to the number of entries in the connector list to return</param>
<result>Error code</result>
<errorcode name="RTS_RESULT" type="ERR_OK">Scan for modules finished</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">hIoDrv was invalid, pConnector, ppConnectorList or pnCount was NULL</errorcode>
<errorcode name="RTS_RESULT" type="ERR_FAILED">Internal error</errorcode>
<errorcode name="RTS_RESULT" type="ERR_NOTIMPLEMENTED">Scan feature is not implemented</errorcode>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hIoDrv, IoConfigConnector *pConnector)">IoDrvStartBusCycle</functionname>
<description>
<p>Start bus cycle for a specific connector.</p>
<p>The bus cycle task is defined globally for the whole PLC
or locally for a specific I/O connector in the CoDeSys project.
This call can be used by the I/O driver to flush the I/O data
if it was cached before.</p>
<p>This way we can get a better and consistent timing on the bus.</p>d
<p>Note: This function is called for every connector which has a
registered I/O driver and "needsbuscycle" set in the device description
(this means that it might also be called for children of the connector).</p>
<p>Depending on the device description, this function might be executed
at the beginning or at the end of the task cycle.</p>
</description>
<param name="hIoDrv" type="IN">Handle to the IO-driver instance</param>
<param name="pConnector" type="IN">Pointer to the connector, on which the buscycle must be triggered</param>
<result>Error code</result>
<errorcode name="RTS_RESULT" type="ERR_OK">Bus cycle was triggered</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">hIoDrv was invalid or pConnector NULL</errorcode>
<errorcode name="RTS_RESULT" type="ERR_FAILED">Internal Error</errorcode>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hIoDrv, IoConfigConnector *pConnectorList, int nCount)">IoDrvUpdateConfiguration</functionname>
<description>
<p>Propagate I/O configuration to the drivers.</p>
<p>This call passes the I/O configuration (based on the
configuration tree in the CoDeSys programming system) to
all registered I/O drivers. Every driver has the chance
to pass this tree and to register itself for a specific
connector.</p>
<p>The driver can use the I/O Manager Interface to iterate
over the I/O Connectors and to read the I/O Parameters.
If it decides to handle the I/Os of one of those connectors,
it can register it's driver handle (IBase) to the connector
in the member hIoDrv.</p>
<p>This function is called when the application is initialized
as well as when it is de- or reinitialized. In this case it is
called with pConnectorList = NULL.</p>
</description>
<param name="hIoDrv" type="IN">Handle to the IO-driver instance</param>
<param name="pConnectorList" type="IN">Pointer to the complete connector list</param>
<param name="nCount" type="IN">Number of entries in the connector list</param>
<result>Error code</result>
<errorcode name="RTS_RESULT" type="ERR_OK">UpdateConfiguration was successfull and found a driver</errorcode>
<errorcode name="RTS_RESULT" type="ERR_NO_OBJECT">No connector for this driver was found</errorcode>
<errorcode name="RTS_RESULT" type="ERR_NO_LICENSE">No license for this driver</errorcode>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hIoDrv, IoConfigTaskMap *pTaskMapList, int nCount)">IoDrvUpdateMapping</functionname>
<description>
<p>Propagate the task map lists to the drivers.</p>
<p>This functions gives the drivers a chance to optimize
their internal data structures based on the real task map
lists. The function is called on every initialization
of the application (download, bootproject,...).</p>
</description>
<param name="hIoDrv" type="IN">Handle to the IO-driver instance</param>
<param name="pTaskMapList" type="IN">Pointer to the task map list of one task</param>
<param name="nCount" type="IN">Number of entries in the map list</param>
<result>Error code</result>
<errorcode name="RTS_RESULT" type="ERR_OK">Default Result (mappings reorganized or nothing changed)</errorcode>
<errorcode name="RTS_RESULT" type="ERR_NOTIMPLEMENTED">UpdateMapping is not implemented</errorcode>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hIoDrv, IoConfigConnector *pConnector)">IoDrvWatchdogTrigger</functionname>
<description>
<p>Trigger the hardware watchdog of a driver.</p>
<p>This function is depricated and not used anymore.</p>
</description>
<param name="hIoDrv" type="IN">Handle to the IO-driver instance</param>
<param name="pConnector" type="IN">Pointer to the connector, on which the watchdog should be retriggered</param>
<result>Should return ERR_NOTIMPLEMENTED</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hIoDrv, IoConfigConnectorMap *pConnectorMapList, int nCount)">IoDrvWriteOutputs</functionname>
<description>
<p>Write outputs for one task</p>
<p>This function is called cyclically from every task
that is using outputs. A part of the task map list,
which contains only the data of one connector are passed
to the driver (called connector map list).</p>
<p>If a driver has registered one instance to more
than one connector, it might get more than one call with
a different subset of the task map list.</p>
<p>The I/O driver should write out the data to the local
hardware, a buffer or a fieldbus.</p>
</description>
<param name="hIoDrv" type="IN">Handle to the IO-driver instance</param>
<param name="pConnectorMapList" type="IN">Pointer to the connector map list</param>
<param name="nCount" type="IN">Number of entries in the connector map list</param>
<result>Error code</result>
<errorcode name="RTS_RESULT" type="ERR_OK">Outputs successfully written</errorcode>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hIoDrv, RTS_HANDLE hIIoDrv)">IoDrvDelete</functionname>
<description>
<p>Delete an I/O driver instance.</p>
<p>This function is obsolete, because the instance has to be deleted
by the caller after he unregisters the I/O driver from the I/O Manager.</p>
</description>
<description>Delete an IO-driver instance</description>
<param name="hIoDrv" type="IN">Handle to the IO-driver instance</param>
<param name="hIIoDrv" type="IN">Handle of the ITFID_ICmpIoDrv interface</param>
<result>Should return ERR_NOTIMPLEMENTED</result>
</element>
</element>
<element interface="1" name="CmpIoDrvParameterItf">
<interfacename>CmpIoDrvParameter</interfacename>
<description>
Interface to access parameters of an IO-driver.
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hDevice, IoConfigConnector *pConnector, IoConfigParameter *pParameter, void *pData, RTS_SIZE ulBitSize, RTS_SIZE ulBitOffset)">IoDrvReadParameter</functionname>
<description>
<p>Read a driver specific parameters.</p>
<p>These parameters can be read by the application, as
well as, by an online service, which is triggered from
the device configurator plugin in the CoDeSys programming
system.</p>
<p>Note: If the I/O driver returns an error, the I/O
Manager may try to read the parameter himself</p>
<p>Note2: On SIL2 runtimes, this interface is not supported.</p>
</description>
<param name="hDevice" type="IN" range="[RTS_INVALID_HANDLE,VALID_IODRIVER]">Handle to the IO-driver instance</param>
<param name="pConnector" type="IN" range="[NULL,VALID_CONNECTOR]">Pointer to the connector (might be determined with IoMgrConfigGetConnector).</param>
<param name="pParameter" type="IN" range="[NULL,VALID_PARAMETER]">Pointer to the parameter (might be determined with IoMgrConfigGetParameter)</param>
<param name="pData" type="IN" range="[NULL,VALID_DATABUFFER]">Buffer where the read data is stored</param>
<param name="ulBitSize" type="IN" range="[0..PARAM_SIZE-1]">Size of the part of the parameter data, that should be read</param>
<param name="ulBitOffset" type="IN" range="[0..PARAM_SIZE-1]">Offset of the part of the parameter, that should be read</param>
<parampseudo name="OperationMode" type="IN" range="[RTS_SIL2_OPMODE_SAFE,RTS_SIL2_OPMODE_DEBUG]">Operation mode</parampseudo>
<parampseudo name="bExceptionGenerated" type="OUT" range="[TRUE,FALSE]">Indicates, if an exception was thrown or not</parampseudo>
<result>Error code</result>
<errorcode name="RTS_RESULT" type="ERR_OK">Parameter was retrieved</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">hDevice was invalid, or pConnector, pConfigParameter or pData was NULL.</errorcode>
<errorcode name="RTS_RESULT" type="ERR_FAILED">Parameter is not handled by the driver</errorcode>
<errorcode name="RTS_RESULT" type="ERR_NOT_SUPPORTED">This feature is not supported by the driver, or the I/O Manager</errorcode>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hDevice, IoConfigConnector *pConnector, IoConfigParameter *pParameter, void *pData, RTS_SIZE ulBitSize, RTS_SIZE ulBitOffset)">IoDrvWriteParameter</functionname>
<description>
<p>Write a driver specific parameters.</p>
<p>These parameters can be written by the application, as
well as, by an online service, which is triggered from
the device configurator plugin in the CoDeSys programming
system.</p>
<p>Note: On SIL2 runtimes, this interface is not supported. And if called in safe-mode,
on SIL2 Runtimes, an exception is generated.</p>
</description>
<param name="hDevice" type="IN" range="[RTS_INVALID_HANDLE,VALID_IODRIVER]">Handle to the IO-driver instance</param>
<param name="pConnector" type="IN" range="[NULL,VALID_CONNECTOR]">Pointer to the connector (might be determined with IoMgrConfigGetConnector).</param>
<param name="pParameter" type="IN" range="[NULL,VALID_PARAMETER]">Pointer to the parameter (might be determined with IoMgrConfigGetParameter)</param>
<param name="pData" type="IN" range="[NULL,VALID_DATABUFFER]">Buffer where the read data is stored</param>
<param name="ulBitSize" type="IN" range="[0..PARAM_SIZE-1]">Size of the part of the parameter data, that should be written</param>
<param name="ulBitOffset" type="IN" range="[0..PARAM_SIZE-1]">Offset of the part of the parameter, that should be written</param>
<parampseudo name="OperationMode" type="IN" range="[RTS_SIL2_OPMODE_SAFE,RTS_SIL2_OPMODE_DEBUG]">Operation mode</parampseudo>
<parampseudo name="bExceptionGenerated" type="OUT" range="[TRUE,FALSE]">Indicates, if an exception was thrown or not</parampseudo>
<result>Error code</result>
<errorcode name="RTS_RESULT" type="ERR_OK">Parameter was retrieved</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">hDevice was invalid, or pConnector, pConfigParameter or pData was NULL.</errorcode>
<errorcode name="RTS_RESULT" type="ERR_FAILED">Parameter is not handled by the driver</errorcode>
<errorcode name="RTS_RESULT" type="ERR_NOT_SUPPORTED">This feature is not supported by the driver, or the I/O Manager</errorcode>
</element>
</element>
<element interface="1" name="CmpIoDrvParameter2Itf">
<interfacename>CmpIoDrvParameter2</interfacename>
<description>
Interface to access parameters of an IO-driver by their parameter id
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hDevice, IoConfigConnector *pConnector, RTS_UI32 dwParamId, void *pData, RTS_SIZE ulBitSize, RTS_SIZE ulBitOffset)">IoDrvReadParameterById</functionname>
<description>  </description>
<result>ERR_OK</result>
</element>
</element>
<element interface="1" name="CmpIoDrvProfinetItf">
<interfacename>CmpIoDrvProfinet</interfacename>
<description>
Interface to get access to a ProfiNet IO-driver.
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hDevice, IoConfigConnector *pConnector)">IoDrvProfinet_Nominate</functionname>
<description>  </description>
<result>ERR_OK</result>
</element>
</element>
<element interface="1" name="CmpIoDrvDPV1C2MasterItf">
<interfacename>CmpIoDrvDPV1C2Master</interfacename>
<description>
Interface of a profibus IO-driver for the DPV1 Class 2 Master interface.
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element typedefinition="1">
<name>DPV1_C2_Abort</name>
<structname>DPV1_C2_Abort</structname>
<description>DPV1_C2_Abort</description>
<rawdata>
typedef struct tagDPV1_C2_Abort
{
	RTS_IEC_BOOL bEnable;
	RTS_IEC_BYTE byStationAddress;
	RTS_IEC_BYTE byDummy[2];
	RTS_IEC_UDINT udiConnectID;
	RTS_IEC_UDINT C_Ref;
	RTS_IEC_BYTE abyError[4];
	RTS_IEC_WORD wOpState;
	RTS_IEC_BOOL bOldEnable;
	RTS_IEC_UDINT udiId;
} DPV1_C2_Abort;
</rawdata>
</element>
<element typedefinition="1">
<name>DPV1_C2_Read</name>
<structname>DPV1_C2_Read</structname>
<description>DPV1_C2_Read</description>
<rawdata>
typedef struct tagDPV1_C2_Read
{
	RTS_IEC_BOOL bEnable;
	RTS_IEC_BYTE byStationAddress;
	RTS_IEC_BYTE bySlotNr;
	RTS_IEC_BYTE byIndex;
	RTS_IEC_UDINT udiConnectID;
	RTS_IEC_UDINT C_Ref;
	RTS_IEC_WORD wLen;
	RTS_IEC_BYTE byDummy[2];
	RTS_IEC_BYTE *pBuffer;
	RTS_IEC_BYTE abyError[4];
	RTS_IEC_WORD wOpState;
	RTS_IEC_BOOL bOldEnable;
	RTS_IEC_UDINT udiId;
} DPV1_C2_Read;
</rawdata>
</element>
<element typedefinition="1">
<name>DPV1_C2_Initiate</name>
<structname>DPV1_C2_Initiate</structname>
<description>DPV1_C2_Initiate</description>
<rawdata>
typedef struct tagDPV1_C2_Initiate
{
	RTS_IEC_BOOL bEnable;
	RTS_IEC_BYTE byStationAddress;
	RTS_IEC_BYTE byDummy[2];
	RTS_IEC_DWORD dwSendTimeoutMs;
	RTS_IEC_UDINT C_Ref;
	RTS_IEC_BYTE Res_SAP;
	RTS_IEC_WORD wOpState;
	RTS_IEC_BYTE abyError[4];
	RTS_IEC_UDINT udiConnectID;
	RTS_IEC_BOOL bOldEnable;
	RTS_IEC_UDINT udiId;
} DPV1_C2_Initiate;
</rawdata>
</element>
<element typedefinition="1">
<name>DPV1_C2_Write</name>
<structname>DPV1_C2_Write</structname>
<description>DPV1_C2_Write</description>
<rawdata>
typedef struct tagDPV1_C2_Write
{
	RTS_IEC_BOOL bEnable;
	RTS_IEC_BYTE byStationAddress;
	RTS_IEC_BYTE bySlotNr;
	RTS_IEC_BYTE byIndex;
	RTS_IEC_UDINT udiConnectID;
	RTS_IEC_UDINT C_Ref;
	RTS_IEC_WORD wLen;
	RTS_IEC_BYTE byDummy[2];
	RTS_IEC_BYTE *pBuffer;
	RTS_IEC_BYTE abyError[4];
	RTS_IEC_WORD wOpState;
	RTS_IEC_BOOL bOldEnable;
	RTS_IEC_UDINT udiId;
} DPV1_C2_Write;
</rawdata>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hIoDrv, DPV1_C2_Initiate *pInit)">IoDrvDPV1_C2_M_Initiate</functionname>
<description></description>
<result>ERR_OK</result>
</element>
</element>
<element interface="1" name="CmpIoDrvDPV1C1MasterItf">
<interfacename>CmpIoDrvDPV1C1Master</interfacename>
<description>
Interface of a profibus IO-driver for the DPV1 Class 1 Master interface.
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hIoDrv, DPV1_C1_Read *pRead)">IoDrvDPV1_C1_M_Read</functionname>
<description></description>
<result>ERR_OK</result>
</element>
</element>
</component>
<component>
<name>CmpIOMgrEmbedded</name>
<description>
Manager for all IO-drivers (IEC and ANSI-C) and IO-configuration.
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element tasks="1" name="Tasks">
<element task="1">
<name>IoMgrWatchdogTask</name>
<category>Task</category>
<priority>TASKPRIO_HIGH_BASE</priority>
<description>Task to handle IO-watchdog trigger.</description>
</element>
</element>
<element interface="1" name="CmpIoMgrItf">
<interfacename>CmpIoMgr</interfacename>
<description>
<p>Interface of the IO-manager, which manages all IO-driver instances in the runtime system.</p>
<p>There are several data structures involved in the I/O update. All of them are registered
in or passed to the I/O Manager. The following is an overview over the most essential
structures and how they are passed to the I/O Manager:</p>
<pre>
.    +------------------+ UpdateConfiguration()
.  +------------------+ |
. +-----------------+ |-+
. | IoConfigTaskMap |-+
. +-------+---------+ ReadInputs() / WriteOutputs()
.         | 1                                  UpdateConfiguration()
.         |                       +--------------------+
.         | n                   +--------------------+ |
. +-------+--------------+     +-------------------+ |-+
. | IoConfigConnectorMap |     | IoConfigConnector |-+
. +-------+--------------+     +--------+----------+ StartBusCycle()
.         | 1                           | 1
.         |                             |
.         | n                           | n
. +-------+------------+ n   1 +--------+----------+
. | IoConfigChannelMap +-------+ IoConfigParameter |
. +--------------------+       +-------------------+
</pre>
<p>Most calls to the I/O Manager are just passed directly through to the drivers.
Depending on the kind of driver, this may passed through CmpIoDrvIEC or directly
to it.</p>
<p>The following drawing illustrates how a call to e.g. ReadInputs() is passed
to the drivers if there is a C and an IEC driver registered and used in one task:</p>
<pre>
. +--------+    +--------+    +--------+   +-----------+   +--------+
. |IEC Task|    |CmpIoMgr|    |IoDrvInC|   |CmpIoDrvIEC|   |IoDrvLib|
. +--------+    +---+----+    +---+----+   +----+------+   +---+----+
.     |             |             |             |              |
.    +++            |             |             |              |
.    | |-----------+++            |             |              |
.    | |           | |-----------+++            |              |
.    | |           | |           | |            |              |
.    | |           | |           | |            |              |
.    | |           | |           | |            |              |
.    | |           | |...........+++            |              |
.    | |           | |            |             |              |
.    | |           | |------------+------------+++             |
.    | |           | |            |            | |             |
.    | |           | |            |            | |             |
.    | |           | |            |            | |------------+++
.    | |           | |            |            | |            | |
.    | |           | |            |            | |            | |
.    | |           | |            |            | |............+++
.    | |           | |.........................+++             |
.    | |...........+++            |             |              |
.    | |            |             |             |              |
.    | |            |             |             |              |
.    +++            |             |             |              |
.     |             |             |             |              |
.     |             |             |             |              |
</pre>
<p>The devices, which are configured in the CoDeSys programming system
are downloaded in form of connector lists. All connectors, specified
for the devices are downloaded in form of a list.</p>
<p>Beside neighbours, this list has although a parent role, that means,
that every list member can point to it's parent.</p>
<p>For example:</p>
<pre>
.                      _____
.             _,.--''''     `'''`--..__
.          ,,'          ___            `--.._
.       _,i__       ,-ii_  `''`--.._         `-..
.     ,;''   `'-._,;''   `'-._      ``-.._       `-._
.  +----+      +----+      +----+      +----+      +-'--+
.  | A  |------+ B  |------| C  |------| D  |------+ E  |-----
.  +----+      +----+      +----+      +----+      +----+
</pre>
<p>This list represents the following tree:</p>
<pre>
.                 ,-.
.                ( A )
.                /`-'\
.              .'     |
.          ,-./       \,-.
.         ( B )       ( E )
.         /`-'\        `-'
.       .'     |
.   ,-./       \,-.
.  ( C )       ( D )
.   `-'         `-'
</pre>
<p>The API functions within this component await always a pointer
to one of these connectors, when the input is a "Connecto List".
The count doesn't essentially need to specify the absolut size
of the list, but the size, starting at the connector that we
passed to the function.</p>
<p>For example, if we want to iterate over the connector list above (in pseudo code):</p>
<pre>
GetFirst(A, 5) => A (count: 5)
GetNext(A,5) => B (count: 4)
GetNextChild(B, 4, B) => C (Count: 3)
GetNextChild(B, 4, C) => D (count: 2)
GetNextChild(B, 4, D) => NULL
GetNext(D, 2) => E (count: 1)
GetNext(E, 1) => NULL
</pre>
<p>Note: Because the parameter pnCount is an INOUT, you need to save
the size of the list in a different variable when you use for example
GetNextChild(). Because this value will be overwritten with the number
of remaining entries in the list, starting at the connector that was
returned.</p>
<p>There are two different kinds of driver handles, that the I/O Manager
needs to differenciate:</p>
<ul>
<li>C Drivers</li>
<li>IEC Drivers</li>
</ul>
<p>The I/O Manager provides a common function interface for C Components
and for IEC Applications. But while the Connectors and Paramter structures
are completely the same for both sides, the driver handles are significantly
different. Internally the I/O manager works with C driver handles. The
abstraction to provide an IEC interface, which is based on Function Blocks,
is done by the two components CmpIoDrvC and CmpIoDrvIec.</p>
<p>The component CmpIoDrvC manages all C drivers and CmpIoDrvIec manages all
IEC drivers.</p>
</description>
<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element define="1">
<name>NUM_OF_STATIC_DEVICES</name>
<key>5</key>
<condition>NUM_OF_STATIC_DEVICES</condition>
<category>Static defines</category>
<description>Number of static IO-driver instances to store</description>
</element>
<element define="1">
<name>NUM_OF_STATIC_PARAMETER_STORAGE</name>
<key>10</key>
<condition>NUM_OF_STATIC_PARAMETER_STORAGE</condition>
<category>Static defines</category>
<description>Number of static parameter to store during writing operation. See setting </description>
</element>
<element define="1">
<name>IOMGR_PARAMETER_STORAGE_FILE</name>
<key>IoConfig.par</key>
<condition>IOMGR_PARAMETER_STORAGE_FILE</condition>
<category>File name definitions</category>
<description>Name of the parameter storage to save the changed IO-config parameters</description>
</element>
<element define="1">
<name>IOMGR_WATCHTDOGTASK_TASK_DELAY</name>
<key>100</key>
<condition>IOMGR_WATCHTDOGTASK_TASK_DELAY</condition>
<category>Watchdog definitions</category>
<description>This is the initial watchdogtask task delay. On the first download of a watchdog time, this time is recalculated</description>
</element>
<element define="1">
<name>BCT_START</name>
<key>0x00000001</key>
<category>Bus Cycle Type</category>
<description>
<p>
Type of the bus cycle to differenciate between:
</p>
<ul>
<li>BCT_START: Bus Cycle is executed at the beginning of the task cycle</li>
<li>BCT_END:   Bus Cycle is executed at the end of the task cycle</li>
</ul>
</description>
</element>
<element define="1">
<name>SRV_IOMGRSCANMODULES</name>
<key>0x01</key>
<category>Online services</category>
<description>
</description>
</element>
<element define="1">
<name>TAG_DEVICESCAN_LIST</name>
<key>0x81</key>
<category>Online tags</category>
<description>
</description>
</element>
<element define="1">
<name>EVT_PrepareUpdateConfiguration</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent before updating the IO-configuration</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpIoMgr</param>
</element>
<element define="1">
<name>EVT_DoneUpdateConfiguration</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent after updating the IO-configuration</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpIoMgr</param>
</element>
<element define="1">
<name>EVT_ConfigAppStartedDone</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent after the config application is started</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpIoMgr</param>
</element>
<element define="1">
<name>EVT_PrepareConfigAppStopped</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent before the config application is stopped</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpIoMgr</param>
</element>
<element define="1">
<name>EVT_PrepareUpdateMapping</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent before updating the IO-mapping of an application</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpIoMgrUpdateMapping</param>
</element>
<element define="1">
<name>EVT_DoneUpdateMapping</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent after updating the IO-mapping of an application</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpIoMgrUpdateMapping</param>
</element>
<element define="1">
<name>EVT_UpdateDiagDone</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent after updating the module diagnosis of the specified driver, which supports the property DRVPROP_BACKGROUND_GETDIAG</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpIoMgrUpdateDiag</param>
</element>
<element define="1">
<name>EVT_ConfigAppStoppedDone</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent after the config application is stopped</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpIoMgr</param>
</element>
<element typedefinition="1">
<name>IoConfigParameter</name>
<structname>IoConfigParameter</structname>
<description>
Parameter description. This entry describes completely a parameter of an connector.
</description>
<param name="dwParameterId" type="IN">ID of the parameter. This ID is specified in the device description.</param>
<param name="dwValue" type="IN">Value (is valid for data with maximum 4 bytes) or a pointer to the value of the parameter</param>
<param name="wType" type="IN">Type class of the parameter. See category "Type class" for detailed information.</param>
<param name="wLen" type="IN">Length of the parameter in bits</param>
<param name="dwFlags" type="IN">Parameter value flags.  See category "Parameter value flags" for detailed information.</param>
<param name="dwDriverSpecific" type="IN">Driver specific entry. Reserved for the usage in the driver.</param>
<SIL2/>
<rawdata>
typedef struct tagIoConfigParameter
{
	RTS_IEC_DWORD dwParameterId;
	RTS_IEC_BYTE *dwValue;
	RTS_IEC_WORD wType;
	RTS_IEC_WORD wLen;
	RTS_IEC_DWORD dwFlags;
	RTS_IEC_BYTE *dwDriverSpecific;
} IoConfigParameter;
</rawdata>
</element>
<element typedefinition="1">
<name>IoConfigConnector</name>
<structname>IoConfigConnector</structname>
<description>
Connector information. Each device is described completely as a set of one input- and one or more
output-conenctors.
</description>
<param name="wType" type="IN">Type of the connector. See category "Connector types" for detailed information.</param>
<param name="wOptions" type="IN">Connector options. See category "Connector options" in CmpIoDrvItf.h for detailed information.</param>
<param name="dwFlags" type="IN">Connector flags. See category "Connector flags" for detailed information.</param>
<param name="hIoDrv" type="IN">Registered instance handle of the IO-driver, that operates this device respectively this connector</param>
<param name="dwNumOfParameters" type="IN">Number of parameters in the parameter list</param>
<param name="pParameterList" type="IN">Pointer to the parameter list, that contains all parameters of this connector</param>
<param name="pFather" type="IN">Pointer to the father connector to describe the device tree</param>
<SIL2/>
<rawdata>
typedef struct tagIoConfigConnector
{
	RTS_IEC_WORD wType;
	RTS_IEC_WORD wOptions;
	RTS_IEC_DWORD dwFlags;
	RTS_IEC_HANDLE hIoDrv;
	RTS_IEC_DWORD dwNumOfParameters;
	IoConfigParameter *pParameterList;
	struct tagIoConfigConnector *pFather;
} IoConfigConnector;
</rawdata>
</element>
<element typedefinition="1">
<name>IoConfigChannelMap</name>
<structname>IoConfigChannelMap</structname>
<description>
Mapping information for a single channel. Every I/O-channel is described as a parameter, but with special meanings.
The datatype of a channel can be simple (BOOL, BYTE, WORD, etc.) or array of simple types.
</description>
<param name="pParameter" type="IN">Pointer to the parameter description</param>
<param name="pbyIecAddress" type="IN">Pointer to the parameter in the process image on the IEC side</param>
<param name="wParameterBitOffset" type="IN">Bitoffset of the device</param>
<param name="wIecAddressBitOffset" type="IN">Bitoffset of pbyIecAddress in the IEC process image</param>
<param name="wSize" type="IN">Size in bits of the channel</param>
<param name="wBaseTypeInformation" type="IN">If this field is unequal zero, it is used for the base type information. With this information, a correct swapping operation can be executed.</param>
<param name="dwDriverSpecific" type="IN">Driver specific entry. Reserved for the usage in the driver.</param>
<SIL2/>
<rawdata>
typedef struct tagIoConfigChannelMap
{
	IoConfigParameter *pParameter;
	RTS_IEC_BYTE *pbyIecAddress;
	RTS_IEC_WORD wParameterBitOffset;
	RTS_IEC_WORD wIecAddressBitOffset;
	RTS_IEC_WORD wSize;
	RTS_IEC_WORD wBaseTypeInformation;
	RTS_IEC_BYTE *dwDriverSpecific;
} IoConfigChannelMap;
</rawdata>
</element>
<element typedefinition="1">
<name>IoConfigConnectorMap</name>
<structname>IoConfigConnectorMap</structname>
<description>
Connector map to describe all IO-channels of one connector
</description>
<param name="pConnector" type="IN">Pointer to the corresponding connector</param>
<param name="dwIoMgrSpecific" type="IN">IO-manager specific entry</param>
<param name="dwNumOfChannels" type="IN">Number of channels in the channel map list</param>
<param name="pChannelMapList" type="IN">Pointer to channel map list</param>
<SIL2/>
<rawdata>
typedef struct tagIoConfigConnectorMap
{
	IoConfigConnector *pConnector;
	RTS_IEC_BYTE *dwIoMgrSpecific;
	RTS_IEC_DWORD dwNumOfChannels;
	IoConfigChannelMap *pChannelMapList;
} IoConfigConnectorMap;
</rawdata>
</element>
<element typedefinition="1">
<name>IoConfigTaskMap</name>
<structname>IoConfigTaskMap</structname>
<description>
Mapping description for each task.
</description>
<param name="dwTaskId" type="IN">Index of the IEC task</param>
<param name="wType" type="IN">Input or output type. See category "Task map types" for detailed information.</param>
<param name="wNumOfConnectorMap" type="IN">Number of connector maps int the connector map list</param>
<param name="pConnectorMapList" type="IN">Pointer to the connector map list</param>
<SIL2/>
<rawdata>
typedef struct tagIoConfigTaskMap
{
	RTS_IEC_DWORD dwTaskId;
	RTS_IEC_WORD wType;
	RTS_IEC_WORD wNumOfConnectorMap;
	IoConfigConnectorMap *pConnectorMapList;
} IoConfigTaskMap;
</rawdata>
</element>
<element typedefinition="1">
<name>iomgrstartbuscycle_struct</name>
<structname>iomgrstartbuscycle_struct</structname>
<description>iomgrstartbuscycle</description>
<rawdata>
typedef struct tagiomgrstartbuscycle_struct
{
	IoConfigConnector *pConnector;		VAR_INPUT
	RTS_IEC_UDINT IoMgrStartBusCycle;	VAR_OUTPUT
} iomgrstartbuscycle_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>iomgrstartbuscycle2_struct</name>
<structname>iomgrstartbuscycle2_struct</structname>
<description>
Start the bus cycle for a specific connector, and pass
the type of this call as an additional option. This way,
the driver knows in which conditions (see BusCycleType)
was called, by calling IoMgrGetBusCycleType().
</description>
<rawdata>
typedef struct tagiomgrstartbuscycle2_struct
{
	IoConfigConnector *pConnector;		VAR_INPUT
	RTS_IEC_UDINT dwType;				VAR_INPUT
	RTS_IEC_UDINT IoMgrStartBusCycle2;	VAR_OUTPUT
} iomgrstartbuscycle2_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>iomgrupdateconfiguration2_struct</name>
<structname>iomgrupdateconfiguration2_struct</structname>
<description>iomgrupdateconfiguration2</description>
<rawdata>
typedef struct tagiomgrupdateconfiguration2_struct
{
	IoConfigConnector *pConnectorList;	VAR_INPUT
	RTS_IEC_DINT nCount;				VAR_INPUT
	RTS_IEC_STRING *pszConfigApplication;	VAR_INPUT
	RTS_IEC_UDINT IoMgrUpdateConfiguration2;	VAR_OUTPUT
} iomgrupdateconfiguration2_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>iomgrconfiggetconnector_struct</name>
<structname>iomgrconfiggetconnector_struct</structname>
<description>iomgrconfiggetconnector</description>
<rawdata>
typedef struct tagiomgrconfiggetconnector_struct
{
	IoConfigConnector *pConnectorList;	VAR_INPUT
	RTS_IEC_DINT *pnCount;				VAR_INPUT
	RTS_IEC_DWORD dwModuleType;			VAR_INPUT
	RTS_IEC_DWORD dwInstance;			VAR_INPUT
	IoConfigConnector *IoMgrConfigGetConnector;	VAR_OUTPUT
} iomgrconfiggetconnector_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>iomgrconfiggetdriver_struct</name>
<structname>iomgrconfiggetdriver_struct</structname>
<description>iomgrconfiggetdriver</description>
<rawdata>
typedef struct tagiomgrconfiggetdriver_struct
{
	IoConfigConnector *pConnector;		VAR_INPUT
	RTS_IEC_DINT *pbIecDriver;			VAR_INPUT
	RTS_IEC_UDINT *pResult;				VAR_INPUT
	IBase *IoMgrConfigGetDriver;		VAR_OUTPUT
} iomgrconfiggetdriver_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>iomgrconfiggetconnectorlist_struct</name>
<structname>iomgrconfiggetconnectorlist_struct</structname>
<description>iomgrconfiggetconnectorlist</description>
<rawdata>
typedef struct tagiomgrconfiggetconnectorlist_struct
{
	IoConfigConnector **ppConnectorList;	VAR_INPUT
	RTS_IEC_DINT *pnCount;				VAR_INPUT
	RTS_IEC_UDINT IoMgrConfigGetConnectorList;	VAR_OUTPUT
} iomgrconfiggetconnectorlist_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>iomgrconfiggetconnectorbydriver_struct</name>
<structname>iomgrconfiggetconnectorbydriver_struct</structname>
<description>iomgrconfiggetconnectorbydriver</description>
<rawdata>
typedef struct tagiomgrconfiggetconnectorbydriver_struct
{
	IBase *pIBase;						VAR_INPUT
	RTS_IEC_DINT bIecDriver;			VAR_INPUT
	RTS_IEC_DINT nIndex;				VAR_INPUT
	RTS_IEC_UDINT *pResult;				VAR_INPUT
	IoConfigConnector *IoMgrConfigGetConnectorByDriver;	VAR_OUTPUT
} iomgrconfiggetconnectorbydriver_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>iomgrconfiggetfirstconnector_struct</name>
<structname>iomgrconfiggetfirstconnector_struct</structname>
<description>iomgrconfiggetfirstconnector</description>
<rawdata>
typedef struct tagiomgrconfiggetfirstconnector_struct
{
	IoConfigConnector *pConnectorList;	VAR_INPUT
	RTS_IEC_DINT *pnCount;				VAR_INPUT
	RTS_IEC_WORD wType;					VAR_INPUT
	IoConfigConnector *IoMgrConfigGetFirstConnector;	VAR_OUTPUT
} iomgrconfiggetfirstconnector_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>iomgrconfigsetdiagnosis_struct</name>
<structname>iomgrconfigsetdiagnosis_struct</structname>
<description>iomgrconfigsetdiagnosis</description>
<rawdata>
typedef struct tagiomgrconfigsetdiagnosis_struct
{
	IoConfigConnector *pConnector;		VAR_INPUT
	RTS_IEC_DWORD dwFlags;				VAR_INPUT
	RTS_IEC_UDINT IoMgrConfigSetDiagnosis;	VAR_OUTPUT
} iomgrconfigsetdiagnosis_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>iomgrreadparameter_struct</name>
<structname>iomgrreadparameter_struct</structname>
<description>iomgrreadparameter</description>
<rawdata>
typedef struct tagiomgrreadparameter_struct
{
	RTS_IEC_DWORD dwModuleType;			VAR_INPUT
	RTS_IEC_DWORD dwInstance;			VAR_INPUT
	RTS_IEC_DWORD dwParameterId;		VAR_INPUT
	RTS_IEC_BYTE *pData;				VAR_INPUT
	RTS_IEC_DWORD dwBitSize;			VAR_INPUT
	RTS_IEC_DWORD dwBitOffset;			VAR_INPUT
	RTS_IEC_UDINT IoMgrReadParameter;	VAR_OUTPUT
} iomgrreadparameter_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>iomgrwatchdogtrigger_struct</name>
<structname>iomgrwatchdogtrigger_struct</structname>
<description>iomgrwatchdogtrigger</description>
<rawdata>
typedef struct tagiomgrwatchdogtrigger_struct
{
	IoConfigConnector *pConnector;		VAR_INPUT
	RTS_IEC_UDINT IoMgrWatchdogTrigger;	VAR_OUTPUT
} iomgrwatchdogtrigger_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>iomgrconfigresetdiagnosis_struct</name>
<structname>iomgrconfigresetdiagnosis_struct</structname>
<description>iomgrconfigresetdiagnosis</description>
<rawdata>
typedef struct tagiomgrconfigresetdiagnosis_struct
{
	IoConfigConnector *pConnector;		VAR_INPUT
	RTS_IEC_DWORD dwFlags;				VAR_INPUT
	RTS_IEC_UDINT IoMgrConfigResetDiagnosis;	VAR_OUTPUT
} iomgrconfigresetdiagnosis_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>iomgrconfiggetnextconnector_struct</name>
<structname>iomgrconfiggetnextconnector_struct</structname>
<description>iomgrconfiggetnextconnector</description>
<rawdata>
typedef struct tagiomgrconfiggetnextconnector_struct
{
	IoConfigConnector *pConnectorList;	VAR_INPUT
	RTS_IEC_DINT *pnCount;				VAR_INPUT
	RTS_IEC_WORD wType;					VAR_INPUT
	IoConfigConnector *IoMgrConfigGetNextConnector;	VAR_OUTPUT
} iomgrconfiggetnextconnector_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>iomgrupdatemapping_struct</name>
<structname>iomgrupdatemapping_struct</structname>
<description>iomgrupdatemapping</description>
<rawdata>
typedef struct tagiomgrupdatemapping_struct
{
	IoConfigTaskMap *pTaskMapList;		VAR_INPUT
	RTS_IEC_DINT nCount;				VAR_INPUT
	RTS_IEC_UDINT IoMgrUpdateMapping;	VAR_OUTPUT
} iomgrupdatemapping_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>iomgrgetfirstdriverinstance_struct</name>
<structname>iomgrgetfirstdriverinstance_struct</structname>
<description>iomgrgetfirstdriverinstance</description>
<rawdata>
typedef struct tagiomgrgetfirstdriverinstance_struct
{
	RTS_IEC_DINT *pbIecDriver;			VAR_INPUT
	RTS_IEC_UDINT *pResult;				VAR_INPUT
	IBase *IoMgrGetFirstDriverInstance;	VAR_OUTPUT
} iomgrgetfirstdriverinstance_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>iomgrregisterconfigapplication_struct</name>
<structname>iomgrregisterconfigapplication_struct</structname>
<description>iomgrregisterconfigapplication</description>
<rawdata>
typedef struct tagiomgrregisterconfigapplication_struct
{
	RTS_IEC_STRING *pszConfigApplication;	VAR_INPUT
	RTS_IEC_UDINT IoMgrRegisterConfigApplication;	VAR_OUTPUT
} iomgrregisterconfigapplication_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>iomgrsetdriverproperties_struct</name>
<structname>iomgrsetdriverproperties_struct</structname>
<description>iomgrsetdriverproperties</description>
<rawdata>
typedef struct tagiomgrsetdriverproperties_struct
{
	RTS_IEC_HANDLE hIoDrv;				VAR_INPUT
	RTS_IEC_DWORD ulProperties;			VAR_INPUT
	RTS_IEC_UDINT IoMgrSetDriverProperties;	VAR_OUTPUT
} iomgrsetdriverproperties_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>iomgrsetdriverproperty_struct</name>
<structname>iomgrsetdriverproperty_struct</structname>
<description>iomgrsetdriverproperty</description>
<rawdata>
typedef struct tagiomgrsetdriverproperty_struct
{
	RTS_IEC_HANDLE hIoDrv;				VAR_INPUT
	RTS_IEC_DWORD ulProperty;			VAR_INPUT
	RTS_IEC_DINT bValue;				VAR_INPUT
	RTS_IEC_UDINT IoMgrSetDriverProperty;	VAR_OUTPUT
} iomgrsetdriverproperty_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>iomgrgetdriverproperties_struct</name>
<structname>iomgrgetdriverproperties_struct</structname>
<description>iomgrgetdriverproperties</description>
<rawdata>
typedef struct tagiomgrgetdriverproperties_struct
{
	RTS_IEC_HANDLE hIoDrv;				VAR_INPUT
	RTS_IEC_DWORD **ppProperties;		VAR_INPUT
	RTS_IEC_UDINT IoMgrGetDriverProperties;	VAR_OUTPUT
} iomgrgetdriverproperties_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>iomgrconfiggetparametervaluepointer_struct</name>
<structname>iomgrconfiggetparametervaluepointer_struct</structname>
<description>iomgrconfiggetparametervaluepointer</description>
<rawdata>
typedef struct tagiomgrconfiggetparametervaluepointer_struct
{
	IoConfigParameter *pParameter;		VAR_INPUT
	RTS_IEC_UDINT *pResult;				VAR_INPUT
	RTS_IEC_BYTE *IoMgrConfigGetParameterValuePointer;	VAR_OUTPUT
} iomgrconfiggetparametervaluepointer_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>iomgrscanmodules_struct</name>
<structname>iomgrscanmodules_struct</structname>
<description>iomgrscanmodules</description>
<rawdata>
typedef struct tagiomgrscanmodules_struct
{
	IoConfigConnector *pConnector;		VAR_INPUT
	IoConfigConnector **ppConnectorList;	VAR_INPUT
	RTS_IEC_DINT *pnCount;				VAR_INPUT
	RTS_IEC_UDINT IoMgrScanModules;		VAR_OUTPUT
} iomgrscanmodules_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>iomgrgetmodulediagnosis_struct</name>
<structname>iomgrgetmodulediagnosis_struct</structname>
<description>iomgrgetmodulediagnosis</description>
<SIL2/>
<rawdata>
typedef struct tagiomgrgetmodulediagnosis_struct
{
	IoConfigConnector *pConnector;		VAR_INPUT
	RTS_IEC_UDINT IoMgrGetModuleDiagnosis;	VAR_OUTPUT
} iomgrgetmodulediagnosis_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>iomgrunregisterinstance_struct</name>
<structname>iomgrunregisterinstance_struct</structname>
<description>iomgrunregisterinstance</description>
<rawdata>
typedef struct tagiomgrunregisterinstance_struct
{
	RTS_IEC_HANDLE hInterface;			VAR_INPUT
	RTS_IEC_UDINT IoMgrUnregisterInstance;	VAR_OUTPUT
} iomgrunregisterinstance_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>iomgrconfiggetnextchild_struct</name>
<structname>iomgrconfiggetnextchild_struct</structname>
<description>iomgrconfiggetnextchild</description>
<rawdata>
typedef struct tagiomgrconfiggetnextchild_struct
{
	IoConfigConnector *pConnectorList;	VAR_INPUT
	RTS_IEC_DINT *pnCount;				VAR_INPUT
	IoConfigConnector *pFather;			VAR_INPUT
	IoConfigConnector *IoMgrConfigGetNextChild;	VAR_OUTPUT
} iomgrconfiggetnextchild_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>iomgrconfiggetparameter_struct</name>
<structname>iomgrconfiggetparameter_struct</structname>
<description>iomgrconfiggetparameter</description>
<rawdata>
typedef struct tagiomgrconfiggetparameter_struct
{
	IoConfigConnector *pConnector;		VAR_INPUT
	RTS_IEC_DWORD dwParameterId;		VAR_INPUT
	IoConfigParameter *IoMgrConfigGetParameter;	VAR_OUTPUT
} iomgrconfiggetparameter_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>iomgrupdatemapping2_struct</name>
<structname>iomgrupdatemapping2_struct</structname>
<description>iomgrupdatemapping2</description>
<rawdata>
typedef struct tagiomgrupdatemapping2_struct
{
	IoConfigTaskMap *pTaskMapList;		VAR_INPUT
	RTS_IEC_DINT nCount;				VAR_INPUT
	RTS_IEC_STRING *pszConfigApplication;	VAR_INPUT
	RTS_IEC_UDINT IoMgrUpdateMapping2;	VAR_OUTPUT
} iomgrupdatemapping2_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>iomgrwriteparameter_struct</name>
<structname>iomgrwriteparameter_struct</structname>
<description>iomgrwriteparameter</description>
<rawdata>
typedef struct tagiomgrwriteparameter_struct
{
	RTS_IEC_DWORD dwModuleType;			VAR_INPUT
	RTS_IEC_DWORD dwInstance;			VAR_INPUT
	RTS_IEC_DWORD dwParameterId;		VAR_INPUT
	RTS_IEC_BYTE *pData;				VAR_INPUT
	RTS_IEC_DWORD dwBitSize;			VAR_INPUT
	RTS_IEC_DWORD dwBitOffset;			VAR_INPUT
	RTS_IEC_UDINT IoMgrWriteParameter;	VAR_OUTPUT
} iomgrwriteparameter_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>iomgrupdateconfiguration_struct</name>
<structname>iomgrupdateconfiguration_struct</structname>
<description>iomgrupdateconfiguration</description>
<rawdata>
typedef struct tagiomgrupdateconfiguration_struct
{
	IoConfigConnector *pConnectorList;	VAR_INPUT
	RTS_IEC_DINT nCount;				VAR_INPUT
	RTS_IEC_UDINT IoMgrUpdateConfiguration;	VAR_OUTPUT
} iomgrupdateconfiguration_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>iomgrgetconfigapplication_struct</name>
<structname>iomgrgetconfigapplication_struct</structname>
<description>iomgrgetconfigapplication</description>
<rawdata>
typedef struct tagiomgrgetconfigapplication_struct
{
	RTS_IEC_STRING *pszConfigApplication;	VAR_INPUT
	RTS_IEC_DINT *pnMaxLen;				VAR_INPUT
	RTS_IEC_UDINT IoMgrGetConfigApplication;	VAR_OUTPUT
} iomgrgetconfigapplication_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>iomgrconfiggetfirstchild_struct</name>
<structname>iomgrconfiggetfirstchild_struct</structname>
<description>iomgrconfiggetfirstchild</description>
<rawdata>
typedef struct tagiomgrconfiggetfirstchild_struct
{
	IoConfigConnector *pConnectorList;	VAR_INPUT
	RTS_IEC_DINT *pnCount;				VAR_INPUT
	IoConfigConnector *pFather;			VAR_INPUT
	IoConfigConnector *IoMgrConfigGetFirstChild;	VAR_OUTPUT
} iomgrconfiggetfirstchild_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>iomgrconfiggetparametervalueword_struct</name>
<structname>iomgrconfiggetparametervalueword_struct</structname>
<description>iomgrconfiggetparametervalueword</description>
<rawdata>
typedef struct tagiomgrconfiggetparametervalueword_struct
{
	IoConfigParameter *pParameter;		VAR_INPUT
	RTS_IEC_UDINT *pResult;				VAR_INPUT
	RTS_IEC_WORD IoMgrConfigGetParameterValueWord;	VAR_OUTPUT
} iomgrconfiggetparametervalueword_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>iomgrwriteoutputs_struct</name>
<structname>iomgrwriteoutputs_struct</structname>
<description>iomgrwriteoutputs</description>
<rawdata>
typedef struct tagiomgrwriteoutputs_struct
{
	IoConfigTaskMap *pTaskMap;			VAR_INPUT
	RTS_IEC_UDINT IoMgrWriteOutputs;	VAR_OUTPUT
} iomgrwriteoutputs_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>iomgrconfiggetparametervaluebyte_struct</name>
<structname>iomgrconfiggetparametervaluebyte_struct</structname>
<description>iomgrconfiggetparametervaluebyte</description>
<rawdata>
typedef struct tagiomgrconfiggetparametervaluebyte_struct
{
	IoConfigParameter *pParameter;		VAR_INPUT
	RTS_IEC_UDINT *pResult;				VAR_INPUT
	RTS_IEC_BYTE IoMgrConfigGetParameterValueByte;	VAR_OUTPUT
} iomgrconfiggetparametervaluebyte_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>iomgrunregisterconfigapplication_struct</name>
<structname>iomgrunregisterconfigapplication_struct</structname>
<description>iomgrunregisterconfigapplication</description>
<rawdata>
typedef struct tagiomgrunregisterconfigapplication_struct
{
	RTS_IEC_STRING *pszConfigApplication;	VAR_INPUT
	RTS_IEC_UDINT IoMgrUnregisterConfigApplication;	VAR_OUTPUT
} iomgrunregisterconfigapplication_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>iomgrregisterinstance2_struct</name>
<structname>iomgrregisterinstance2_struct</structname>
<description>iomgrregisterinstance2</description>
<rawdata>
typedef struct tagiomgrregisterinstance2_struct
{
	RTS_IEC_DWORD dwClassId;			VAR_INPUT
	IBase *pItf;						VAR_INPUT
	RTS_IEC_UDINT *pResult;				VAR_INPUT
	RTS_IEC_BYTE *IoMgrRegisterInstance2;	VAR_OUTPUT
} iomgrregisterinstance2_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>iomgrreadinputs_struct</name>
<structname>iomgrreadinputs_struct</structname>
<description>iomgrreadinputs</description>
<rawdata>
typedef struct tagiomgrreadinputs_struct
{
	IoConfigTaskMap *pTaskMap;			VAR_INPUT
	RTS_IEC_UDINT IoMgrReadInputs;		VAR_OUTPUT
} iomgrreadinputs_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>iomgrconfiggetparametervaluedword_struct</name>
<structname>iomgrconfiggetparametervaluedword_struct</structname>
<description>iomgrconfiggetparametervaluedword</description>
<rawdata>
typedef struct tagiomgrconfiggetparametervaluedword_struct
{
	IoConfigParameter *pParameter;		VAR_INPUT
	RTS_IEC_UDINT *pResult;				VAR_INPUT
	RTS_IEC_DWORD IoMgrConfigGetParameterValueDword;	VAR_OUTPUT
} iomgrconfiggetparametervaluedword_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>iomgridentify_struct</name>
<structname>iomgridentify_struct</structname>
<description>iomgridentify</description>
<rawdata>
typedef struct tagiomgridentify_struct
{
	IoConfigConnector *pConnector;		VAR_INPUT
	RTS_IEC_UDINT IoMgrIdentify;		VAR_OUTPUT
} iomgridentify_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>iomgrgetnextdriverinstance_struct</name>
<structname>iomgrgetnextdriverinstance_struct</structname>
<description>iomgrgetnextdriverinstance</description>
<rawdata>
typedef struct tagiomgrgetnextdriverinstance_struct
{
	IBase *pIBasePrev;					VAR_INPUT
	RTS_IEC_DINT *pbIecDriver;			VAR_INPUT
	RTS_IEC_UDINT *pResult;				VAR_INPUT
	IBase *IoMgrGetNextDriverInstance;	VAR_OUTPUT
} iomgrgetnextdriverinstance_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>iomgrcopyinputbe_struct</name>
<structname>iomgrcopyinputbe_struct</structname>
<description>iomgrcopyinputbe</description>
<rawdata>
typedef struct tagiomgrcopyinputbe_struct
{
	IoConfigChannelMap *pChannel;		VAR_INPUT
	RTS_IEC_BYTE *pAddress;				VAR_INPUT
	RTS_IEC_RESULT IoMgrCopyInputBE;	VAR_OUTPUT
} iomgrcopyinputbe_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>iomgrcopyinputle_struct</name>
<structname>iomgrcopyinputle_struct</structname>
<description>iomgrcopyinputle</description>
<rawdata>
typedef struct tagiomgrcopyinputle_struct
{
	IoConfigChannelMap *pChannel;		VAR_INPUT
	RTS_IEC_BYTE *pAddress;				VAR_INPUT
	RTS_IEC_RESULT IoMgrCopyInputLE;	VAR_OUTPUT
} iomgrcopyinputle_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>iomgrcopyoutputbe_struct</name>
<structname>iomgrcopyoutputbe_struct</structname>
<description>iomgrcopyoutputbe</description>
<rawdata>
typedef struct tagiomgrcopyoutputbe_struct
{
	IoConfigChannelMap *pChannel;		VAR_INPUT
	RTS_IEC_BYTE *pAddress;				VAR_INPUT
	RTS_IEC_RESULT IoMgrCopyOutputBE;	VAR_OUTPUT
} iomgrcopyoutputbe_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>iomgrcopyoutputle_struct</name>
<structname>iomgrcopyoutputle_struct</structname>
<description>iomgrcopyoutputle</description>
<rawdata>
typedef struct tagiomgrcopyoutputle_struct
{
	IoConfigChannelMap *pChannel;		VAR_INPUT
	RTS_IEC_BYTE *pAddress;				VAR_INPUT
	RTS_IEC_RESULT IoMgrCopyOutputLE;	VAR_OUTPUT
} iomgrcopyoutputle_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>iomgrgetbuscycletype_struct</name>
<structname>iomgrgetbuscycletype_struct</structname>
<description>iomgrgetbuscycletype</description>
<rawdata>
typedef struct tagiomgrgetbuscycletype_struct
{
	IoConfigConnector *pConnector;		VAR_INPUT
	RTS_IEC_RESULT *pResult;			VAR_INPUT
	RTS_IEC_UDINT IoMgrGetBusCycleType;	VAR_OUTPUT
} iomgrgetbuscycletype_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>iomgrconfiggetiodriver_struct</name>
<structname>iomgrconfiggetiodriver_struct</structname>
<description>iomgrconfiggetiodriver</description>
<rawdata>
typedef struct tagiomgrconfiggetiodriver_struct
{
	IoConfigConnector *pConnector;		VAR_INPUT
	RTS_IEC_DINT *pbIecDriver;			VAR_INPUT
	RTS_IEC_UDINT *pResult;				VAR_INPUT
	IBase *IoMgrConfigGetIoDriver;		VAR_OUTPUT
} iomgrconfiggetiodriver_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>EVTPARAM_CmpIoMgr</name>
<structname>EVTPARAM_CmpIoMgr</structname>
<category>Event parameter</category>
<element name="pConnectorList" type="IN">Pointer to connector list</element>
<element name="nCount" type="IN">Number of elements in connectors in list</element>
<rawdata>
typedef struct tagEVTPARAM_CmpIoMgr
{
	IoConfigConnector *pConnectorList;
	RTS_IEC_DINT nCount;
} EVTPARAM_CmpIoMgr;
</rawdata>
</element>
<element typedefinition="1">
<name>EVTPARAM_CmpIoMgrUpdateMapping</name>
<structname>EVTPARAM_CmpIoMgrUpdateMapping</structname>
<category>Event parameter</category>
<element name="pTaskMapList" type="IN">Pointer to task map list</element>
<element name="nCount" type="IN">Number of elements in map list</element>
<element name="pszConfigApplication" type="IN">Name of the mapping application</element>
<rawdata>
typedef struct
{
	IoConfigTaskMap *pTaskMapList;
	int nCount;
	char *pszConfigApplication;
} EVTPARAM_CmpIoMgrUpdateMapping;
</rawdata>
</element>
<element typedefinition="1">
<name>EVTPARAM_CmpIoMgrUpdateDiag</name>
<structname>EVTPARAM_CmpIoMgrUpdateDiag</structname>
<category>Event parameter</category>
<element name="hIoDrv" type="IN">Registered instance handle of the IO-driver</element>
<rawdata>
typedef struct
{
	RTS_HANDLE hIoDrv;
} EVTPARAM_CmpIoMgrUpdateDiag;
</rawdata>
</element>
<element function="1">
<functionname returntype="void" parameters="(iomgrstartbuscycle_struct *p)">iomgrstartbuscycle</functionname>
<description>IEC Interface for the function IoMgrStartBusCycle()</description>
</element>
<element function="1">
<functionname returntype="void" parameters="(iomgrupdateconfiguration2_struct *p)">iomgrupdateconfiguration2</functionname>
<description>IEC Interface for the function IoMgrUpdateConfiguration2()</description>
</element>
<element function="1">
<functionname returntype="void" parameters="(iomgrconfiggetconnector_struct *p)">iomgrconfiggetconnector</functionname>
<description>IEC Interface for the function IoMgrConfigGetConnector()</description>
</element>
<element function="1">
<functionname returntype="void" parameters="(iomgrconfiggetdriver_struct *p)">iomgrconfiggetdriver</functionname>
<description>
<p>This function behaves the same way as IoMgrConfigGetDriver() but
uses IEC handles instead of C handles instead.</p>
</description>
<param name="pConnector" type="IN" range="[NULL,VALID_CONNECTOR]">Pointer to connector</param>
<param name="pbIecDriver" type="OUT">Pointer to return if it is an Iec Driver</param>
<parampseudo name="pResult" type="OUT">Pointer to error code</parampseudo>
<result>Pointer to IBase interface</result>
<errorcode name="RTS_RESULT" type="ERR_OK">driver interface successfully retrieved</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">driver interface not retrieved</errorcode>
</element>
<element function="1">
<functionname returntype="void" parameters="(iomgrconfiggetconnectorlist_struct *p)">iomgrconfiggetconnectorlist</functionname>
<description>IEC Interface for the function IoMgrConfigGetConnectorList()</description>
</element>
<element function="1">
<functionname returntype="void" parameters="(iomgrconfiggetconnectorbydriver_struct *p)">iomgrconfiggetconnectorbydriver</functionname>
<description>IEC Interface for the function IoMgrConfigGetConnectorByDriver()</description>
</element>
<element function="1">
<functionname returntype="void" parameters="(iomgrconfiggetfirstconnector_struct *p)">iomgrconfiggetfirstconnector</functionname>
<description>IEC Interface for the function IoMgrConfigGetFirstConnector()</description>
</element>
<element function="1">
<functionname returntype="void" parameters="(iomgrconfigsetdiagnosis_struct *p)">iomgrconfigsetdiagnosis</functionname>
<description>IEC Interface for the function IoMgrConfigSetDiagnosis()</description>
</element>
<element function="1">
<functionname returntype="void" parameters="(iomgrreadparameter_struct *p)">iomgrreadparameter</functionname>
<description>IEC Interface for the function IoMgrReadParameter()</description>
</element>
<element function="1">
<functionname returntype="void" parameters="(iomgrwatchdogtrigger_struct *p)">iomgrwatchdogtrigger</functionname>
<description>IEC Interface for the function IoMgrWatchdogTrigger()</description>
</element>
<element function="1">
<functionname returntype="void" parameters="(iomgrconfigresetdiagnosis_struct *p)">iomgrconfigresetdiagnosis</functionname>
<description>IEC Interface for the function IoMgrConfigResetDiagnosis()</description>
</element>
<element function="1">
<functionname returntype="void" parameters="(iomgrconfiggetnextconnector_struct *p)">iomgrconfiggetnextconnector</functionname>
<description>IEC Interface for the function IoMgrConfigGetNextConnector()</description>
</element>
<element function="1">
<functionname returntype="void" parameters="(iomgrupdatemapping_struct *p)">iomgrupdatemapping</functionname>
<description>IEC Interface for the function IoMgrUpdateMapping()</description>
</element>
<element function="1">
<functionname returntype="void" parameters="(iomgrgetfirstdriverinstance_struct *p)">iomgrgetfirstdriverinstance</functionname>
<description>
<p>This function acts in the same way as IoMgrGetFirstDriverInstance(), but
uses IEC driver handles instead of C driver handles.</p>
</description>
</element>
<element function="1">
<functionname returntype="void" parameters="(iomgrregisterconfigapplication_struct *p)">iomgrregisterconfigapplication</functionname>
<description>IEC Interface for the function IoMgrRegisterConfigApplication()</description>
</element>
<element function="1">
<functionname returntype="void" parameters="(iomgrsetdriverproperties_struct *p)">iomgrsetdriverproperties</functionname>
<description>IEC Interface for the function IoMgrSetDriverProperties()</description>
</element>
<element function="1">
<functionname returntype="void" parameters="(iomgrsetdriverproperty_struct *p)">iomgrsetdriverproperty</functionname>
<description>IEC Interface for the function IoMgrSetDriverProperty()</description>
</element>
<element function="1">
<functionname returntype="void" parameters="(iomgrgetdriverproperties_struct *p)">iomgrgetdriverproperties</functionname>
<description>IEC Interface for the function IoMgrGetDriverProperties()</description>
</element>
<element function="1">
<functionname returntype="void" parameters="(iomgrconfiggetparametervaluepointer_struct *p)">iomgrconfiggetparametervaluepointer</functionname>
<description>IEC Interface for the function IoMgrConfigGetParameterValuePointer()</description>
</element>
<element function="1">
<functionname returntype="void" parameters="(iomgrscanmodules_struct *p)">iomgrscanmodules</functionname>
<description>IEC Interface for the function IoMgrScanModules()</description>
</element>
<element function="1">
<functionname returntype="void" parameters="(iomgrgetmodulediagnosis_struct *p)">iomgrgetmodulediagnosis</functionname>
<description>IEC Interface for the function IoMgrGetModuleDiagnosis()</description>
</element>
<element function="1">
<functionname returntype="void" parameters="(iomgrunregisterinstance_struct *p)">iomgrunregisterinstance</functionname>
<description>IEC Interface for the function IoMgrUnregisterInstance()</description>
</element>
<element function="1">
<functionname returntype="void" parameters="(iomgrconfiggetnextchild_struct *p)">iomgrconfiggetnextchild</functionname>
<description>IEC Interface for the function IoMgrConfigGetNextChild()</description>
</element>
<element function="1">
<functionname returntype="void" parameters="(iomgrconfiggetparameter_struct *p)">iomgrconfiggetparameter</functionname>
<description>IEC Interface for the function IoMgrConfigGetParameter()</description>
</element>
<element function="1">
<functionname returntype="void" parameters="(iomgrupdatemapping2_struct *p)">iomgrupdatemapping2</functionname>
<description>IEC Interface for the function IoMgrUpdateMapping2()</description>
</element>
<element function="1">
<functionname returntype="void" parameters="(iomgrwriteparameter_struct *p)">iomgrwriteparameter</functionname>
<description>IEC Interface for the function IoMgrWriteParameter()</description>
</element>
<element function="1">
<functionname returntype="void" parameters="(iomgrupdateconfiguration_struct *p)">iomgrupdateconfiguration</functionname>
<description>IEC Interface for the function IoMgrUpdateConfiguration()</description>
</element>
<element function="1">
<functionname returntype="void" parameters="(iomgrgetconfigapplication_struct *p)">iomgrgetconfigapplication</functionname>
<description>IEC Interface for the function IoMgrGetConfigApplication()</description>
</element>
<element function="1">
<functionname returntype="void" parameters="(iomgrconfiggetfirstchild_struct *p)">iomgrconfiggetfirstchild</functionname>
<description>IEC Interface for the function IoMgrConfigGetFirstChild()</description>
</element>
<element function="1">
<functionname returntype="void" parameters="(iomgrconfiggetparametervalueword_struct *p)">iomgrconfiggetparametervalueword</functionname>
<description>IEC Interface for the function IoMgrConfigGetParameterValueWord()</description>
</element>
<element function="1">
<functionname returntype="void" parameters="(iomgrwriteoutputs_struct *p)">iomgrwriteoutputs</functionname>
<description>IEC Interface for the function IoMgrWriteOutputs()</description>
</element>
<element function="1">
<functionname returntype="void" parameters="(iomgrconfiggetparametervaluebyte_struct *p)">iomgrconfiggetparametervaluebyte</functionname>
<description>IEC Interface for the function IoMgrConfigGetParameterValueByte()</description>
</element>
<element function="1">
<functionname returntype="void" parameters="(iomgrunregisterconfigapplication_struct *p)">iomgrunregisterconfigapplication</functionname>
<description>IEC Interface for the function IoMgrUnregisterConfigApplication()</description>
</element>
<element function="1">
<functionname returntype="void" parameters="(iomgrregisterinstance2_struct *p)">iomgrregisterinstance2</functionname>
<description>IEC Interface for the function IoMgrRegisterInstance2()</description>
<param name="p" type="IN" range="[VALID_REGISTERINSTANCE_STRUCT]">IBase interface of the IO-driver</param>
</element>
<element function="1">
<functionname returntype="void" parameters="(iomgrreadinputs_struct *p)">iomgrreadinputs</functionname>
<description>IEC Interface for the function IoMgrReadInputs()</description>
</element>
<element function="1">
<functionname returntype="void" parameters="(iomgrconfiggetparametervaluedword_struct *p)">iomgrconfiggetparametervaluedword</functionname>
<description>IEC Interface for the function IoMgrConfigGetParameterValueDWord()</description>
</element>
<element function="1">
<functionname returntype="void" parameters="(iomgridentify_struct *p)">iomgridentify</functionname>
<description>IEC Interface for the function IoMgrIdentify()</description>
</element>
<element function="1">
<functionname returntype="void" parameters="(iomgrgetnextdriverinstance_struct *p)">iomgrgetnextdriverinstance</functionname>
<description>
<p>This function acts in the same way as IoMgrGetNextDriverInstance(), but
uses IEC driver handles instead of C driver handles.</p>
</description>
<description>IEC Interface for the function IoMgrGetNextDriverInstance()</description>
</element>
<element function="1">
<functionname returntype="void" parameters="(iomgrcopyinputbe_struct *p)">iomgrcopyinputbe</functionname>
<description>IEC Interface for the function IoMgrCopyInputBE()</description>
</element>
<element function="1">
<functionname returntype="void" parameters="(iomgrcopyinputle_struct *p)">iomgrcopyinputle</functionname>
<description>IEC Interface for the function IoMgrCopyInputLE()</description>
</element>
<element function="1">
<functionname returntype="void" parameters="(iomgrcopyoutputbe_struct *p)">iomgrcopyoutputbe</functionname>
<description>IEC Interface for the function IoMgrCopyOutputBE()</description>
</element>
<element function="1">
<functionname returntype="void" parameters="(iomgrcopyoutputle_struct *p)">iomgrcopyoutputle</functionname>
<description>IEC Interface for the function IoMgrCopyOutputLE()</description>
</element>
<element function="1">
<functionname returntype="void" parameters="(iomgrconfiggetiodriver_struct *p)">iomgrconfiggetiodriver</functionname>
<description>IEC Interface for the function IoMgrConfigGetIoDriver()</description>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char *pszApplication, RTS_UI32 ulException)">IoMgrExceptionHandler</functionname>
<description>Exception handler of the IO-manager</description>
<param name="pszApplication" type="IN">Pointer to the specified application name, in which the exception was generated</param>
<param name="ulException" type="IN">Exception number of the exception. See SysExceptItf.h for details.</param>
<errorcode name="RTS_RESULT" type="ERR_OK">This function never fails</errorcode>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(IBase *pIBase, RTS_RESULT *pResult)">IoMgrRegisterInstance</functionname>
<description>
<p>This function has the same behavior as IoMgrRegisterInstance2() but
is not able to handle IEC drivers</p>
</description>
<param name="pIBase" type="IN">IBase interface of the IO-driver</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<errorcode name="RTS_RESULT" type="ERR_OK">Driver was successfully registered</errorcode>
<errorcode name="RTS_RESULT" type="ERR_NOTINITIALIZED">No driver pool was found</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">pIBase was NULL or bIecDriver was set but not supported</errorcode>
<errorcode name="RTS_RESULT" type="ERR_NOMEMORY">There was no space left in the device pool</errorcode>
<result>Handle to the registered instance</result>
</element>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(IBase *pIBase, int bIecDriver, RTS_RESULT *pResult)">IoMgrRegisterInstance2</functionname>
<description>
<p>Register an instance of an IO-driver.</p>
<p>This function registers C as well as IEC drivers in a common
device pool.</p>
</description>
<param name="pIBase" type="IN" range="[NULL,VALID_IBASE]">IBase interface of the IO-driver</param>
<param name="bIecDriver" type="IN" range="[0,1]">Specifies if IBase describes a C or an IEC driver</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<parampseudo name="bException" type="OUT">Exception occured, because MemPool is full</parampseudo>
<parampseudo name="DevicePool" type="IN" range="[VALID_MEMPOOL,FULL_MEMPOOL]">State of MemPool</parampseudo>
<errorcode name="RTS_RESULT" type="ERR_OK">Driver was successfully registered</errorcode>
<errorcode name="RTS_RESULT" type="ERR_NOTINITIALIZED">No driver pool was found</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">pIBase was NULL or bIecDriver was set but not supported</errorcode>
<errorcode name="RTS_RESULT" type="ERR_NOMEMORY">There was no space left in the device pool</errorcode>
<result>Handle to the registered driver instance</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(IBase *pIBase)">IoMgrUnregisterInstance</functionname>
<description>
<p>Unregister an instance of an IO-driver</p>
<p>Note: For SIL2, this function is only allowed in debug mode, or from a safe context in safety mode.</p>
</description>
<param name="pIBase" type="IN" range="[NULL,VALID_IBASE,INVALID_IBASE]">IBase interface of the IO-driver</param>
<parampseudo name="SIL2ModeDebug" type="IN" range="[0,1]">SIL2 safety mode</parampseudo>
<parampseudo name="bException" type="OUT">Exception occured, not allowed in safety mode</parampseudo>
<errorcode name="RTS_RESULT" type="ERR_OK">Driver retrieved successfully</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">Parameter invalid</errorcode>
<errorcode name="RTS_RESULT" type="ERR_NO_OBJECT">Driver could not be found</errorcode>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="IBase*" parameters="(int *pbIecDriver, RTS_RESULT *pResult)">IoMgrGetFirstDriverInstance</functionname>
<description>Get first registered driver instance</description>
<param name="pbIecDriver" type="INOUT" range="[NULL,VALID_PBIECDRIVER]">Pointer to return, if the instance is an IEC- or C-driver:
1= pIBase is an interface of an IEC-driver, 0= C-driver</param>
<parampseudo name="bIecDriver" type="IN" range="[0,1]">If the instance is an IEC- or C-driver</parampseudo>
<param name="pResult" type="OUT">Pointer to error code</param>
<errorcode name="RTS_RESULT" type="ERR_OK">Driver retrieved successfully</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">Parameter invalid</errorcode>
<errorcode name="RTS_RESULT" type="ERR_NO_OBJECT">Driver could not be found</errorcode>
<result>Handle to the first instance</result>
</element>
<element function="1">
<functionname returntype="IBase*" parameters="(IBase *pIBasePrev, int *pbIecDriver, RTS_RESULT *pResult)">IoMgrGetNextDriverInstance</functionname>
<description>Get the next registered driver instance</description>
<param name="pIBasePrev" type="IN" range="[NULL,VALID_PIBASEPREV,INVALID_PIBASEPREV]">Pointer to IBase of the previous interface</param>
<param name="pbIecDriver" type="INOUT" range="[NULL,VALID_PBIECDRIVER]">Pointer to return, if the instance is an IEC- or C-driver:
<parampseudo name="bIecDriver" type="IN" range="[0,1]">If the instance is an IEC- or C-driver</parampseudo>
1= pIBase is an interface of an IEC-driver, 0= C-driver</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<errorcode name="RTS_RESULT" type="ERR_OK">Driver retrieved successfully</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">Parameter invalid</errorcode>
<errorcode name="RTS_RESULT" type="ERR_NO_OBJECT">Driver could not be found</errorcode>
<result>Handle to the first instance</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(IBase *pIBase, RTS_UI32 ulProperties)">IoMgrSetDriverProperties</functionname>
<description>
<p>Set the properties of a driver.</p>
<p>This function overwrites all existing properties of the driver.</p>
</description>
<param name="pIBase" type="IN" range="[NULL,VALID_IBASE]">Pointer to IBase interface of the driver</param>
<param name="ulProperties" type="IN" range="[0,VALID_PROPERTIES]">Properties of the driver. See category "Driver property flags" for detailed information.</param>
<result>error code</result>
<errorcode name="RTS_RESULT" type="ERR_OK">Properties where successfully overwritten</errorcode>
<errorcode name="RTS_RESULT" type="ERR_FAILED">Driver could not be found</errorcode>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(IBase *pIBase, RTS_UI32 **ppulProperty)">IoMgrGetDriverProperties</functionname>
<description>
<p>Get a pointer to the properties of a driver.</p>
</description>
<param name="pIBase" type="IN" range="[NULL,VALID_IBASE]">Pointer to IBase interface of the driver</param>
<param name="ppulProperty" type="INOUT" range="[NULL,VALID_PROPERTY_POINTER]">Pointer will point to the properties of the driver.</param>
<result>error code</result>
<errorcode name="RTS_RESULT" type="ERR_OK">Pointer to properties was returned successfully</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">pIBase or ppulProperty was NULL</errorcode>
<errorcode name="RTS_RESULT" type="ERR_NO_OBJECT">No driver found</errorcode>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(IBase *pIBase, RTS_UI32 ulProperty, int bValue)">IoMgrSetDriverProperty</functionname>
<description>
<p>Modify a Property Bitfield of a driver.</p>
<p>The bits in the mask ulProperty are set or reset, depending on the value of bValue.</p>
</description>
<param name="pIBase" type="IN" range="[NULL,VALID_IBASE]">Pointer to IBase interface of the driver</param>
<param name="bValue" type="IN" range="[0,1]">Value to set.</param>
<param name="ulProperty" type="IN" range="[0,VALID_PROPERTY]">Property of the driver. See category "Driver property flags" for detailed information.</param>
<result>error code</result>
<errorcode name="RTS_RESULT" type="ERR_OK">The Property was successfully set</errorcode>
<errorcode name="RTS_RESULT" type="ERR_FAILED">Driver could not be found</errorcode>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char *pszConfigApplication)">IoMgrRegisterConfigApplication</functionname>
<description>
<p>Register the name of the application that contains the IO-configuration.</p>
</description>
<param name="pszConfigApplication" type="IN" range="[NULL,VALID_CONFIGAPP_NAME]">Pointer to the name of the IO-config application</param>
<parampseudo name="pszRegisteredConfigApplication" type="IN" range="[NULL,VALID_CONFIGAPP_NAME,INVALID_CONFIGAPP_NAME]">Registered Config Application</parampseudo>
<result>error code</result>
<errorcode name="RTS_RESULT" type="ERR_OK">The config application was registered</errorcode>
<errorcode name="RTS_RESULT" type="ERR_DUPLICATE">Another application is already registered</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">pszConfigApplication was NULL</errorcode>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char *pszConfigApplication)">IoMgrUnregisterConfigApplication</functionname>
<description>
<p>Unregister the name of the application that contains the IO-configuration.</p>
</description>
<param name="pszConfigApplication" type="IN" range="[NULL,VALID_CONFIGAPP]">Pointer to the name of the IO-config application</param>
<result>error code</result>
<errorcode name="RTS_RESULT" type="ERR_OK">The config application was unregistered</errorcode>
<errorcode name="RTS_RESULT" type="ERR_FAILED">The application is not the registered config application</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">pszConfigApplication was NULL</errorcode>
<parampseudo name="pszRegisteredConfigApplication" type="IN" range="[NULL,VALID_REGISTERED_CONFIGAPP]">Registered Config Application</parampseudo>
<parampseudo name="bException" type="OUT">SIL2 Runtime: Exception if not in Debug Mode</parampseudo>
<parampseudo name="bSIL2SafeMode" type="IN" range="[0,1]">SIL2 Runtime: SIL2 OpMode</parampseudo>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char *pszConfigApplication, int *pnMaxLen)">IoMgrGetConfigApplication</functionname>
<description>
<p>Return the name of the application that contains the I/O configuration.</p>
<p>If the parameter pszConfigApplication is NULL, only the size of the string is returned.</p>
</description>
<param name="pszConfigApplication" type="IN" range="[NULL,VALID_CONFIGAPP]">Pointer to get the name of the IO-config application</param>
<param name="pnMaxLen" type="INOUT" range="[NULL,VALID_CONFIGAPP_LENGTH]">IN: size of pszConfigApplication, OUT: Size of config application if psz</param>
<parampseudo name="pszRegisteredConfigApplication" type="IN" range="[NULL,VALID_REGISTERED_CONFIGAPP]">Registered Config Application</parampseudo>
<errorcode name="RTS_RESULT" type="ERR_OK">The config application was retrieved successfully</errorcode>
<errorcode name="RTS_RESULT" type="ERR_NO_OBJECT">No config application registered</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">pnMaxLen was NULL</errorcode>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(IoConfigConnector *pConnectorList, int nCount)">IoMgrUpdateConfiguration</functionname>
<description>
<p>Interface to inform all IO-drivers about a new IO-configuration.</p>
<p>On initialization, the parameter pConnectorList describes the
whole I/O configuration of the IEC application.</p>
<p>On Reset or deletion of the application, this function is called,
too, but then with the parameter pConnectorList set to NULL.</p>
<p>Note: When an I/O driver returns ERR_EXCEPTION, the I/O Manager puts
the application into an exception state. All other errors are just, logged.</p>
<p>Note2: On SIL2 runtimes, any error code that is returned by the I/O
driver, leads to an exception.</p>
</description>
<param name="pConnectorList" type="IN" range="[NULL,VALID_CONNECTORLIST]">Pointer to the complete connector list of the IO-configuration</param>
<param name="nCount" type="INOUT" range="[0,VALID_CONNECTORCOUNT]">Number of connectors in the connector list</param>
<result>error code</result>
<errorcode name="RTS_RESULT" type="ERR_OK">Update Configuration of all drivers was successfull</errorcode>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(IoConfigConnector *pConnectorList, int nCount, char *pszConfigApplication)">IoMgrUpdateConfiguration2</functionname>
<description>
<p>Interface to inform all IO-drivers about a new IO-configuration.</p>
<p>On initialization, the parameter pConnectorList describes the
whole I/O configuration of the IEC application.</p>
<p>On Reset or deletion of the application, this function is called,
too, but then with the parameter pConnectorList set to NULL.</p>
<p>Note: When an I/O driver returns ERR_EXCEPTION, the I/O Manager puts
the application into an exception state. All other errors are just, logged.</p>
<p>Note2: On SIL2 runtimes, any error code that is returned by the I/O
driver, leads to an exception.</p>
</description>
<param name="pConnectorList" type="IN" range="[NULL,VALID_CONNECTORLIST]">Pointer to the complete connector list of the IO-configuration</param>
<param name="nCount" type="IN" range="[0,VALID_CONNECTORCOUNT]">Number of connectors in the connector list</param>
<param name="pszConfigApplication" type="IN" range="[NULL,VALID_CONFIGAPP]">Pointer to the application name in which context this function is called</param>
<parampseudo name="bUpdateConfigFailed" type="IN" range="[0,1]">Pointer to the application name in which context this function is called</parampseudo>
<parampseudo name="bException" type="OUT">Exception is thrown as UpdateConfiguration failed</parampseudo>
<result>error code</result>
<errorcode name="RTS_RESULT" type="ERR_OK">Update Configuration of all drivers was successfull</errorcode>
<errorcode name="RTS_RESULT" type="ERR_FAILED">Update Configuration of at least one driver failed</errorcode>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(IoConfigTaskMap *pTaskMapList, int nCount)">IoMgrUpdateMapping</functionname>
<description>
<p>Interface to inform all IO-drivers about a new IO-mapping.</p>
</description>
<param name="pTaskMapList" type="IN" range="[NULL,VALID_TASKMAPLIST,INVALID_TASKMAPLIST]">Pointer to the complete task map list</param>
<param name="nCount" type="INOUT" range="[0,VALID_TASKMAPCOUNT,INVALID_TASKMAPCOUNT]">Number of task map entries in the list</param>
<result>error code</result>
<errorcode name="RTS_RESULT" type="ERR_OK">All registered drivers where informed about the change</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">pTaskMapList may not be NULL</errorcode>
<errorcode name="RTS_RESULT" type="ERR_FAILED">Update Mapping of at least one driver failed</errorcode>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(IoConfigTaskMap *pTaskMapList, int nCount, char *pszConfigApplication)">IoMgrUpdateMapping2</functionname>
<description>
<p>Interface to inform all IO-drivers about a new IO-mapping.</p>
<p>Note: When an I/O driver returns ERR_EXCEPTION, the I/O Manager puts
the application into an exception state. All other errors are just, logged.</p>
<p>Note2: On SIL2 runtimes, any error code that is returned by the I/O
driver, leads to an exception.</p>
</description>
<param name="pTaskMapList" type="IN" range="[NULL,VALID_TASKMAPLIST,INVALID_TASKMAPLIST]">Pointer to the complete task map list</param>
<param name="nCount" type="IN" range="[0,VALID_TASKMAPCOUNT]">Number of task map entries in the list</param>
<param name="pszConfigApplication" type="IN" range="[NULL,VALID_CONFIGAPP]">Pointer to the application name in which context this function is called</param>
<parampseudo name="dwTaskId" type="IN" range="[0,1,NUM_OF_STATIC_IEC_TASKS]">Exception is thrown if Taskmap is corrupted, or TaskId invalid</parampseudo>
<parampseudo name="bException" type="OUT">Exception is thrown if Taskmap is corrupted, or TaskId invalid</parampseudo>
<parampseudo name="bUpdateMappingFailed" type="IN" range="[0,1]">UpdateMapping Failed in IoDriver</parampseudo>
<result>error code</result>
<errorcode name="RTS_RESULT" type="ERR_OK">All registered drivers where informed about the change</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">pTaskMapList may not be NULL</errorcode>
<errorcode name="RTS_RESULT" type="ERR_FAILED">Update Mapping of at least one driver failed</errorcode>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(IoConfigTaskMap *pTaskMap)">IoMgrReadInputs</functionname>
<description>
<p>Interface to perform an update of all inputs of one task.</p>
<p>This function is called once out of each IEC-task, in which inputs are referenced.
This call is passed to every I/O driver that is used by this task.</p>
<p>Throws Exception if dwDriverSpecific is 0.</p>
</description>
<param name="pTaskMap" type="IN" range="[NULL,VALID_TASKMAP,INVALID_TASKMAP]">Pointer to the task map, which references all input channels of the task</param>
<parampseudo name="hIoDrv" type="IN" range="[NULL,VALID_TASKMAP_IBASE]">hIoDrv May be NULL</parampseudo>
<parampseudo name="dwIoMgrSpecific" type="IN" range="[0,1]">dwIoMgrSpecific contains a valid cound or not</parampseudo>
<parampseudo name="IsCalled" type="OUT">Is Testdriver called or not</parampseudo>
<parampseudo name="bException" type="OUT">Exception thrown</parampseudo>
<result>error code</result>
<errorcode name="RTS_RESULT" type="ERR_OK">All registered drivers where called</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">TaskMap may not be null</errorcode>
<errorcode name="RTS_RESULT" type="ERR_FAILED">dwDriverSpecific may not be 0</errorcode>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(IoConfigTaskMap *pTaskMap)">IoMgrWriteOutputs</functionname>
<description>
<p>Interface to perform an update of all outputs of one task.</p>
<p>This function is called once out of each IEC-task, in which outputs are referenced.
This call is passed to every I/O driver that is used by this task.</p>
<p>Throws Exception if dwDriverSpecific is 0.</p>
</description>
<param name="pTaskMap" type="IN" range="[NULL,VALID_TASKMAP,INVALID_TASKMAP]">Pointer to the task map, which references all output channels of the task</param>
<parampseudo name="hIoDrv" type="IN" range="[NULL,VALID_TASKMAP_IBASE]">hIoDrv May be NULL</parampseudo>
<parampseudo name="dwIoMgrSpecific" type="IN" range="[0,1]">dwIoMgrSpecific contains a valid cound or not</parampseudo>
<parampseudo name="bFlowControlError" type="IN" range="[0,1]">Error in FlowControl</parampseudo>
<parampseudo name="IsCalled" type="OUT">Is Testdriver called or not</parampseudo>
<parampseudo name="bException" type="OUT">Exception thrown</parampseudo>
<result>error code</result>
<errorcode name="RTS_RESULT" type="ERR_OK">All registered drivers where called</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">TaskMap may not be null</errorcode>
<errorcode name="RTS_RESULT" type="ERR_FAILED">dwDriverSpecific may not be 0</errorcode>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(IoConfigConnector *pConnector)">IoMgrStartBusCycle</functionname>
<description>
<p>This function is deprecated. Newer versions of the iostandard library,
are using IoMgrStartBusCycle2.</p>
</description>
<param name="pConnector" type="IN" range="[NULL,VALID_CONNECTOR_1,INVALID_CONNECTOR]">Pointer to the connector that needs a bus cycle</param>
<errorcode name="RTS_RESULT" type="ERR_OK">All registered drivers where called</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">pConnector may not be null</errorcode>
<errorcode name="RTS_RESULT" type="ERR_FAILED">No Driver found</errorcode>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(IoConfigConnector *pConnector, RTS_UI32 dwType)">IoMgrStartBusCycle2</functionname>
<description>
<p>This function is called for every connector that has the setting "needs bus cycle"
in the device description. It is only called once and only from the context of the
so called "buscycle task". This task can be specified globally (= default for all
drivers), or specifically for every driver.</p>
<p>The parameter dwType defines if the function was calle at the beginning
or at the end of the IEC task cycle. This value, can actively be requested
by the driver, by calling IoMgrGetBusCycleType().</p>
</description>
<param name="pConnector" type="IN" range="[NULL,VALID_CONNECTOR_1,INVALID_CONNECTOR]">Pointer to the connector that needs a bus cycle</param>
<param name="dwType" type="IN" range="[BCT_START,BCT_END]">Type of the bus cycle</param>
<errorcode name="RTS_RESULT" type="ERR_OK">All registered drivers where called</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">pConnector may not be null</errorcode>
<errorcode name="RTS_RESULT" type="ERR_FAILED">No Driver found</errorcode>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(IoConfigConnector *pConnector, RTS_RESULT *pResult)">IoMgrGetBusCycleType</functionname>
<description>
<p>This function can be called by the I/O driver, within the function
IoDrvStartBusCycle, to determine if this bus cycle was called at the
beginning or at the end of a task cycle.</p>
<p>Note: When this function is called when an application is loaded, that
uses an older version of the iostandard library, the function will return
ERR_FAILED, as the caller context can't be determined.</p>
</description>
<param name="pConnector" type="IN" range="[NULL,VALID_CONNECTOR_1,INVALID_CONNECTOR]">Pointer to the connector that got the bus cycle</param>
<param name="pResult" type="OUT">Pointer to the error code</param>
<errorcode name="RTS_RESULT" type="ERR_OK">The current type was returned successfully</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">pConnector was null, or didn't contain a valid driver handle</errorcode>
<errorcode name="RTS_RESULT" type="ERR_FAILED">The function was called outside of IoDrvStartBuscycle or the iostandard library was too old</errorcode>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(IoConfigConnector *pConnector, IoConfigConnector **ppConnectorList, int *pnCount)">IoMgrScanModules</functionname>
<description>
<p>Interface to scan submodule on the specified connector.</p>
<p>This interface is optional and may not be implemented by the runtime system.</p>
</description>
<param name="pConnector" type="IN" range="[NULL,VALID_CONNECTOR]">Pointer to connector</param>
<param name="ppConnectorList" type="OUT" range="[NULL,VALID_CONNECTORLIST]">List of submodule connectors</param>
<param name="pnCount" type="OUT" range="[NULL,VALID_CONNECTORCOUNT_P,INVALID_CONNECTORCOUNT_P]">Pointer to elements in the connector list</param>
<parampseudo name="SIL2OpModeSafe" type="IN" range="[0,1]">Is not allowed in SIL2 Mode</parampseudo>
<parampseudo name="bException" type="OUT">Exception if in Safe Mode</parampseudo>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(IoConfigConnector *pConnector)">IoMgrGetModuleDiagnosis</functionname>
<description>
<p>Get diagnostic flags of specified connector.</p>
</description>
<param name="pConnector" type="IN" range="[NULL,VALID_CONNECTOR,INVALID_CONNECTOR]">Pointer to connector</param>
<result>error code</result>
<errorcode name="RTS_RESULT" type="ERR_OK">Diagnostic flags could be read</errorcode>
<errorcode name="RTS_RESULT" type="ERR_FAILED">Diagnostic info could not be read</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">pConnector may not be null</errorcode>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(IoConfigConnector *pConnector)">IoMgrIdentify</functionname>
<description>
<p>Interface to identify a device specified by connector.</p>
<p>This can be used for example to blink a LED on the device to identify it physically.</p>
</description>
<param name="pConnector" type="IN" range="[NULL,VALID_CONNECTOR,INVALID_CONNECTOR]">Pointer to connector</param>
<parampseudo name="SIL2OpModeSafe" type="IN" range="[0,1]">Is not allowed in SIL2 Mode</parampseudo>
<parampseudo name="bException" type="OUT">Exception if in Safe Mode</parampseudo>
<result>error code</result>
<errorcode name="RTS_RESULT" type="ERR_OK">This error code is passed directly from the driver.</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">pConnector may not be null.</errorcode>
<errorcode name="RTS_RESULT" type="ERR_FAILED">Driver returned ERR_FAILED or driver not found</errorcode>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(IoConfigConnector *pConnector)">IoMgrNominate</functionname>
<description>Interface to nominate a device specified by connector. Nomination can be used for example
for ProfiNET devices to configure their IP-addresses.</description>
<param name="pConnector" type="IN">Pointer to connector</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(IoConfigConnector *pConnector)">IoMgrWatchdogTrigger</functionname>
<description>
<p>If enabled in the device description, this function is called periodically to
trigger some kind of hardware watchdog.</p>
</description>
<param name="pConnector" type="IN" range="[NULL,VALID_CONNECTOR_1]">Pointer to the connector of the device</param>
<errorcode name="RTS_RESULT pResult" type="ERR_OK">Watchdog triggered successfully</errorcode>
<errorcode name="RTS_RESULT pResult" type="ERR_NOT_SUPPORTED">Function is not implemented on this target</errorcode>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="IoConfigParameter*" parameters="(IoConfigConnector *pConnector, RTS_UI32 dwParameterId)">IoMgrConfigGetParameter</functionname>
<description>
<p>Interface to get a parameter on a specified connector specified by ID</p>
</description>
<param name="pConnector" type="IN" range="[NULL,VALID_CONNECTOR,INVALID_CONNECTOR]">Pointer to connector</param>
<param name="dwParameterId" type="IN" range="[VALID_PARAMETERID,INVALID_PARAMETERID]">ID of the parameter. Is defined in the device description.</param>
<parampseudo name="bException" type="OUT">Exception occured for Invalid Connector</parampseudo>
<result>Parameter or NULL if failed</result>
</element>
<element function="1">
<functionname returntype="RTS_UI32" parameters="(IoConfigParameter *pParameter, RTS_RESULT *pResult)">IoMgrConfigGetParameterValueDword</functionname>
<description>
<p>Interface to get the DWORD value out of the specified parameter</p>
</description>
<param name="pParameter" type="IN" range="[NULL,VALID_PARAMETER_DWORD,INVALID_PARAMETER]">Pointer to the parameter</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<parampseudo name="bException" type="OUT">Exception occured for Invalid Parameter</parampseudo>
<result>Value of the parameter or 0 if failed. Please check always pResult additionally!</result>
<errorcode name="RTS_RESULT pResult" type="ERR_OK">Value was read successfully</errorcode>
<errorcode name="RTS_RESULT pResult" type="ERR_PARAMETER">pParameter was NULL or Parameter has not the value flag</errorcode>
</element>
<element function="1">
<functionname returntype="unsigned short" parameters="(IoConfigParameter *pParameter, RTS_RESULT *pResult)">IoMgrConfigGetParameterValueWord</functionname>
<description>
<p>Interface to get the WORD value out of the specified parameter</p>
</description>
<param name="pParameter" type="IN" range="[NULL,VALID_PARAMETER_WORD,INVALID_PARAMETER]">Pointer to the parameter</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<parampseudo name="bException" type="OUT">Exception occured for Invalid Parameter</parampseudo>
<result>Value of the parameter or 0 if failed. Please check always pResult additionally!</result>
<errorcode name="RTS_RESULT pResult" type="ERR_OK">Value was read successfully</errorcode>
<errorcode name="RTS_RESULT pResult" type="ERR_PARAMETER">pParameter was NULL or Parameter has not the value flag</errorcode>
</element>
<element function="1">
<functionname returntype="unsigned char" parameters="(IoConfigParameter *pParameter, RTS_RESULT *pResult)">IoMgrConfigGetParameterValueByte</functionname>
<description>
<p>Interface to get the BYTE value out of the specified parameter</p>
</description>
<param name="pParameter" type="IN" range="[NULL,VALID_PARAMETER_BYTE,INVALID_PARAMETER]">Pointer to the parameter</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<parampseudo name="bException" type="OUT">Exception occured for Invalid Parameter</parampseudo>
<result>Value of the parameter or 0 if failed. Please check always pResult additionally!</result>
<errorcode name="RTS_RESULT pResult" type="ERR_OK">Value was read successfully</errorcode>
<errorcode name="RTS_RESULT pResult" type="ERR_PARAMETER">pParameter was NULL or Parameter has not the value flag</errorcode>
</element>
<element function="1">
<functionname returntype="void *" parameters="(IoConfigParameter *pParameter, RTS_RESULT *pResult)">IoMgrConfigGetParameterValuePointer</functionname>
<description>
<p>Interface to get the POINTER to the value out of the specified parameter</p>
</description>
<param name="pParameter" type="IN" range="[NULL,VALID_PARAMETER_POINTER,INVALID_PARAMETER]">Pointer to the parameter</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<parampseudo name="bException" type="OUT">Exception occured for Invalid Parameter</parampseudo>
<result>Pointer to the value or NULL if failed. Please check always pResult additionally!</result>
<errorcode name="RTS_RESULT pResult" type="ERR_OK">Value was read successfully</errorcode>
<errorcode name="RTS_RESULT pResult" type="ERR_PARAMETER">pParameter was NULL or Parameter has not the value flag</errorcode>
</element>
<element function="1">
<functionname returntype="IoConfigConnector*" parameters="(IoConfigConnector *pConnectorList, int *pnCount, unsigned short wType)">IoMgrConfigGetFirstConnector</functionname>
<description>
<p>Get the first connector with the specified wType in the connector list.</p>
<p>pnCount is decreased and contains the rest of elements still remaining in list.</p>
</description>
<param name="pConnectorList" type="IN" range="[NULL,VALID_CONNECTORLIST,INVALID_CONNECTORLIST]">Pointer to connector list</param>
<param name="pnCount" type="INOUT" range="[NULL,VALID_CONNECTORCOUNT_P]">Pointer to number of elements in list</param>
<param name="wType" type="IN" range="[0,VALID_MODULE_TYPE]">Type of the connector</param>
<parampseudo name="bException" type="OUT">Exception if Connectorlist is invalid</parampseudo>
<result>Pointer to the connector or NULL if not found</result>
</element>
<element function="1">
<functionname returntype="IoConfigConnector*" parameters="(IoConfigConnector *pConnectorList, int *pnCount, unsigned short wType)">IoMgrConfigGetNextConnector</functionname>
<description>
<p>Get the next connector with the specified wType in the connector list.</p>
<p>pnCount is decreased and contains the rest of elements still remaining in list.</p>
</description>
<param name="pConnectorList" type="IN" range="[NULL,VALID_CONNECTORLIST,INVALID_CONNECTORLIST]">Pointer to connector list</param>
<param name="pnCount" type="INOUT" range="[NULL,VALID_CONNECTORCOUNT_P]">Pointer to number of elements in list</param>
<param name="wType" type="IN" range="[0,VALID_MODULE_TYPE]">Type of the connector</param>
<parampseudo name="bException" type="OUT">Exception if Connectorlist is invalid</parampseudo>
<result>Pointer to the connector or NULL if not found</result>
</element>
<element function="1">
<functionname returntype="IoConfigConnector*" parameters="(IoConfigConnector *pConnectorList, int *pnCount, IoConfigConnector *pFather)">IoMgrConfigGetFirstChild</functionname>
<description>
<p>Get the first child connector of the specified father connector.</p>
<p>pnCount is decreased and contains the rest of elements still remaining in list.</p>
</description>
<param name="pConnectorList" type="IN" range="[NULL,VALID_CONNECTORLIST,INVALID_CONNECTORLIST]">Pointer to connector list</param>
<param name="pnCount" type="INOUT" range="[NULL,VALID_CONNECTORCOUNT_P]">Pointer to number of elements in list</param>
<param name="pFather" type="IN" range="[NULL,VALID_PARENTCONNECTOR,INVALID_PARENTCONNECTOR]">Pointer to the father connector</param>
<parampseudo name="bException" type="OUT">Exception at Connectorlist check</parampseudo>
<result>Pointer to the child connector or NULL if not found</result>
</element>
<element function="1">
<functionname returntype="IoConfigConnector*" parameters="(IoConfigConnector *pConnectorList, int *pnCount, IoConfigConnector *pFather)">IoMgrConfigGetNextChild</functionname>
<description>
<p>Get the next child connector of the specified father connector.</p>
<p>pnCount is decreased and contains the rest of elements still remaining in list.</p>
</description>
<param name="pConnectorList" type="IN" range="[NULL,VALID_CONNECTORLIST,INVALID_CONNECTORLIST]">Pointer to connector list</param>
<param name="pnCount" type="INOUT" range="[NULL,VALID_CONNECTORCOUNT_P]">Pointer to number of elements in list</param>
<param name="pFather" type="IN" range="[NULL,VALID_PARENTCONNECTOR,INVALID_PARENTCONNECTOR]">Pointer to the father connector</param>
<parampseudo name="bException" type="OUT">Exception at Connectorlist check</parampseudo>
<result>Pointer to the child connector or NULL if not found</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(IoConfigConnector **ppConnectorList, int *pnCount)">IoMgrConfigGetConnectorList</functionname>
<description>
<p>Get the actual IO-configuration in form of the connector list.</p>
<p>If the parameter ppConnectorList is NULL, only the size of the list will be returned.</p>
</description>
<parampseudo name="RegisteredConnectorList" type="IN"  range="[NULL,VALID_CONNECTORLIST,INVALID_CONNECTORLIST]">Registered Pointer to connector list</parampseudo>
<param name="ppConnectorList" type="OUT">Pointer to connector list</param>
<parampseudo name="bException" type="OUT">Exception if Connectorlist is invalid</parampseudo>
<param name="pnCount" type="INOUT"  range="[NULL,VALID_CONNECTORCOUNT_P]">Number of elements in the list</param>
<result>error code</result>
<errorcode name="RTS_RESULT" type="ERR_OK">There was a list registered and at least the size could be returned</errorcode>
<errorcode name="RTS_RESULT" type="ERR_FAILED">Registered list was corrupted</errorcode>
<errorcode name="RTS_RESULT" type="ERR_NO_OBJECT">No list was registered, yet</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">pnCount was NULL</errorcode>
</element>
<element function="1">
<functionname returntype="IoConfigConnector*" parameters="(IoConfigConnector *pConnectorList, int *pnCount, RTS_UI32 ulModuleType, RTS_UI32 ulInstance)">IoMgrConfigGetConnector</functionname>
<description>
<p>Get the connector specified by ModuleType and ModuleInstance number</p>
<p>pnCount is decreased and contains the rest of elements, still remaining in list! </p>
<p>Might be called with NULL as Connectorlist, then the Connectorlist and pnCount from the last call to UpdateConfiguration is used </p>
<p>Returns NULL if pnCount is NULL, if ulInstance is greater than nCount, no fitting Connector with given Instance and Type is found or (if pConnectorList is Null, the last stored ConnectorList is also NULL) </p>
</description>
<param name="pConnectorList" type="IN" range="[NULL,VALID_CONNECTORLIST,INVALID_CONNECTORLIST]">Pointer to connector list</param>
<param name="pnCount" type="INOUT" range="[NULL,VALID_CONNECTORCOUNT_P_P,INVALID_CONNECTORCOUNT_P_P]">Number of elements in the list</param>
<param name="ulModuleType" type="IN" range="[0,VALID_MODULE_TYPE]">Module type</param>
<param name="ulInstance" type="IN" range="[0,VALID_INSTANCE_COUNT,INVALID_INSTANCE_COUNT]">Instance number</param>
<parampseudo name="Exception" type="OUT">Exception may be thrown if problem occurs while checking Connectorlist</parampseudo>
<result>Pointer to found connector or NULL</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(IoConfigConnector *pConnector, RTS_UI32 ulFlags)">IoMgrConfigSetDiagnosis</functionname>
<description>
<p>Interface to set the diagnostic flags in the connector.</p>
<p>Only the bits that are specified with 1 in the passed ulFlags parameter
will be set.</p>
</description>
<param name="pConnector" type="IN" range="[NULL,VALID_CONNECTOR,INVALID_CONNECTOR]">Pointer to connector</param>
<param name="ulFlags" type="IN" range="[0x0001,0x0010,0x0020,0x0040,0x0080,0x0100,0x0200,0x0400,0x0800]">Flags to write</param>
<parampseudo name="bException" type="OUT">Exception caused by INVALID_CONNECTOR</parampseudo>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(IoConfigConnector *pConnector, RTS_UI32 ulFlags)">IoMgrConfigResetDiagnosis</functionname>
<description>
<p>Interface to reset the diagnostic flags in the connector.</p>
<p>Only the bits that are specified with 1 in the passed ulFlags parameter
will be resetted.</p>
</description>
<param name="pConnector" type="IN" range="[NULL,VALID_CONNECTOR,INVALID_CONNECTOR]">Pointer to connector</param>
<param name="ulFlags" type="IN" range="[0x0001,0x0010,0x0020,0x0040,0x0080,0x0100,0x0200,0x0400,0x0800]">Flags to write</param>
<parampseudo name="bException" type="OUT">Exception caused by INVALID_CONNECTOR</parampseudo>
<result>error code</result>
<errorcode name="RTS_RESULT" type="ERR_OK">Diagnostic flags set successfully</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">pConnector was NULL or not consistent</errorcode>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_UI32 ulModuleType, RTS_UI32 ulInstance, RTS_UI32 ulParameterId, void *pData, RTS_SIZE ulBitSize, RTS_SIZE ulBitOffset)">IoMgrReadParameter</functionname>
<description>
<p>Interface to read a specified parameter.</p>
<p>This interface is optional and may not be implemented by the runtime system.</p>
</description>
<param name="ulModuleType" type="IN" range="[0,VALID_MODULE_TYPE]">Module type</param>
<param name="ulInstance" type="IN" range="[0,VALID_INSTANCE_COUNT,INVALID_INSTANCE_COUNT]">Instance number</param>
<param name="ulParameterId" type="IN" range="[VALID_PARAMETERID_1,INVALID_PARAMETERID_1]">ID of the parameter. Is defined in the device description.</param>
<param name="pData" type="IN" range="[NULL,VALID_PDATA]">Pointer to read in the parameter value</param>
<param name="ulBitSize" type="IN" range="[0,VALID_BITSIZE]">Bits to read</param>
<param name="ulBitOffset" type="IN" range="[0,VALID_BITOFFSET]">Bitoffset of the parameter value</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_UI32 ulModuleType, RTS_UI32 ulInstance, RTS_UI32 ulParameterId, void *pData, RTS_SIZE ulBitSize, RTS_SIZE ulBitOffset)">IoMgrWriteParameter</functionname>
<description>
<p>Interface to write a specified parameter.</p>
<p>This interface is optional and may not be implemented by the runtime system.</p>
</description>
<param name="ulModuleType" type="IN" range="[0,VALID_MODULE_TYPE]">Module type</param>
<param name="ulInstance" type="IN" range="[0,VALID_INSTANCE_COUNT,INVALID_INSTANCE_COUNT]">Instance number</param>
<param name="ulParameterId" type="IN" range="[VALID_PARAMETERID_1,INVALID_PARAMETERID_1]">ID of the parameter. Is defined in the device description.</param>
<param name="pData" type="IN" range="[NULL,VALID_PDATA]">Pointer to the parameter write value</param>
<param name="ulBitSize" type="IN" range="[0,VALID_BITSIZE]">Bits to write</param>
<param name="ulBitOffset" type="IN" range="[0,VALID_BITOFFSET]">Bitoffset of the parameter value</param>
<parampseudo name="bSafetyMode" type="IN" range="[0,1]">According to SIL2 Mode this function may not be called</parampseudo>
<parampseudo name="bException" type="OUT">SIL2 Runtime: Exception is thrown if not in DebugMode</parampseudo>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="IBase *" parameters="(IoConfigConnector *pConnector, RTS_RESULT *pResult)">IoMgrConfigGetDriver</functionname>
<description>
<p>Return the registered driver interface of a connector</p>
</description>
<param name="pConnector" type="IN" range="[NULL,VALID_CONNECTOR_CDRIVER, VALID_CONNECTOR_IECDRIVER]">Pointer to connector</param>
<parampseudo name="bIecDriver_out" type="OUT">For ext function: If the instance is an IEC or C driver</parampseudo>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Pointer to IBase interface</result>
<errorcode name="RTS_RESULT" type="ERR_OK">driver interface successfully retrieved</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">driver interface not retrieved</errorcode>
</element>
<element function="1">
<functionname returntype="IoConfigConnector *" parameters="(IBase *pIBase, int nIndex, RTS_RESULT *pResult)">IoMgrConfigGetConnectorByDriver</functionname>
<description>
<p>Interface to get the connector of the driver specified by IBase interface</p>
<p>Note: This function is optional and not supported by CmpIoMgrEmbedded!</p>
</description>
<param name="pIBase" type="IN" range="[NULL,VALID_IBASE]">Pointer to IBase interface of the driver</param>
<param name="nIndex" type="IN" range="[RTS_RANGE_OF_INT]">Index of the connector</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Pointer to connector</result>
</element>
<element function="1">
<functionname returntype="void" parameters="(IoConfigChannelMap *pChannel, char *pAddress)">IoMgrCopyInputLE</functionname>
<description>
<p>Copy an Input from the Device to some local memory and swap to little endian if necessary.</p>
</description>
<param name="pChannel" type="IN" range="[NULL,VALID_COPINPUT_CHANNELMAP_1,VALID_COPINPUT_CHANNELMAP_2]">Pointer to one Channel Mapping</param>
<param name="pAddress" type="IN" range="[NULL,VALID_COPYINPUT_SRC]">Pointer to the Source Address</param>
</element>
<element function="1">
<functionname returntype="void" parameters="(IoConfigChannelMap *pChannel, char *pAddress)">IoMgrCopyInputBE</functionname>
<description>
<p>Copy an Input from the Device to some local memory and swap to big endian if necessary</p>
</description>
<param name="pChannel" type="IN" range="[NULL,VALID_COPINPUT_CHANNELMAP_1,VALID_COPINPUT_CHANNELMAP_2]">Pointer to one Channel Mapping</param>
<param name="pAddress" type="IN" range="[NULL,VALID_COPYINPUT_SRC]">Pointer to the Source Address</param>
</element>
<element function="1">
<functionname returntype="void" parameters="(IoConfigChannelMap *pChannel, char *pAddress)">IoMgrCopyOutputLE</functionname>
<description>
<p>Copy an Output from local memory to the Device and swap to little endian if necessary</p>
</description>
<param name="pChannel" type="IN" range="[NULL,VALID_COPINPUT_CHANNELMAP_1,VALID_COPINPUT_CHANNELMAP_2]">Pointer to one Channel Mapping</param>
<param name="pAddress" type="IN" range="[NULL,VALID_COPYOUTPUT_DST]">Pointer to the Destination Address</param>
</element>
<element function="1">
<functionname returntype="void" parameters="(IoConfigChannelMap *pChannel, char *pAddress)">IoMgrCopyOutputBE</functionname>
<description>
<p>Copy an Output from local memory to the Device and swap to big endian if necessary</p>
</description>
<param name="pChannel" type="IN" range="[NULL,VALID_COPINPUT_CHANNELMAP_1,VALID_COPINPUT_CHANNELMAP_2]">Pointer to one Channel Mapping</param>
<param name="pAddress" type="IN" range="[NULL,VALID_COPYOUTPUT_DST]">Pointer to the DestinationAddress</param>
</element>
</element>
</component>
<component>
<name>CmpLogEmbedded</name>
<description>
This component support to log all events and data in the runtime system
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element interface="1" name="CmpLogItf">
<interfacename>CmpLog</interfacename>
<description><p>Interface of the runtime system logger component.</p>

<p>The logger can log runtime system messages in form of strings, together
with some describing informations, like message categories and IDs.
The messages are saved in a local buffer in the RAM and uploaded to
the CoDeSys programming system or an external service tool on demand.</p>

<p>The embedded variant of this component does not support backends and
is therefore not able to save the log messages into a file.</p>

<p>Neither the log buffer in RAM, nor the communication medium are safe.
Therefore one can not essentially rely on the content of the log
messages. They can only be used for analytical purposes.</p>

<p>For runtimes with the define RTS_SIL2 defined, the component may be a
bit more limited. For example, no events are supported.</p>
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element define="1">
<name>LT_HIGHSPEED</name>
<key>UINT32_C</key>
<category>Log types</category>
<description>Types of a logger instance</description>
<element name="LT_HIGHSPEED" type="">Not supported</element>
<element name="LT_SAFE" type="">Not supported. Dump log entries in ring buffer residing in retain memory.</element>
<element name="LT_NORMAL" type="">Dump log entries in ring buffer residing in volatile memory (RAM)</element>
<element name="LT_TIMESTAMP_RTC" type="">Use realtime clock for the timestamp</element>
<element name="LT_TIMESTAMP_RTC_HIGHRES" type="">Use realtime clock with high resolution for the timestamp</element>
<element name="LT_TIMESTAMP_MS" type="">Use millisecond ticks for the timestamp</element>
<element name="LT_TIMESTAMP_US" type="">Use microsecond ticks for the timestamp</element>
<element name="LT_TIMESTAMP_NS" type="">Use nanosecond ticks for the timestamp</element>
<element name="LT_NO_DISABLE" type="">If this option is set, the logger cannot be disabled</element>
<element name="LT_DUMP_ASYNC" type="">Dump asynchronously in the backends</element>
<element name="LT_DUMP_ALWAYS" type="">Dump into the backends at every log entry</element>
<element name="LT_DUMP_ON_CLOSE" type="">Dump only the backends at closing the logger</element>
<element name="LT_DUMP_ON_REQUEST" type="">Dump can be done by calling LogDumpEntries()</element>
<element name="LT_DUMP_FORMAT2" type="">Dump with optional format 2. Is only recognized in the backends.</element>
<element name="LT_STD" type=""></element>
</element>
<element define="1">
<name>LOG_NONE</name>
<key>UINT32_C</key>
<category>Log class/filter</category>
<description>Log entry classes and filters</description>
<element name="LOG_NONE" type="No defined class"></element>
<element name="LOG_INFO" type="Information"></element>
<element name="LOG_WARNING" type="Warning"></element>
<element name="LOG_ERROR" type="Error"></element>
<element name="LOG_EXCEPTION" type="Exception"></element>
<element name="LOG_DEBUG" type="Debug log entries (reserved for development, diagnosis or test)"></element>
<element name="LOG_PRINTF" type="Debug log entries like printf. For this entry, no timestamp ist logged."></element>
<element name="LOG_COM" type="Communication"></element>
<element name="LOG_INFO_TIMESTAMP_RELATIVE" type="Information with timestamp relative to the previous entry"></element>
<element name="LOG_CRIT_SEC" type="Semaphore log entries"></element>
<element name="LOG_USER_NOTIFY" type="Log entries are displayed as a message box in CoDeSys"></element>
</element>
<element define="1">
<name>LOG_ALL</name>
<key>UINT32_MAX</key>
<category>Log filter</category>
<description>Log entry classes and filters</description>
<element name="LOG_NONE" type="LogFilter"></element>
</element>
<element define="1">
<name>USERDB_OBJECT_LOGGER</name>
<key>Device.Logger</key>
<category>Static defines</category>
<description>Predefined objects in the runtime</description>
</element>
<element define="1">
<name>LOG_STD_MAX_NUM_OF_ENTRIES</name>
<key>500</key>
<condition>LOG_STD_MAX_NUM_OF_ENTRIES</condition>
<category>Static defines</category>
<description>Default maximimum number of log entries in a logger instance</description>
</element>
<element define="1">
<name>LOG_STD_MAX_NUM_OF_FILES</name>
<key>3</key>
<condition>LOG_STD_MAX_NUM_OF_FILES</condition>
<category>Static defines</category>
<description>Default maximimum number of files for a logger with a file backend</description>
</element>
<element define="1">
<name>LOG_STD_MAX_FILE_SIZE</name>
<key>100000</key>
<condition>LOG_STD_MAX_FILE_SIZE</condition>
<category>Static defines</category>
<description>Default maximimum file size for a logger with a file backend</description>
</element>
<element define="1">
<name>LOG_MAX_INFO_LEN</name>
<key>128</key>
<condition>LOG_MAX_INFO_LEN</condition>
<category>Static defines</category>
<description>Maximimum lenght of the info string in a logger entry</description>
</element>
<element define="1">
<name>EVT_LogAdd</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent, after a new log entry added to the logger</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpLogAdd</param>
</element>
<element define="1">
<name>LOG_GET_ENTRIES</name>
<key>0x01</key>
<category>Online services</category>
<description>
Get all log entries
</description>
</element>
<element define="1">
<name>LOG_GET_COMPONENT_NAMES</name>
<key>0x02</key>
<category>Online services</category>
<description>
Get component name specified by component id
</description>
</element>
<element define="1">
<name>LOG_GET_LOGGER_LIST</name>
<key>0x03</key>
<category>Online services</category>
<description>
Get all registered logger names
</description>
</element>
<element define="1">
<name>TAG_LOGGER_NAME</name>
<key>0x01</key>
<category>Online service tags</category>
<description>
</description>
</element>
<element typedefinition="1">
<name>EVTPARAM_CmpLogAdd</name>
<structname>EVTPARAM_CmpLogAdd</structname>
<category>Event parameter</category>
<element name="pApp" type="IN">Pointer to application description</element>
<rawdata>
typedef struct
{
	RTS_HANDLE hLog;
	CMPID CmpId;
	RTS_I32 iClassID;
	RTS_RESULT iErrorID;
	RTS_I32 iInfoID;
	char *pszInfo;
	va_list *pargList;
} EVTPARAM_CmpLogAdd;
</rawdata>
</element>
<element typedefinition="1">
<name>LogOptions</name>
<structname>LogOptions</structname>
<SIL2/>
<category>Logger</category>
<description>Options of a logger (part of the configuration).</description>
<param name="szName" type="IN">Name of logger</param>
<param name="bEnable" type="IN">Logger active/inactive</param>
<param name="iType" type="IN">Logger type. See above log types.</param>
<param name="iFilter" type="IN">Filter for the logger entries to store. It is a combination of log classes</param>
<param name="iMaxEntries" type="IN">Max number of possible log entries</param>
<param name="iMaxFileSize" type="IN">Max file size, if logger content is stored in a file</param>
<param name="iMaxFiles" type="IN">Max number of files, if logger content is stored in a file</param>
<param name="pszPath" type="IN">Optional path for the logger file</param>
<rawdata>
typedef struct tagLogOptions
{
	char szName[32];
	RTS_I32 bEnable;
	RTS_I32 iType;
	RTS_I32 iFilter;
	RTS_I32 iMaxEntries;
	RTS_I32 iMaxFileSize;
	RTS_I32 iMaxFiles;
	char *pszPath;
} LogOptions;
</rawdata>
</element>
<element typedefinition="1">
<name>LogEntry</name>
<structname>LogEntry</structname>
<SIL2/>
<category>Logger</category>
<description>One logger Entry, including the message.</description>
<rawdata>
typedef struct tagLogEntry
{
	LogTimestamp tTimestamp;
	CMPID CmpId;
	RTS_UI32 iClassID;
	RTS_RESULT iErrorID;
	RTS_UI32 iInfoID;
	char szInfo[LOG_MAX_INFO_LEN];
} LogEntry;
</rawdata>
</element>
<element typedefinition="1">
<name>LogItf</name>
<structname>LogItf</structname>
<SIL2/>
<category>Logger</category>
<description>Backend interface of one logger.</description>
<rawdata>
typedef struct
{
	ICmpLogBackend *pIBackend;
	CLASSID ClassId;
	RTS_HANDLE hLogBackend;
	RTS_I32 iLastDumpedIndex;
} LogItf;
</rawdata>
</element>
<element typedefinition="1">
<name>Logger</name>
<structname>Logger</structname>
<SIL2/>
<category>Logger</category>
<description>Configuration of one logger.</description>
<rawdata>
typedef struct
{
	LogOptions lo;
	RTS_UI32 ulStartTimestamp;
	RTS_I32 iIndex;
	RTS_I32 iFirstIndex;
	RTS_I32 iRegInterfaces;
	RTS_I32 iDumpSync;
	LogEntry *pLog;
	LogItf tLogItf[LOG_DEFAULT_NUM_OF_ITF];
} Logger;
</rawdata>
</element>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(LogOptions *pOptions,  RTS_RESULT *pResult)">LogCreate</functionname>
<description> Create a logger </description>
<param name="pOptions" type="IN">Options for logger</param>
<param name="pResult" type="OUT">Pointer to get the result</param>
<result>Handle to the logger, or RTS_INVALID_HANDLE if failed</result>
</element>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(char *pszName, RTS_RESULT *pResult)">LogOpen</functionname>
<description> Open a logger with the specified name. Logger must exist! </description>
<param name="pszName" type="IN">Logger name</param>
<param name="pResult" type="OUT">Pointer to get the result</param>
<result>Handle to the logger, or RTS_INVALID_HANDLE if logger does not exist</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hLog)">LogClose</functionname>
<description> Close the handle to a logger </description>
<param name="hLog" type="IN">Handle to logger</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hLog)">LogDelete</functionname>
<description> Delete a logger </description>
<param name="hLog" type="IN">Handle to logger</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hLog, LogOptions **ppOptions)">LogGetOptions</functionname>
<description> Get options of logger </description>
<param name="hLog" type="IN">Handle to logger</param>
<param name="ppOptions" type="OUT">Pointer to pointer to log options</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hLog)">LogEnable</functionname>
<description> Enable logging </description>
<param name="hLog" type="IN">Handle to logger</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hLog)">LogDisable</functionname>
<description> Disable logging </description>
<param name="hLog" type="IN">Handle to logger</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hLog, RTS_I32 iFilter)">LogSetFilter</functionname>
<description> Set filter of logger </description>
<param name="hLog" type="IN">Handle to logger</param>
<param name="iFilter" type="IN">Logger filter</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_I32" parameters="(RTS_HANDLE hLog)">LogGetFilter</functionname>
<description> Get filter of logger</description>
<param name="hLog" type="IN">Handle to logger</param>
<result> Filter </result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hLog, CMPID CmpId, RTS_I32 iClassID, RTS_RESULT iErrorID, RTS_I32 iInfoID, char *pszInfo, ...)">LogAdd</functionname>
<description>
<p>Add a new log entry to the log buffer.</p>

<p>If the buffer is full when this function is called, the oldest
log entry in the buffer will be overwritten.</p>

<p>If the Class ID contains LOG_INFO_TIMESTAMP_RELATIVE, there is an additional
tag, called "TimeRel" added to the text of the log entry. This will
limit the message size of the entry by the size of this tag.</p>

<p>If the Class ID contains the flag LOG_USER_NOTIFY, the log message
will be shown in form of a message box at the next log in of
CoDeSys or instantly if CoDeSys is still loged in.</p>

<p>The interface supports a minimum of 8 variable arguments. Depending
on the C-Library, this might be more.</p>
<p>LT_TIMESTAMP_RTC, LT_TIMESTAMP_RTC_HIGHRES is not supported in SIL2 Runtime.</p>
</description>
<param name="hLog" type="IN" range="[RTS_INVALID_HANDLE,STD_LOGGER]">Handle to logger</param>
<param name="CmpId" type="IN" range="[VALID_CMPID]">Component id</param>
<param name="iClassID" type="IN" range="[LOG_ALL,LOG_NONE,LOG_ALL_NOT_LOG_USER_NOTIFY,LOG_ALL_NOT_LOG_INFO_TIMESTAMP_RELATIVE]">ClassID of entry (Info, Warning, Error, etc.)</param>
<param name="iErrorID" type="IN" range="[VALID_IERRORID]">Error code if available</param>
<param name="iInfoID" type="IN" range="[VALID_IINFOID]">ID of info text to enable multiple language error texts</param>
<param name="pszInfo" type="IN" range="[NULL,VALID_PSZINFO]">String to info text (in english or informations coded in XML)</param>
<parampseudo name="_iFilterID" type="IN" range="[LOG_ALL,LOG_ALL_NOT_LOG_USER_NOTIFY,LOG_ALL_NOT_LOG_INFO_TIMESTAMP_RELATIVE]">Filter option</parampseudo>
<parampseudo name="_iType_Timestamp" type="IN" range="[LT_TIMESTAMP_MS,LT_TIMESTAMP_US,LT_TIMESTAMP_NS]">Logger Type Timestamp</parampseudo>
<parampseudo name="_bAddedEntry" type="OUT">Entry Added to Log</parampseudo>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">Invalid logger handle</errorcode>
<errorcode name="RTS_RESULT" type="ERR_FAILED">iClassID was filtered for this logger or Logger is not enabled,</errorcode>
<errorcode name="RTS_RESULT" type="ERR_NOMEMORY">Configured memory for log buffer could not be allocated</errorcode>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hLog, CMPID CmpId, RTS_I32 iClassID, RTS_RESULT iErrorID, RTS_I32 iInfoID, char *pszInfo, va_list *pargList)">LogAddArg</functionname>
<description>
<p>Add a new log entry to the log buffer.</p>

<p>The behavior is the same as the behavior of "LogAdd()", except that the
parameter is a pointer to a variable argument list instead of a direct
variable argument list, passed to the function.</p>
</description>
<param name="hLog" type="IN" range="[RTS_INVALID_HANDLE,STD_LOGGER]">Handle to logger</param>
<param name="CmpId" type="IN" range="[VALID_CMPID]">Component id</param>
<param name="iClassID" type="IN" range="[LOG_ALL,LOG_NONE]">ClassID of entry (Info, Warning, Error, etc.)</param>
<param name="iErrorID" type="IN" range="[VALID_IERRORID]">Error code if available</param>
<param name="iInfoID" type="IN" range="[VALID_IINFOID]">ID of info text to enable multiple language error texts</param>
<param name="pszInfo" type="IN" range="[NULL,VALID_PSZINFO_1,VALID_PSZINFO_MAX]">String to info text (in english or informations coded in XML)</param>
<param name="pargList" type="IN" range="[NULL,VALID_PARGLIST]">Pointer to argument list, format is specified in pszInfo</param>
<parampseudo name="_bAddedEntry" type="OUT">Entry Added to Log</parampseudo>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">Invalid logger handle</errorcode>
<errorcode name="RTS_RESULT" type="ERR_FAILED">iClassID was filtered for this logger or Logger is not enabled,</errorcode>
<errorcode name="RTS_RESULT" type="ERR_NOMEMORY">Configured memory for log buffer could not be allocated</errorcode>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(int iOptions)">LogDumpAll</functionname>
<description> Dump all entries from all log files </description>
<param name="iOptions" type="IN"><p>One or multiple of the following options:</p>
<ul>
<li>LT_DUMP_ASYNC: If dump is done from an asychronous event</li>
<li>LT_DUMP_ALWAYS: If dump should be forced (always)</li>
<li>LT_DUMP_ON_CLOSE: If dump is called from closing the logger instance</li>
<li>LT_DUMP_ON_REQUEST: If dump is forced from a request</li>
</ul>
</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hLog)">LogDumpEntries</functionname>
<description> Dump all entries from the last still dumped entry </description>
<param name="hLog" type="IN">Handle to the logger</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hLog, CLASSID ClassId, ICmpLogBackend *pIBackend)">LogRegisterInterface</functionname>
<description> Register a new logger interface </description>
<param name="hLog" type="IN">Handle to logger</param>
<param name="ClassId" type="IN">ClassID of the backend component</param>
<param name="pIBackend" type="IN">Pointer to the backend interface</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hLog, ICmpLogBackend *pIBackend)">LogUnregisterInterface</functionname>
<description> Unregister a logger interface </description>
<param name="hLog" type="IN">Handle to logger</param>
<param name="pIBackend" type="IN">Pointer to the backend interface</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(RTS_HANDLE hLog, int iIndex, LogEntry *pLogEntry, RTS_RESULT *pResult)">LogGetEntryByIndex</functionname>
<description> Get the first logentry of a logger </description>
<param name="hLog" type="IN">Handle to logger</param>
<param name="iIndex" type="IN">Index of entry to get. 0 is the first entry.</param>
<param name="pLogEntry" type="IN">Pointer to log entry</param>
<param name="pResult" type="IN">Pointer to result</param>
<result>Handle to next log entry or RTS_INVALID_HANDLE, if end of logger is reached</result>
</element>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(RTS_HANDLE hLog, int iQueueIndex, LogEntry *pLogEntry, RTS_RESULT *pResult)">LogGetEntryByQueueIndex</functionname>
<description> Get the first logentry of a logger </description>
<param name="hLog" type="IN">Handle to logger</param>
<param name="iQueueIndex" type="IN">Index of entry to get. -1 get the first entry.</param>
<param name="pLogEntry" type="IN">Pointer to log entry</param>
<param name="pResult" type="IN">Pointer to result</param>
<result>Handle to next log entry or RTS_INVALID_HANDLE, if end of logger is reached</result>
</element>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(RTS_HANDLE hLog, LogEntry *pLogEntry, RTS_RESULT *pResult)">LogGetFirstEntry</functionname>
<description> Get the first logentry of a logger </description>
<param name="hLog" type="IN">Handle to logger</param>
<param name="pLogEntry" type="IN">Pointer to log entry</param>
<param name="pResult" type="IN">Pointer to result</param>
<result>Handle to next log entry or RTS_INVALID_HANDLE, if end of logger is reached</result>
</element>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(RTS_HANDLE hLog, RTS_HANDLE hEntry, LogEntry *pLogEntry, RTS_RESULT *pResult)">LogGetNextEntry</functionname>
<description> Get the next logentry of a logger </description>
<param name="hLog" type="IN">Handle to logger</param>
<param name="hEntry" type="IN">Handle to log entry (is returned by LogGetFirstEntry or LogGetNextEntry)</param>
<param name="pLogEntry" type="IN">Pointer to log entry</param>
<param name="pResult" type="IN">Pointer to result</param>
<result>Handle to next log entry or RTS_INVALID_HANDLE, if end of logger is reached</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hLog, RTS_HANDLE hEntry, LogEntry *pLogEntry)">LogGetEntry</functionname>
<description> Get an entry specified by handle</description>
<param name="hLog" type="IN">Handle to logger</param>
<param name="hEntry" type="IN">Handle to log entry (is returned by LogGetFirstEntry or LogGetNextEntry)</param>
<param name="pLogEntry" type="IN">Pointer to log entry</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(RTS_RESULT *pResult)">LogGetFirstLogger</functionname>
<description>Get the first registered logger</description>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Handle to the first logger</result>
</element>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(RTS_HANDLE hLogger, RTS_RESULT *pResult)">LogGetNextLogger</functionname>
<description>Get the next registered logger</description>
<param name="hLogger" type="IN">Handle to previous logger</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Handle to the first logger</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hLog, char *pszLoggerName, int nMaxLen)">LogGetName</functionname>
<description>Get the logger name of the logger specified by handle</description>
<param name="hLogger" type="IN">Handle to the logger</param>
<param name="pszLogger" type="INOUT">Pointer to logger name</param>
<param name="nMaxLen" type="IN">Max length of pszLogger</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(LogEntry **ppLogEntryUserNotify)">LogGetUserNotify</functionname>
<description>Get the last log entry of class LOG_USER_NOTIFY</description>
<param name="ppLogEntryUserNotify" type="OUT">Returns the pointer to the user notify entry</param>
<result>Error code:
<ul>
<li>ERR_OK: There is still an unread log entry of the type LOG_USER_NOTIFY</li>
<li>ERR_NO_OBJECT: No pending log entry of the type LOG_USER_NOTIFY</li>
</ul>
</result>
</element>
</element>
</component>
<component>
<name>CmpMemPool</name>
<description>
System component that provides heap memory access.
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<p><h1>Compiler Switch</h1></p>
<ul>
<li>
<csdef>#define MEMPOOL_DISABLE_HEAP_MEMORY</csdef>
<csdesc>Switch to disable dynamic memory</csdesc>
<p></p>
</li>
</ul>
<element interface="1" name="CmpMemPoolItf">
<interfacename>CmpMemPool</interfacename>
<description>
<p>Interface of the memory pool manager to handle static and dynamic memory blocks</p>

<p>A MemPool has the following structure:</p>
<pre>
.
. -------------- Pool Control Block                -------------- Block Control Block
. |Blocksize   |  data size of single block        |nRefCount   |  Reference Counter
. |pBlocksInUse|  List of used blocks              |pBCB        |  Pointer to next BCB
. |pBCB        |  List of free blocks              |pPCB        |  Pointer to PCB
. |...         |                                   `------------'
. `-------------
.
.                      provided
.                      Memory Area
.                      .--------------------------.
.                      | PCB                      |
.   List of free Blocks|  Blocksize               |      List of used Blocks
.                      |  pBlocksInUse            |===========.
.         .=========== |  pBCB                    |           |
.         |            |......................... |           |
.         |            | BCB                      | &lt;========='
.         |            |                          | ---.
.         |            |......................... |    |
.         |            | DATA                     |    |
.         |            |                          |    |
.         |            |......................... |    |
.         |            | BCB                      | &lt;--'
.         |            |                          | ---.
.         |            |......................... |    |
.         |            | DATA                     |    |
.         |            |                          |    |
.         |            |......................... |    |
.         |            |                          | &lt;--'
.         |           ~~~                        ~~~
.         |
.         |           ~~~                        ~~~
.         '=========&gt;  |......................... |
.                      | BCB                      | ---.
.                      |                          |    |
.                      |......................... |    |
.                      | DATA                     |    |
.                      |                          |    |
.                      |......................... | &lt;--'
.                      | BCB                      | ---.
.                      |                          |    |
.                     ~~~                        ~~   ~~~
.
.                     ~~~                        ~~~
.                      |                          |
.                      |                          |
.                      .--------------------------.
.                      End of Memory Area
.
.
</pre>

</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element typedefinition="1">
<name></name>
/***************************************************************************
<rawdata>
typedef struct tagRTS_MEM_LIST_POOL RTS_MEM_LIST_POOL;
typedef struct tagRTS_MEM_LIST_POOL_BLOCK RTS_MEM_LIST_POOL_BLOCK;
typedef struct tagRTS_MEM_LIST_ELEMENT RTS_MEM_LIST_ELEMENT;

Single-linked list element.
struct tagRTS_MEM_LIST_ELEMENT
{
	RTS_MEM_LIST_ELEMENT* next;
};
</rawdata>
</element>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(char *pszComponentName, RTS_SIZE ulNumBlocks, RTS_SIZE ulBlockSize, RTS_RESULT *pResult)">MemPoolCreateDynamic</functionname>
<description>
Create a dynamic pool (consists of heap memory)
</description>
<param name="pszComponentName" type="IN">Component name</param>
<param name="ulBlockSize" type="IN">Size of each memory block in the pool</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Handle to the memory pool</result>
</element>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(RTS_SIZE ulBlockSize, RTS_SIZE ulMemSize, void* pMemory, RTS_RESULT *pResult)">MemPoolCreateStatic</functionname>
<description>
<p>Create a memory pool from a static memory buffer.</p>
<p>The memory buffer don't has to be aligned in a specific way. Therefore,
not all of the memory in the buffer might be used. To get the appropriate
additional buffer, the caller is recommended to use the macro
MEM_GET_STATIC_LEN(Num, Struct) to get the size of the buffer</p>
<p>For example:</p>
<pre>
typedef struct
{
...
} myStruct_s;

#define NUM_OF_STATIC_ELEMENTS 0x100

RTS_UI8 s_byMyStaticPool[MEM_GET_STATIC_LEN(NUM_OF_STATIC_ELEMENTS, myStruct_s);
</pre>
</description>
<param name="ulBlockSize" type="IN" range="[BLOCKSIZE_ALIGNED1,BLOCKSIZE_ALIGNED2,BLOCKSIZE_ALIGNED4,BLOCKSIZE_ALIGNED8]">Size of each memory block in the pool, misaligned to 1, 2, 4 or 8 bytes</param>
<param name="ulMemSize" type="IN" range="[MEMSIZE_INVALID,MEMSIZE_ALIGNED1,MEMSIZE_ALIGNED2,MEMSIZE_ALIGNED4,MEMSIZE_ALIGNED8]">Complete size of the static memory, misaligned to 1, 2, 4 or 8 bytes</param>
<param name="pMemory" type="IN" range="[NULL,VALID_MEM]">Pointer to the static memory</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<errorcode name="RTS_RESULT pResult" type="ERR_OK">MemPool created successfully</errorcode>
<errorcode name="RTS_RESULT pResult" type="ERR_PARAMETER">pMemory was NULL</errorcode>
<errorcode name="RTS_RESULT pResult" type="ERR_NOMEMORY">ulMemSize was not large enough, to hold at leaset one block</errorcode>
<result>Handle to the memory pool</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hMemPool, char *pszComponentName, RTS_SIZE ulNumBlocks)">MemPoolExtendDynamic</functionname>
<description>
Extend dynamic an existing pool
</description>
<param name="hMemPool" type="IN">Handle to the pool</param>
<param name="pszComponentName" type="IN">Component name</param>
<param name="ulNumBlocks" type="IN">Number of blocks to extend</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hMemPool, RTS_SIZE ulMemSize, void* pMemory)">MemPoolExtendStatic</functionname>
<description>
Extend an existing pool with a static array
</description>
<param name="hMemPool" type="IN">Handle to the pool</param>
<param name="ulMemSize" type="IN">Complete size of the static memory</param>
<param name="pMemory" type="IN">Pointer to the static memory</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hMemPool)">MemPoolCreateSyncObject</functionname>
<description>
Create the internal sync object for synchronizing the pool.
</description>
<param name="hMemPool" type="IN">Handle to the pool</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hMemPool)">MemPoolDeleteSyncObject</functionname>
<description>
Delete the internal sync object for synchronizing the pool.
</description>
<param name="hMemPool" type="IN">Handle to the pool</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hMemPool, char *pszComponentName)">MemPoolDelete</functionname>
<description>
Delete an existing pool
</description>
<param name="hMemPool" type="IN">Handle to the pool</param>
<param name="pszComponentName" type="IN">Component name</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hMemPool, char *pszComponentName, int bReleaseSemaphore)">MemPoolCleanup</functionname>
<description>
Cleanup the pool (delete all allocated heap pool objects)
</description>
<param name="hMemPool" type="IN">Handle to the pool</param>
<param name="pszComponentName" type="IN">Component name</param>
<param name="bReleaseSemaphore" type="IN">1=Pool semaphore is released, 0=Only cleanup</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="void*" parameters="(RTS_HANDLE hMemPool, RTS_RESULT *pResult)">MemPoolGetBlock</functionname>
<description>
<p>Get one memory block out of the pool.</p>
<p>SIL2 Implementation: If pPCB is wrong, an Exception is generated!</p>
</description>
<param name="hMemPool" type="IN" range="[RTS_INVALID_HANDLE,VALID_MEMPOOLHANDLE,INVALID_MEMPOOLHANDLE]">Handle to the pool</param>
<parampseudo name="hMemPool.NumEntries" type="IN" range="[0..NUM_OF_STATIC_ELEMENTS-1,NUM_OF_STATIC_ELEMENTS..INT_MAX]">Number of already allocated entries from the pool</parampseudo>
<param name="pResult" type="OUT">Pointer to error code</param>
<parampseudo name="bExceptionGenerated" type="OUT" range="[TRUE,FALSE]">specifies, if an exception was generated or not</parampseudo>
<errorcode name="RTS_RESULT pResult" type="ERR_OK">Retrieved free block from MemPool</errorcode>
<errorcode name="RTS_RESULT pResult" type="ERR_INVALID_HANDLE">No free block found</errorcode>
<result>Pointer to the memory block</result>
</element>
<element function="1">
<functionname returntype="void*" parameters="(RTS_HANDLE hMemPool, int bDynamic, char *pszComponentName, RTS_RESULT *pResult)">MemPoolGetBlock2</functionname>
<description>
Get one memory block out of the pool
</description>
<param name="hMemPool" type="IN">Handle to the pool</param>
<param name="bDynamic" type="IN">1=Block is created dynamically, if the pool is empty, 0=Only use of static pool memory</param>
<param name="pszComponentName" type="IN">Pointer to the component name for dynamic memory allocation</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Pointer to the memory block</result>
</element>
<element function="1">
<functionname returntype="RTS_PCB*" parameters="(RTS_HANDLE hMemPool, RTS_RESULT *pResult)">MemPoolGetPCB</functionname>
<description>
Get one the pool control block of a specified pool
</description>
<param name="hMemPool" type="IN">Handle to the pool</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Pointer to the pool control block</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(void* pBlock)">MemPoolPutBlock</functionname>
<description>
Put a memory block back into the pool (release). Now, the block is in the chain list of free blocks again.
</description>
<param name="pBlock" type="IN" range="[NULL,VALID_BLOCK,INVALID_BLOCK]">Pointer to the memory block</param>
<errorcode name="RTS_RESULT pResult" type="ERR_OK">Successfully added Block to MemPool</errorcode>
<errorcode name="RTS_RESULT pResult" type="ERR_PARAMETER">Could not add Block to MemPool, wrong pBlock</errorcode>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(void* pBlock)">MemPoolAddUsedBlock</functionname>
<description>
Add used block at the beginning of the pool. Now, the block is in the chain list of used blocks.
</description>
<param name="pBlock" type="IN" range="[NULL,VALID_BLOCK]">Pointer to the memory block</param>
<errorcode name="RTS_RESULT pResult" type="ERR_OK">Successfully added Block to MemPool</errorcode>
<errorcode name="RTS_RESULT pResult" type="ERR_PARAMETER">Could not add Block to MemPool, wrong pBlock</errorcode>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(void* pBlock)">MemPoolAppendUsedBlock</functionname>
<description>
Add used block at the end of the pool. Now, the block is in the chain list of used blocks.
</description>
<param name="pBlock" type="IN" range="[NULL,VALID_BLOCK]">Pointer to the memory block</param>
<errorcode name="RTS_RESULT pResult" type="ERR_OK">Successfully added Block to MemPool</errorcode>
<errorcode name="RTS_RESULT pResult" type="ERR_PARAMETER">Could not add Block to MemPool, wrong pBlock</errorcode>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(void* pPrevBlock, void* pBlock)">MemPoolInsertUsedBlock</functionname>
<description>
Insert used block right after the specified block or as a head element of an internal used blocks list.
</description>
<param name="pPrevBlock" type="IN" range="[NULL,VALID_PREVBLOCK,INVALID_PREVBLOCK]">Pointer to the predecessor block</param>
<param name="pBlock" type="IN" range="[NULL,VALID_BLOCK]">Pointer to the memory block</param>
<errorcode name="RTS_RESULT pResult" type="ERR_OK">Successfully inserted Block to MemPool</errorcode>
<errorcode name="RTS_RESULT pResult" type="ERR_PARAMETER">Could not insert Block to MemPool because pBlock is NULL or pPrevBlock belongs to a different pool than pBlock</errorcode>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(void* pBlock)">MemPoolRemoveUsedBlock</functionname>
<description>
Remove used block from the pool. Now, the block is removed from the chain list of used blocks.
</description>
<param name="pBlock" type="IN" range="[NULL,VALID_BLOCK]">Pointer to the memory block</param>
<errorcode name="RTS_RESULT pResult" type="ERR_OK">Successfully removed Block from MemPool</errorcode>
<errorcode name="RTS_RESULT pResult" type="ERR_PARAMETER">Could not remove Block from MemPool, wrong pBlock</errorcode>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(void* pBlock, RTS_HANDLE hPool)">MemPoolAddUsedBlockToPool</functionname>
<description>
Add used block the beginning of the specified pool. Now, the block is in the chain list of used blocks.
</description>
<param name="pBlock" type="IN">Pointer to the memory block</param>
<param name="hPool" type="IN">Handle to the pool</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(void* pBlock, RTS_HANDLE hPool)">MemPoolAppendUsedBlockToPool</functionname>
<description>
Add the block to the end of the used block list of hPool
</description>
<param name="pBlock" type="IN">Pointer to the memory block</param>
<param name="hPool" type="IN">Handle to the pool</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(void* pBlock, RTS_HANDLE hPool)">MemPoolRemoveUsedBlockFromPool</functionname>
<description>
Remove used block from the specified pool. Now, the block is removed from the chain list of used blocks.
</description>
<param name="pBlock" type="IN">Pointer to the memory block</param>
<param name="hPool" type="IN">Handle to the pool</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(void* pBlock)">MemPoolLockBlock</functionname>
<description>
Lock the access to a pool to be threadsafe.
</description>
<param name="pBlock" type="IN">Pointer to the memory block</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(void* pBlock)">MemPoolUnlockBlock</functionname>
<description>
Unlock the access to a pool.
</description>
<param name="pBlock" type="IN">Pointer to the memory block</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hMemPool)">MemPoolLock</functionname>
<description>
Lock the access to the complete pool. SIL2 Implementation is using INT Locks.
</description>
<param name="hMemPool" type="IN" range="[VALID_MEMPOOLHANDLE,NULL]">Handle to the memory pool</param>
<errorcode name="RTS_RESULT" type="ERR_OK">Pool was sucessfully locked</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">Parameter is wrong</errorcode>
<errorcode name="RTS_RESULT" type="ERR_FAILED">Pool could not be locked, SysInt or SysSem had problems</errorcode>
<errorcode name="RTS_RESULT" type="ERR_NOTIMPLEMENTED">SysInt or SysSem are not implemented</errorcode>
<errorcode name="RTS_RESULT" type="ERR_NOTINITIALIZED">Lock cannot be done before CH_INIT_SYSTEM, not relevant for SIL2</errorcode>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hMemPool)">MemPoolUnlock</functionname>
<description>
Unlock the access to the complete pool. SIL2 Implementation is using INT Locks.
</description>
<param name="hMemPool" type="IN" range="[VALID_MEMPOOLHANDLE,NULL]">Handle to the memory pool</param>
<errorcode name="RTS_RESULT" type="ERR_OK">Pool was sucessfully unlocked</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">Parameter is wrong</errorcode>
<errorcode name="RTS_RESULT" type="ERR_FAILED">Pool could not be unlocked, SysInt or SysSem had problems</errorcode>
<errorcode name="RTS_RESULT" type="ERR_NOTIMPLEMENTED">SysInt or SysSem are not implemented</errorcode>
<errorcode name="RTS_RESULT" type="ERR_NOTINITIALIZED">Unlock cannot be done before CH_INIT_SYSTEM, not relevant for SIL2</errorcode>
<result>Error code</result>
</element>
<element function="1">
<functionname returntype="void *" parameters="(RTS_HANDLE hMemPool, RTS_SIZE ulOffset, RTS_SIZE ulSize, void *pToFind, RTS_RESULT *pResult)">MemPoolFindBlock</functionname>
<description>
Find a block specified by a value, that is stored in the block.
</description>
<param name="hMemPool" type="IN">Handle to the memory pool</param>
<param name="ulOffset" type="IN">Byte offset of the value in the block to find</param>
<param name="ulSize" type="IN">Size in bytes of the value to find in the block</param>
<param name="pToFind" type="IN">Pointer to the value to find in the block</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Pointer to the memory block</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hMemPool, void *pBlock)">MemPoolIsValidBlock</functionname>
<description>
Check a pool memory block, if it is still valid and is not released.
NOTE:
If the check is successful, a lock is done on this pool!!! So you have to unlock this reference at the end of the usage with MemPoolUnlock()!
</description>
<param name="hMemPool" type="IN">Handle to the memory pool</param>
<param name="pBlock" type="IN">Pointer to the memory block</param>
<result>Error code</result>
</element>
<element function="1">
<functionname returntype="void*" parameters="(RTS_HANDLE hMemPool, RTS_RESULT *pResult)">MemPoolGetFirstBlock</functionname>
<description>
Get the first memory block out of the pool. Can be used for explicite iteration routines.
</description>
<param name="hMemPool" type="IN">Handle to the memory pool</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Pointer to first memory block</result>
</element>
<element function="1">
<functionname returntype="void*" parameters="(RTS_HANDLE hMemPool, void *pPrevBlock, RTS_RESULT *pResult)">MemPoolGetNextBlock</functionname>
<description>
Get the next memory block out of the pool. Can be used for explicite iteration routines.
</description>
<param name="hMemPool" type="IN">Handle to the memory pool</param>
<param name="pPrevBlock" type="IN">Pointer to previous memory block</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Pointer to next memory block</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_FIXED_BLOCKS_POOL* pPool, RTS_MEM_REGION* pRegion, RTS_SIZE block_size, RTS_SIZE blocks_number)">FixedBlocksPoolInit</functionname>
<description>
Initializes a pool for allocating objects of fixed size
</description>
<param name="pPool" type="IN">Pointer to a pool object</param>
<param name="pRegion" type="IN">Pointer to a region of memory that will be used for allocation</param>
<param name="block_size" type="IN">Size (in bytes) of a memory block</param>
<param name="blocks_number" type="IN">Number of blocks that should be located in a contiguous chunk</param>
<result>Error code</result>
</element>
<element function="1">
<functionname returntype="void*" parameters="(RTS_FIXED_BLOCKS_POOL* pPool, RTS_SIZE size, RTS_RESULT* pResult)">FixedBlocksPoolAlloc</functionname>
<description>
Allocates a memory block out of the pool
</description>
<param name="pPool" type="IN">Pointer to a pool object</param>
<param name="size" type="IN">Requested size of memory to be allocated. Should be less than the pPool block size</param>
<param name="pResult" type="OUT">Pointer to an error code</param>
<result>Pointer to the allocated block of memory</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_FIXED_BLOCKS_POOL* pPool, void* pMem)">FixedBlocksPoolFree</functionname>
<description>
Puts a memory block back to the pool.
</description>
<param name="pPool" type="IN">Pointer to a pool object</param>
<param name="pMem" type="IN">Pointer to a memory block to be returned to the pool</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_FIXED_BLOCKS_POOL* pPool)">FixedBlocksPoolReclaim</functionname>
<description>
Puts all the previously allocated memory blocks back to the pool.
</description>
<param name="pPool" type="IN">Pointer to a pool object</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_FIXED_BLOCKS_POOL* pPool)">FixedBlocksPoolDestroy</functionname>
<description>
Destroys a pool object.
</description>
<param name="pPool" type="IN">Pointer to a pool object</param>
<result>error code</result>
</element>
</element>
</component>
<component>
<name>CmpMonitor</name>
<description>This component realizes the monitoring of IEC variable values. This component handles
communication service of the group "SG_MONITORING". Therefore, the component registers a handler function
at the level 7 server component CmpSrv. The component supports monitoring of simple datatypes, including Bits.
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element interface="1" name="CmpMonitorItf">
<interfacename>CmpMonitor</interfacename>
<description>
Interface of the monitoring component, that provides monitoring of IEC variables.
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element define="1">
<name>SRV_MONITORLISTONCE</name>
<key>1</key>
<category>Online services</category>
<description></description>
</element>
<element define="1">
<name>MONITORING_FEATURE_COMPLEX_MONITORING</name>
<key>0x00000001</key>
<category>Features</category>
<type>Int</type>
<description>
Supported features of the monitoring component
</description>
</element>
<element define="1">
<name>EVT_PrepareWriteVariable</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent to prepare the write operation to a variable</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpMonitorWriteVar2</param>
</element>
<element define="1">
<name>EVT_WriteVariableDone</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent after the write operation to a variable was done</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpMonitorWriteVar</param>
</element>
<element define="1">
<name>EVT_PrepareForceVariable</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent to prepare the force of variable</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpMonitorForceVar2</param>
</element>
<element define="1">
<name>EVT_ForceVariableDone</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent after the force operation of a variable was done</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpMonitorForceVar</param>
</element>
<element typedefinition="1">
<name>EVTPARAM_CmpMonitorWriteVar</name>
<structname>EVTPARAM_CmpMonitorWriteVar</structname>
<category>Event parameter</category>
<element name="usSize" type="IN">Size of the variable</element>
<element name="dummy" type="IN">Alignment dummy</element>
<element name="pAddress" type="IN">Pointer to the variable value</element>
<element name="pValue" type="IN">Pointer to the write value</element>
<rawdata>
typedef struct
{
	RTS_UI16 usSize;
	RTS_UI16 dummy;
#ifdef TRG_64BIT
	RTS_UI32 dummy2;
#endif
	RTS_UI8* pAddress;
	void* pValue;
}
EVTPARAM_CmpMonitorWriteVar;
</rawdata>
</element>
<element typedefinition="1">
<name>EVTPARAM_CmpMonitorWriteVar2</name>
<structname>EVTPARAM_CmpMonitorWriteVar2</structname>
<category>Event parameter</category>
<element name="usSize" type="IN">Size of the variable</element>
<element name="dummy" type="IN">Alignment dummy</element>
<element name="pAddress" type="IN">Pointer to the variable value</element>
<element name="pValue" type="IN">Pointer to the write value</element>
<element name="bDeny" type="IN">1=Writing variable is denied, 0=Variable can be written</element>
<element name="cmpId" type="IN">ComponentID which denies this write operation</element>
<rawdata>
typedef struct
{
	RTS_UI16 usSize;
	RTS_UI16 dummy;
#ifdef TRG_64BIT
	RTS_UI32 dummy2;
#endif
	RTS_UI8* pAddress;
	void* pValue;
	RTS_I32 bDeny;
	CMPID cmpId;
}
EVTPARAM_CmpMonitorWriteVar2;
</rawdata>
</element>
<element typedefinition="1">
<name>EVTPARAM_CmpMonitorForceVar</name>
<structname>EVTPARAM_CmpMonitorForceVar</structname>
<category>Event parameter</category>
<element name="usForceFlag" type="IN">Force flags</element>
<element name="dummy" type="IN">Alignment dummy</element>
<element name="pDataRef" type="IN">Data description of the variable</element>
<element name="pAppl" type="IN">Pointer to the application description</element>
<rawdata>
typedef struct
{
	RTS_UI16 usForceFlag;
	RTS_UI16 dummy;
#ifdef TRG_64BIT
	RTS_UI32 dummy2;
#endif
	VarDataRef* pDataRef;
	APPLICATION* pAppl;
}
EVTPARAM_CmpMonitorForceVar;
</rawdata>
</element>
<element typedefinition="1">
<name>EVTPARAM_CmpMonitorForceVar2</name>
<structname>EVTPARAM_CmpMonitorForceVar2</structname>
<category>Event parameter</category>
<element name="usForceFlag" type="IN">Force flags</element>
<element name="dummy" type="IN">Alignment dummy</element>
<element name="pDataRef" type="IN">Data description of the variable</element>
<element name="pAppl" type="IN">Pointer to the application description</element>
<element name="pAddress" type="IN">Pointer to the variable value, if it is a simple data type (no property variable!)</element>
<element name="bDeny" type="IN">1=Writing variable is denied, 0=Variable can be written</element>
<element name="cmpId" type="IN">ComponentID which denies this write operation</element>
<rawdata>
typedef struct
{
	RTS_UI16 usForceFlag;
	RTS_UI16 dummy;
#ifdef TRG_64BIT
	RTS_UI32 dummy2;
#endif
	VarDataRef* pDataRef;
	APPLICATION* pAppl;
	RTS_UI8* pAddress;
	RTS_I32 bDeny;
	CMPID cmpId;
}
EVTPARAM_CmpMonitorForceVar2;
</rawdata>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(unsigned long ulFeatures)">MonitoringHasFeature</functionname>
<description>
Routine to check, if a scheduler has the specified feature.
</description>
<param name="ulFeatures" type="IN">Feature flags, See corresponding category "Features".</param>
<result>ERR_OK if the flags are supported, an error code otherwise</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION* pappl, BINTAGREADER* preader, RTS_UI8* pbyValue, RTS_UI16 usSize)">MonitoringReadValue</functionname>
<description>
Routine to read a value via a monitoring service.
Note: this function is equivalent to calling MonitoringReadValue2 with bIec = 0.
</description>
<param name="pappl" type="IN">Pointer to application.</param>
<param name="preader" type="IN">the reader specifying the location of the value to monitor.</param>
<param name="pbyValue" type="IN">pointer to the destination address were the retrieved value is written.</param>
<param name="usSize" type="IN">size of value to read.</param>
<result>ERR_OK if the value could be retrieved successfully</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION* pappl, BINTAGREADER* preader, RTS_UI8* pbyValue, RTS_UI16 usSize, int bIec)">MonitoringReadValue2</functionname>
<description>
Routine to read a value via a monitoring service.
</description>
<param name="pappl" type="IN">Pointer to application.</param>
<param name="preader" type="IN">the reader specifying the location of the value to monitor.</param>
<param name="pbyValue" type="IN">pointer to the destination address were the retrieved value is written.</param>
<param name="usSize" type="IN">size of value to read.</param>
<param name="bIec" type="IN">whether the call is done from an IEC task or not</param>
<result>ERR_OK if the value could be retrieved successfully</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION* pappl, BINTAGREADER* preader, RTS_UI8* pbyValue, RTS_UI16 usSize)">MonitoringWriteValue</functionname>
<description>
Routine to writa a value via a monitoring service.
Note: this function is equivalent to calling MonitoringWriteValue2 with bIec = 0.
</description>
<param name="pappl" type="IN">Pointer to application.</param>
<param name="preader" type="IN">the reader specifying the location of the value to write.</param>
<param name="pbyValue" type="IN">pointer to the source address of the value to write.</param>
<param name="usSize" type="IN">size of value to read.</param>
<result>ERR_OK if the value could be written successfully</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION* pappl, BINTAGREADER* preader, RTS_UI8* pbyValue, RTS_UI16 usSize, int bIec)">MonitoringWriteValue2</functionname>
<description>
Routine to writa a value via a monitoring service.
</description>
<param name="pappl" type="IN">Pointer to application.</param>
<param name="preader" type="IN">the reader specifying the location of the value to write.</param>
<param name="pbyValue" type="IN">pointer to the source address of the value to write.</param>
<param name="usSize" type="IN">size of value to read.</param>
<param name="bIec" type="IN">whether the call is done from an IEC task or not</param>
<result>ERR_OK if the value could be written successfully</result>
</element>
</element>
</component>
<component>
<name>CmpNameServiceServer</name>
<description>
Implements the naming services
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element interface="1" name="CmpNameServiceServerItf">
<interfacename>CmpNameServiceServer</interfacename>
<description>
External interface for the naming service server
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
</element>
</component>
<component>
<name>CmpRouter</name>
<description>
Implements the routing of packages on layer 3
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element interface="1" name="CmpRouterItf">
<interfacename>CmpRouter</interfacename>
<description>
Interface for the communication router component.
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element typedefinition="1">
<name>RTR_AddrComponent</name>
<structname>RTR_AddrComponent</structname>
<description>RTR_AddrComponent</description>
<rawdata>
typedef struct tagRTR_AddrComponent
{
	RTS_IEC_BYTE Component[2];
} RTR_AddrComponent;
</rawdata>
</element>
<element typedefinition="1">
<name>RTR_NodeAddress</name>
<structname>RTR_NodeAddress</structname>
<description>RTR_NodeAddress</description>
<rawdata>
typedef struct tagRTR_NodeAddress
{
	RTS_IEC_UDINT nAddrComponentCount;
	RTR_AddrComponent AddrComponents[15];
} RTR_NodeAddress;
</rawdata>
</element>
<element typedefinition="1">
<name>routergetinstancebyname_struct</name>
<structname>routergetinstancebyname_struct</structname>
<description>routergetinstancebyname</description>
<rawdata>
typedef struct tagroutergetinstancebyname_struct
{
	RTS_IEC_STRING *pstName;			VAR_INPUT
	RTS_IEC_UDINT *pResult;				VAR_INPUT
	RTS_IEC_BYTE *RouterGetInstanceByName;	VAR_OUTPUT
} routergetinstancebyname_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>routergetname_struct</name>
<structname>routergetname_struct</structname>
<description>routergetname</description>
<rawdata>
typedef struct tagroutergetname_struct
{
	RTS_IEC_BYTE *hRouter;				VAR_INPUT
	RTS_IEC_BYTE *pBuffer;				VAR_INPUT
	RTS_IEC_INT nBufferSize;			VAR_INPUT
	RTS_IEC_UDINT RouterGetName;		VAR_OUTPUT
} routergetname_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>routergethostaddress_struct</name>
<structname>routergethostaddress_struct</structname>
<description>routergethostaddress</description>
<rawdata>
typedef struct tagroutergethostaddress_struct
{
	RTS_IEC_BYTE *hRouter;				VAR_INPUT
	RTR_NodeAddress *resAddr;			VAR_IN_OUT
	RTS_IEC_UDINT RouterGetHostAddress;	VAR_OUTPUT
} routergethostaddress_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>routergetparentaddress_struct</name>
<structname>routergetparentaddress_struct</structname>
<description>routergetparentaddress</description>
<rawdata>
typedef struct tagroutergetparentaddress_struct
{
	RTS_IEC_BYTE *hRouter;				VAR_INPUT
	RTR_NodeAddress *resAddr;			VAR_IN_OUT
	RTS_IEC_UDINT RouterGetParentAddress;	VAR_OUTPUT
} routergetparentaddress_struct;
</rawdata>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(NETWORKINTERFACEINFO2 *pInterfaceInfo, RTS_HANDLE * phSubnet)">RouterRegisterNetworkInterface2</functionname>
/** <description>
Called by a blockdriver to register one of it's devices with the router. Allows also
to provide some block driver typ specific information.
</description>
<param name="pDeviceInfo" type="IN">Describes the device to register </param>
<param name="phSubnet" type="OUT">
Is set to the subnet handle that refers to this interface. The
blockdriver must provide this value in each call to
RouterHandleData or RouterUnregisterNetworkInterface.
</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(NETWORKINTERFACEINFO *pInterfaceInfo, RTS_HANDLE * phSubnet)">RouterRegisterNetworkInterface</functionname>
/** <description>
Called by a blockdriver to register one of it's devices with the router.
</description>
<param name="pDeviceInfo" type="IN">Describes the device to register </param>
<param name="phSubnet" type="OUT">
Is set to the subnet handle that refers to this interface. The
blockdriver must provide this value in each call to
RouterHandleData or RouterUnregisterNetworkInterface.
</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(NETWORKINTERFACEINFO *pInterfaceInfo, ONDEMANDNETWORKINTERFACE *pOnDemandInfo, RTS_HANDLE * phSubnet)">RouterRegisterOnDemandNWInterface</functionname>
/** <description>
At the moment pOnDemandInfo IS NOT USED by the CmpRouter!

Called by an on-demand blockdriver to register one of it's devices with the router. An on-demand blockdriver
is a blockdriver that is able to shutdown/open its connection on demand. Eg. for serial blockdrivers, so they
can release their hardware interface as long as it isn't needed and open it only, when their is data to be sent.
The blockdriver is supposed to be initially closed.
</description>
<param name="pDeviceInfo" type="IN">
Describes the device to register
</param>
<param name="pOnDemandInfo" type="IN">
Contains additional functions, that allow for opening and closing of the interface.
</param>
<param name="phSubnet" type="OUT">
Is set to the subnet handle that refers to this interface. The
blockdriver must provide this value in each call to
RouterHandleData or RouterUnregisterNetworkInterface.
</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hSubnet)">RouterUnregisterNetworkInterface</functionname>
/** <description>
Called by a blockdriver to unregister one of it's devices
</description>
<param name="hSubnet" type="IN">
Subnet handle of the interface, which should be unregistered.
</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE phSubnet, NETWORKADDRESS sender, PROTOCOL_DATA_UNIT pduData, int bIsBroadcast)">RouterHandleData</functionname>
/** <description>
Called whenever the blockdriver receives a valid data package
</description>
<param name="phSubnet" type="IN">
The subnetid assigned to the receiving device during RouterRegisterDevice
</param>
<param name="addrSender" type="IN">
The device address of the sender within the subnet
</param>
<param name="pduData" type="IN">The received data package</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(PROTOCOL_DATA_UNIT pduData, PEERADDRESS *pAddrReceiver, PEERADDRESS *pAddrSender, RTS_I32 *piDataOffset)">RouterGetBlkAddresses</functionname>
/** <description>
Called by a blockdriver to get the addresses of a data package.
</description>
<param name="pduData" type="IN">
Data package, from which the addresses should be read.
</param>
<param name="pAddrReceiver" type="OUT">
The function returns here the address of the receiver.
</param>
<param name="pAddrSender" type="OUT">
The function returns here the address of the sender.
</param>
<param name="piDataOffset" type="OUT">
If not NULL, the function returns here the offset (start) of the pay load. .
</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_BOOL" parameters="(PEERADDRESS *pAddr1, PEERADDRESS *pAddr2)">RouterCompareAddresses</functionname>
/** <description>
Called by a blockdriver to compare two peer addresses.
</description>
<param name="pAddr1" type="IN">
First address to compare
</param>
<param name="pAddr2" type="IN">
Second address to compare
</param>
<result>TRUE if the addresses are equal, else FALSE</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(int nProtocolId, PFPHHandleData pfPHHandleData)">RouterRegisterProtocolHandler</functionname>
/** <description>
A protocol handler calls this function to register itself with the router
The handler for the addressresolution protocol uses a specialized interface,
thus it is an error to register a handler for either PID_ADDRESSREQUEST or
PID_ADDRESSNOTIFICATION with this function.
</description>
<param name="protocolId" type="IN">The id of the protocol assigned to this handler</param>
<param name="pfPHHandleData" type="IN">
Pointer to the function to be called by the router whenever a package arrives
</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_UI16 usBlkDrvType, RTS_UI8 byNetworkAddressBitSize, NETWORKADDRESS *pNetworkAddr, NODEADDRESS *pNodeAddr)">RouterCalculateNodeAddr</functionname>
/** <description>
Let the router calculate the CoDeSys peer address of a node. This works only for block drivers, which
have a unique instance, e. g. the BlkDrvTcp. The given network address conains in this case the ip-address
and the port of the node, in the  block driver specific format.
Additionally this function can be used to get the address of the first router instance of the own
runtime system.
</description>
<param name="usBlkDrvType" type="IN">
Type of the block driver, see CmpCommunicationLibItf.h.
If set to RTS_BLK_DRV_TYPE_NONE, the address of the first router instance is returned. In this case
the next two parameters are ignored.
</param>
<param name="byNetworkAddressBitSize" type="IN">
Length of the specified network address in bits. Must match to the setting in the blockdriver.
Should be 0, if RTS_BLK_DRV_TYPE_NONE is used to get the own router address.
</param>
<param name="pNetworkAddr" type="IN">
Networkaddress of the node, for which the peer address should be calcualted.
Should be NULL, if RTS_BLK_DRV_TYPE_NONE is used to get the own router address.
</param>
<param name="pNodeAddr" type="OUT">
The function returns here the calculated node address.
</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char *szName, RTS_HANDLE *phRouter)">RouterGetInstanceByName</functionname>
<description>
Get the handle to the routerinstance with the provided name.
</description>
<param name="szName" type="IN">
Name of the router. This parameter may be NULL to request a handle to the default router.
</param>
<param name="phRouter" type="OUT">
If a router exists with the specified name, then the handle of the router is written into this
parameter. Otherwise it is set to RTS_INVALID_HANDLE.
</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hRouter, char *pszName, int nMaxLen)">RouterGetName</functionname>
<description>
Get the name of a router specified by handle
</description>
<param name="hRouter" type="IN">Handle to router</param>
<param name="pszName" type="OUT">Pointer to get router name</param>
<param name="nMaxLen" type="IN">Maximum buffer length of pszName</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hRouter, PEERADDRESS addrPeer, RTS_UI16 *usMaxSize)">RouterGetMaxMessageSize</functionname>
<description>
Get the max. size of messages, which can be sent by higher layers to this peer address
</description>
<param name="hRouter" type="IN">Handle to router. If set to RTS_INVALID_HANDLE, the first router instance is used.</param>
<param name="addrPeer" type="IN">Address to check</param>
<param name="byMaxSize" type="OUT">Max payload of the router message.</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hRouter, RTS_UI16 usSumAddrLen, RTS_UI16 *usMaxSize)">RouterGetMaxMessageSizeByAddressLength</functionname>
<description>
Get the max. size of messages, which can be sent by higher layers to this peer address
</description>
<param name="hRouter" type="IN">Handle to router</param>
<param name="usSumAddrLen" type="IN">Sum of sender and receiver address length</param>
<param name="byMaxSize" type="OUT">Max payload of the router message.</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hRouter, PEERADDRESS addrPeer, RTS_UI8 *byMaxSize)">RouterGetMaxAddressSize</functionname>
<description>
Get the sum of the address lengths of the current router and the addrPeer.
</description>
<param name="hRouter" type="IN">Handle to router. If set to RTS_INVALID_HANDLE, the first router instance is used.</param>
<param name="addrPeer" type="IN">Address to check</param>
<param name="byMaxSize" type="OUT">Sum of router address and addrPeer length</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hRouter, PEERADDRESS addrReceiver, int nProtocolId, RTS_UI8 byMessageId, ROUTERPRIORITY prio, PROTOCOL_DATA_UNIT pduData, RTS_BOOL bUseQueue)">RouterSend2</functionname>
/** <description>
Protocol handlers call this function to send a data package.
</description>
<param name="hRouter" type="IN">Handle to the router</param>
<param name="addrReceiver" type="IN">
Address of the receiver. Relative addresses are allowed as well as absolute ones.
</param>
<param name="nProtocolId" type="IN">Identifies the protocol handler on the receiving host.</param>
<param name="byMessageId" type="IN">typically 0</param>
<param name="prio" type="IN">Priority of the message.</param>
<param name="pduData" type="IN">The data to be sent.</param>
<param name="bUseQueue" type="IN">Defines if the message should be queued, if it can not be send at once.</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hRouter, PEERADDRESS addrReceiver, int nProtocolId, RTS_UI8 byMessageId, ROUTERPRIORITY prio, PROTOCOL_DATA_UNIT pduData)">RouterSend</functionname>
/** <description>
Protocol handlers call this function to send a data package.
</description>
<param name="hRouter" type="IN">Handle to the router</param>
<param name="addrReceiver" type="IN">
Address of the receiver. Relative addresses are allowed as well as absolute ones.
</param>
<param name="nProtocolId" type="IN">Identifies the protocol handler on the receiving host.</param>
<param name="byMessageId" type="IN">typically 0</param>
<param name="prio" type="IN">Priority of the message.</param>
<param name="pduData" type="IN">The data to be sent.</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hRouter, NODEADDRESS *pAddrRouter)">RouterGetHostAddress</functionname>
/** <description>
Get the routers nodeaddress.
</description>
<param name="hRouter" typ="IN">Handle to router. If set to RTS_INVALID_HANDLE, the first router instance is used.</param>
<param name="pAddrRouter" type="OUT">Is set to the nodeaddress of the router</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hRouter, NODEADDRESS *pAddrParent)">RouterGetParentAddress</functionname>
/** <description>
Get the nodeaddress of the parent node.
</description>
<param name="hRouter" typ="IN">Handle to router. If set to RTS_INVALID_HANDLE, the first router instance is used.</param>
<param name="pAddrParent" type="OUT">Is set to the nodeaddress of the router</param>
<result>error code</result>
</element>
</element>
</component>
<component>
<name>CmpScheduleTimer</name>
<description>
<p>The so called "Timer Scheduler" is in fact a mixture between
the "Embedded Scheduler" and the full "Multitasking Scheduler"
of CoDeSys Control.</p>
<p>It supports the following task types:</p>
<ul>
<li>Freewheeling Tasks</li>
<li>Cyclic Tasks</li>
<li>Event Tasks</li>
</ul>
<p>External Events are currently not supported.</p>
<p>Freewheeling- and Event Tasks are scheduled in the same way
as with the "Embedded Scheduler" - they are called within the
context of the Comm-Cycle in the Background loop.</p>
<p>Contrary to this, the Cyclic Tasks are set up on hardware
Timers, using the Interface of the component "SysTimer".</p>
<p>The "SysTimer" component just needs to provide some kind
of cyclic callback. It don't essentially needs to be a real
hardware timer, but can also be emulated by software. The only
prerequisit that the cyclic callback from SysTimer needs to
fullfill is that the callbacks can only be preempted in a
priorized way and that they don't block in between a cycle.
This is necessary, because the locking scheme of the
"Timer Scheduler" relys on this behavior.</p>
<p>The simplest solution to implement those cyclic tasks,
would be, to call the task code directly out of the ISR
of the hardware timer, and that's it. But this solution
reaches it's limits, when we want to do debugging in one
task. To do this, we need to jump actively out of the task
code and resume later at the same position.</p>
<pre>
.           prio
.             ^
.             |
.         ISR |      XXXXXXXXX
.             |      |       |
.             |      |       |
.  Comm Cycle |XXXXXX:::::::::XXXXXX
.             |
.             '----------------------> t
</pre>
<p>This debugging scenario can be solved easily with the
standard calls setjump and longjump.</p>
<p>This is the first IEC cycle, where we set up the Task context:</p>
<pre>
.                               _,._
.                              /    '-.
.                             /        '-.
.                            |            '
.                            | [2]        (1)
.    IEC Task |              | XXXXXXXXXXXXX
.             |              v |           |
.             |             [1]|           |
.         ISR |             XXX:::::::::::::XXX
.             |             |                 |
.             |             |                 |
.  Comm Cycle |XXXXXXXXXXXXX:::::::::::::::::::XXXXXXXXXXXXXXXX
.             |
.             '------------------------------------------------> t
.
.  Index:
.  [1] setjump ContextFrame
.  [2] setjump ContextIecTask
.  (1) longjump ContextFrame
</pre>
<p>On the first switch between the ISR context and the IEC task
context, we have to switch the task stack. We do this with a call
to the macro RTS_CPU_CALL_ON_STACK(), which needs to be implemented
platform specifically.</p>
<p>On every next call of the ISR, we don't switch the stack anymore,
but simply make a longjump into the saved context number two
(ContextIecTask).</p>
<pre>
.                             _,._
.                           ,'    '-.
.                          /         '.
.                         /   -.       '.
.                        /   /  \        \
.                       |   |   v         '.
.                      |   |   [2]        (1)
.    IEC Task |        .   |   XXXXXXXXXXXXX
.             |        v   |   |           |
.             |       [1] (2)  |           |
.         ISR |       XXXXXXXXX:::::::::::::XXX
.             |       |                       |
.             |       |                       |
.  Comm Cycle |XXXXXXX:::::::::::::::::::::::::XXXXXXXXXXXXXXXX
.             |
.             '------------------------------------------------> t
.
.  Index:
.  [1] setjump ContextFrame
.  [2] setjump ContextIecTask
.  (1) longjump ContextFrame
.  (2) longjump ContextIecTask
</pre>
<p>The reason, why we have to jump in and out of the IEC task
context every time is, that later in the debug case, our calling
context may have changed when we leave the task.</p>
<p>When we are running on a breakpoint, our IEC task saves the
breakpoint context and jumps out of the task.</p>
<pre>
.                            __
.                          ,'  '-.
.                         /   -.  '.
.                        |   /  \   \
.                       |   |   v    '.
.                       |   |  [2][3](1)
.    IEC Task |        |   |   XXXXXXXXXXXXX
.             |        v   |   |           |
.             |       [1] (2)  |           |
.         ISR |       XXXXXXXXX:::::::::::::XXX
.             |       |                       |
.             |       |                       |
.  Comm Cycle |XXXXXXXX::::::::::::::::::::::::XXXXXXXXXXXXXXXX
.             |
.             '------------------------------------------------> t
.
.  Index:
.  [1] setjump ContextFrame
.  [2] setjump ContextIecTask
.  [3] setjump ContextIecTaskBP
.  (1) longjump ContextFrame
.  (2) longjump ContextIecTask
</pre>
<p>As long as the task is waiting on the breakpoint, we are
jumping into the stored breakpoint context. The breakpoint
handling code there is checking by it's own, if it has to
continue the task execution or if it has to jump back to
the ContextFrame again.</p>
<pre>
.                            __
.                          ,'  '-.
.                         /   ,.. '.
.                        |   /   '. \
.                       |   /      v '.
.                       |  |   [2][3](1)
.    IEC Task |        |   |   XXXXXXXXXXXXX
.             |        v   |   |           |
.             |       [1] (3)  |           |
.         ISR |       XXXXXXXXX:::::::::::::XXX
.             |       |                       |
.             |       |                       |
.  Comm Cycle |XXXXXXXX::::::::::::::::::::::::XXXXXXXXXXXXXXXX
.             |
.             '------------------------------------------------> t
.
.  Index:
.  [1] setjump ContextFrame
.  [2] setjump ContextIecTask
.  [3] setjump ContextIecTaskBP
.  (1) longjump ContextFrame
.  (2) longjump ContextIecTask
.  (3) longjump ContextIecTaskBP
</pre>
<p>The command CMD_TICK checks itself if the period in which it was
called matches the configured period, which is set by the define
SCHEDULEKEY_INT_SCHEDULER_INTERVAL_DEFAULT. If it missed one tick, it
imediately generates an exception.</p>
<p>This implies, that SysTimer and SysTime are synchronized or are
based on the same timer source.</p>
<p>This is a design pattern for the synchronization in pseudocode:</p>
<pre>
static variable s_Time

TIMER_ISR()
IF s_LastTime = 0
s_LastTime = current time

WHILE (current time - s_LastTime) &gt; Period
CALL Schedule( CMD_TICK )
s_LastTime += Period
</pre>
<p>This design pattern will base the call on the frequency of the
hardware timer, but synchronizes it with another timer. This might
lead to a jitter when the algorithm regulates a timer drift, but it
takes care that no tick is missed. What is important when doing a
watchdog check.</p>
<p>If the both components SysTime and SysTimer are based on the
same hardware frequency, it is not necessary to synchronize.</p>
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element define="1">
<name>CMPSCHEDULE_IECTASKS_HIGH_PRIO</name>
<key></key>
<condition>CMPSCHEDULE_IECTASKS_HIGH_PRIO</condition>
<category>Static defines</category>
<description>
<p>This is a soft barrier and is not mandatory for the scheduler.
But the Timer Scheduler is using this to place the task stacks of
tasks with a higher priority (&lt;= CMPSCHEDULE_IECTASKS_HIGH_PRIO) into
a different memory area than the others (e.g. internal RAM).</p>
<p>The physical location of the stacks can be influenced with the
two macros:</p>
<ul>
<li>CMPSCHEDULE_IECTASK_STACK_STD_ATTRIBUTE</li>
<li>CMPSCHEDULE_IECTASK_STACK_HIGH_ATTRIBUTE</li>
</ul>
</description>
</element>
<element define="1">
<name>CMPSCHEDULE_IECTASKS_STACK_STD_ATTRIBUTE</name>
<key></key>
<condition>CMPSCHEDULE_IECTASKS_STACK_STD_ATTRIBUTE</condition>
<category>Static defines</category>
<description>Attribute to place the stack of the IEC tasks
in a different location.</description>
</element>
<element define="1">
<name>CMPSCHEDULE_IECTASKS_STACK_HIGH_ATTRIBUTE</name>
<key></key>
<condition>CMPSCHEDULE_IECTASKS_STACK_HIGH_ATTRIBUTE</condition>
<category>Static defines</category>
<description>Attribute to place the stack of high priority tasks
in a different location (e.g. internal RAM).</description>
</element>
<p><h1>Compiler Switch</h1></p>
<ul>
<li>
<csdef>#define CMPSCHEDULE_DISABLE_TASK_WAKEUP_ON_CYCLE_END</csdef>
<csdesc>Switch to disable calling the scheduler at each IEC task cycle end once more to reduce processor load</csdesc>
<p></p>
</li>
</ul>
<element interface="1" name="CmpScheduleItf">
<interfacename>CmpSchedule</interfacename>
<description>
Interface of the scheduler.
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element define="1">
<name>CMPSCHEDULE_IECTASK_STACK_SIZE</name>
<key>0</key>
<condition>CMPSCHEDULE_IECTASK_STACK_SIZE</condition>
<category>Stack size</category>
<description>Specifies the stack size of an IEC task of the timer scheduler. 0 is the default size of the operating system or environment.</description>
</element>
<element define="1">
<name>SCHEDULEKEY_INT_SCHEDULER_INTERVAL_US</name>
<key>SchedulerInterval</key>
<description>
Set the interval in microseconds of the scheduler. INT type.
</description>
</element>
<element define="1">
<name>SCHED_DEBUG_LOOP_CYCLE_TIME</name>
<key>100</key>
<condition>SCHED_DEBUG_LOOP_CYCLE_TIME</condition>
<category>Static defines</category>
<description>Sleep time in breakpoint loop in milliseconds</description>
</element>
<element define="1">
<name>SCHEDULE_FEATURE_RESET_ON_BREAKPOINT</name>
<key>0x00000001</key>
<category>Features</category>
<type>Int</type>
<description>
Supported features of the scheduler
</description>
</element>
<element define="1">
<name>EVT_TaskCreateDone</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent, after an IEC-task was created at application download</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpSchedule</param>
</element>
<element define="1">
<name>EVT_PrepareTaskDelete</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent, before an IEC-task will be deleted at application download</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpSchedule</param>
</element>
<element define="1">
<name>EVT_ExternalEventTaskCreateDone</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent, after an IEC-task, that is external event triggered was created</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpSchedule</param>
</element>
<element define="1">
<name>EVT_PrepareExternalEventTaskDelete</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent, before an IEC-task, that is external event triggered will be deleted</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpSchedule</param>
</element>
<element define="1">
<name>EVT_ScheduleTick</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent always in the schedule tick</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpScheduleTick</param>
</element>
<element define="1">
<name>EVT_ScheduleTaskGap</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Event is sent always, if no IEC task is active (task gap)</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpScheduleTick</param>
</element>
<element typedefinition="1">
<name>EVTPARAM_CmpSchedule</name>
<structname>EVTPARAM_CmpSchedule</structname>
<category>Event parameter</category>
<element name="pTaskDesc" type="IN">Pointer to the task description of the assigned IEC task</element>
<element name="hEvent" type="IN">Handle to the event, that can be used to trigger the task by SysEventSet(hEvent)</element>
<rawdata>
typedef struct
{
	Task_Desc* pTaskDesc;
	RTS_HANDLE hEvent;
} EVTPARAM_CmpSchedule;
</rawdata>
</element>
<element typedefinition="1">
<name>EVTPARAM_CmpScheduleTick</name>
<structname>EVTPARAM_CmpScheduleTick</structname>
<category>Event parameter</category>
<element name="pSchedTime" type="IN">Actual time value of the scheduler, that is used for activating the tasks</element>
<rawdata>
typedef struct
{
	RTS_SYSTIME *pSchedTime;
	int nScheduleIntervalUs;
} EVTPARAM_CmpScheduleTick;
</rawdata>
</element>
<element typedefinition="1">
<name>schedwaitsleep_struct</name>
<structname>schedwaitsleep_struct</structname>
<description>
Function to sleep a specified time interval in microseconds _without_ consuming processor load!
</description>
<param name="ptSleepUs" type="IN">Time to sleep in microseconds</param>
<result>error code</result>
<rawdata>
typedef struct tagschedwaitsleep_struct
{
	RTS_IEC_ULINT *ptSleepUs;			VAR_IN_OUT
	RTS_IEC_UDINT SchedWaitSleep;		VAR_OUTPUT
} schedwaitsleep_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>schedsettaskinterval_struct</name>
<structname>schedsettaskinterval_struct</structname>
<description>
Set the actual interval of a cyclic task. If the specified task is no cyclic task, the function return an error.
This interface can be used to synchronize a task to another task or to events.
</description>
<param name="hSchedTask" type="IN">Handle to the task</param>
<param name="tInterval" type="IN">New interval in microseconds!</param>
<result>error code</result>
<rawdata>
typedef struct tagschedsettaskinterval_struct
{
	RTS_IEC_BYTE *hSchedTask;			VAR_INPUT
	RTS_IEC_UDINT ulInterval;			VAR_INPUT
	RTS_IEC_UDINT SchedSetTaskInterval;	VAR_OUTPUT
} schedsettaskinterval_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>schedgetcurrenttask_struct</name>
<structname>schedgetcurrenttask_struct</structname>
<description>Is called to get the schedule handle of the current running task</description>
<param name="pResult" type="OUT">ERR_OK or Error code</param>
<result>Handle to the current running task or RTS_INVALID_HANDLE if failed</result>
<rawdata>
typedef struct tagschedgetcurrenttask_struct
{
	RTS_IEC_UDINT *pResult;				VAR_INPUT
	RTS_IEC_BYTE *SchedGetCurrentTask;	VAR_OUTPUT
} schedgetcurrenttask_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>schedwaitbusy_struct</name>
<structname>schedwaitbusy_struct</structname>
<description>
Function to wait busy during a specified time interval. This consumes maximum of processor load!
</description>
<param name="ptSleepUs" type="IN">Time to sleep in microseconds</param>
<result>error code</result>
<rawdata>
typedef struct tagschedwaitbusy_struct
{
	RTS_IEC_ULINT *ptSleepUs;			VAR_IN_OUT
	RTS_IEC_UDINT SchedWaitBusy;		VAR_OUTPUT
} schedwaitbusy_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>schedgettaskinterval_struct</name>
<structname>schedgettaskinterval_struct</structname>
<description>
Get the actual interval of a cyclic task. If the specified task is no cyclic task, the function return an error.
</description>
<param name="hSchedTask" type="IN">Handle to the task</param>
<param name="ptInterval" type="OUT">Interval of the task in microseconds!</param>
<result>error code</result>
<rawdata>
typedef struct tagschedgettaskinterval_struct
{
	RTS_IEC_BYTE *hSchedTask;			VAR_INPUT
	RTS_IEC_UDINT *pulInterval;			VAR_IN_OUT
	RTS_IEC_UDINT SchedGetTaskInterval;	VAR_OUTPUT
} schedgettaskinterval_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>schedgettaskeventbyhandle_struct</name>
<structname>schedgettaskeventbyhandle_struct</structname>
<description>
Function returns the handle to the task event. With this event a task can be activaed externally,
e.g. for external triggered event tasks. The event can be sent by SysEventSet(EventHandle);
</description>
<param name="hSchedTask" type="IN">Scheduler task handle</param>
<param name="pResult" type="OUT">ERR_OK or Error code</param>
<result>Event handle. Can be used with SysEventSet(hEvent) of the SysEvent.library to wakeup the task</result>
<rawdata>
typedef struct tagschedgettaskeventbyhandle_struct
{
	RTS_IEC_BYTE *hSchedTask;			VAR_INPUT
	RTS_IEC_UDINT *pResult;				VAR_INPUT
	RTS_IEC_BYTE *SchedGetTaskEventByHandle;	VAR_OUTPUT
} schedgettaskeventbyhandle_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>schedgettaskhandlebyname_struct</name>
<structname>schedgettaskhandlebyname_struct</structname>
<description>
Function returns the handle to the task specified by name.
</description>
<param name="pszTaskName" type="IN">Task name</param>
<param name="pResult" type="OUT">ERR_OK or Error code</param>
<result>Scheduler task handle</result>
<rawdata>
typedef struct tagschedgettaskhandlebyname_struct
{
	RTS_IEC_STRING *pszTaskName;		VAR_IN_OUT
	RTS_IEC_UDINT *pResult;				VAR_INPUT
	RTS_IEC_BYTE *SchedGetTaskHandleByName;	VAR_OUTPUT
} schedgettaskhandlebyname_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>schedgetnumoftasks_struct</name>
<structname>schedgetnumoftasks_struct</structname>
<description>
Is called to get the number of all registerd IEC tasks in the scheduler.
</description>
<param name="pApp" type="IN">If an application is specified, only the tasks of this application is returned.
If NULL, number of all tasks is returned.
</param>
<param name="pResult" type="OUT">ERR_OK or Error code</param>
<result>Number of tasks</result>
<rawdata>
typedef struct tagschedgetnumoftasks_struct
{
	APPLICATION *pApp;					VAR_INPUT
	RTS_IEC_UDINT *pResult;				VAR_INPUT
	RTS_IEC_DINT SchedGetNumOfTasks;	VAR_OUTPUT
} schedgetnumoftasks_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>schedgetprocessorload_struct</name>
<structname>schedgetprocessorload_struct</structname>
<description>Returns the processor load of all IEC tasks</description>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Processor load in percent</result>
<rawdata>
typedef struct tagschedgetprocessorload_struct
{
	RTS_IEC_UDINT *pResult;				VAR_INPUT
	RTS_IEC_UDINT SchedGetProcessorLoad;	VAR_OUTPUT
} schedgetprocessorload_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>schedgettaskhandlebyindex_struct</name>
<structname>schedgettaskhandlebyindex_struct</structname>
<description>
Function returns the task handle of a task specified by an index.
</description>
<param name="pApp" type="IN">If an application is specified, only the task of this application is returned.
If NULL, the task with the index in all tasks i returned.
</param>
<param name="pResult" type="OUT">ERR_OK or Error code</param>
<result>Handle to the task</result>
<rawdata>
typedef struct tagschedgettaskhandlebyindex_struct
{
	APPLICATION *pApp;					VAR_INPUT
	RTS_IEC_DINT nIndex;				VAR_INPUT
	RTS_IEC_UDINT *pResult;				VAR_INPUT
	RTS_IEC_BYTE *SchedGetTaskHandleByIndex;	VAR_OUTPUT
} schedgettaskhandlebyindex_struct;
</rawdata>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(unsigned long ulFeatures)">SchedHasFeature</functionname>
<description>
Routine to check, if a scheduler has the specified feature.
</description>
<param name="ulFeatures" type="IN">Feature flags, See corresponding category "Features".</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(Task_Desc *pTask, RTS_RESULT *pResult)">SchedAddTask</functionname>
<description>
<p>Create a new IEC task, that is under control of the CoDeSys Control
Scheduler</p>
<p>Depending on the type of Scheduler which is used, the tasks may be
created in different ways. Here is a small list of the most common
Scheduling schemes:</p>
<ul>
<li><b>CmpSchedule:</b>
A full multitasking scheduler, where every task (independent of its
type) has a corresponding OS task.</li>
<li><b>CmpScheduleEmbedded:</b>
A very simple scheduler, where every task runs in the context of a
super loop in the background (the comm cycle). The tasks are scheduled
in polling mode by the scheduler.</li>
<li><b>CmpScheduleTimer:</b>
Freewheeling and Event tasks are scheduled similar to CmpScheduleEmbedded,
but cyclic tasks are placed on preemptive timers.</li>
</ul>
<p>The tasks are set up, but not started, yet. To start the tasks, one
should call SchedStart().</p>
</description>
<param name="pTask" type="IN" range="[NULL,VALID_TASKSDESC]">Task description</param>
<parampseudo name="TaskType" type="IN" range="[TaskFreewheeling,TaskEvent,TaskCyclic,TaskExternal]">Type of the IEC task</parampseudo>
<parampseudo name="iNumOfTasks" type="IN" range="[0..NUM_OF_STATIC_IEC_TASKS]">Number of Tasks that are created</parampseudo>
<parampseudo name="bException" type="OUT">Exception was thrown</parampseudo>
<param name="pResult" type="OUT">Result</param>
<result>Handle to task</result>
<errorcode name="RTS_RESULT" type="ERR_OK">Task was created successfully</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">pTask was NULL</errorcode>
<errorcode name="RTS_RESULT" type="ERR_NOMEMORY">Not enough memory to create the task.</errorcode>
<errorcode name="RTS_RESULT" type="ERR_FAILED">Scheduler specific error. Most likely the scheduler was unable to create a required ressource.</errorcode>
<errorcode name="RTS_RESULT" type="ERR_NOT_SUPPORTED">The configured task type is not supported by this scheduler</errorcode>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hSchedTask)">SchedRemoveTask</functionname>
<description> Removes a task from scheduler </description>
<param name="hSchedTask" type="IN">Handle to taks</param>
<result>ERR_OK</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hSchedTask, RTS_UI32 ulTimeoutMs)">SchedRemoveTask2</functionname>
<description> Removes a task from scheduler with timeout </description>
<param name="hSchedTask" type="IN">Handle to taks</param>
<param name="ulTimeoutMs" type="IN">Timeout in milliseconds to wait for removing the task
Some timeouts are predefined (see CmpStd.h):
<ul>
<li>RTS_TIMEOUT_DEFAULT: Use default wait time</li>
<li>RTS_TIMEOUT_NO_WAIT: No wait</li>
</ul>
</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hSchedTask, int iCmd)">Schedule</functionname>
<description>
<p>Execute a scheduler command.</p>
<p>Depending on the kind of scheduler, it may support different scheduler
specific commands. Those commands may be described in the documentation
of the scheduler component itself.</p>
<p>The following are generic commands which every scheduler should support:</p>
<ul>
<li>CMD_TICK:
This command can be used by the scheduler to schedule it's cyclic- or
event tasks. But most essentially this tick has to check the tasks
watchdogs.</li>
<li>CMD_DEBUG_LOOP:
This command is used by the IEC tasks to halt on a breakpoint. It should
only be called by an IEC task, which ran on a breakpoint. The implementation
is very dependent on the kind of scheduler, but it will halt the execution
of the IEC task until the breakpoint is left.</li>
</ul>
</description>
<param name="hSchedTask" type="IN" range="[RTS_INVALID_HANDLE,VALID_TASKHANDLE]">Handle to taks</param>
<param name="iCmd" type="IN" range="[CMD_TICK,CMD_DEBUG_LOOP,INVALID_CMD]">Type of schedule command</param>
<parampseudo name="bSIL2SafetyMode" type="IN" range="[0,1]">Type of schedule command</parampseudo>
<parampseudo name="bWatchdogSleep" type="IN" range="[0,1]">Watchdog sleep to check if Exception occurs</parampseudo>
<parampseudo name="bException" type="OUT">Is only allowed in SIL2 Runtime in Debugmode</parampseudo>
<result>error code</result>
<errorcode name="RTS_RESULT" type="ERR_OK">Command executed successfully</errorcode>
<errorcode name="RTS_RESULT" type="ERR_NOT_SUPPORTED">Command is not supported</errorcode>
<errorcode name="RTS_RESULT" type="ERR_FAILED">Command is not supported</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">Command is not supported</errorcode>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hSchedTask)">SchedDebugEnter</functionname>
<description> Enter task for debugging </description>
<param name="hSchedTask" type="IN">Handle to taks</param>
<result>ERR_OK</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hSchedTask)">SchedDebugLeave</functionname>
<description> Leave from debugging </description>
<param name="hSchedTask" type="IN">Handle to taks</param>
<result>ERR_OK</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION *pApp, int bResetOrigin)">SchedPrepareReset</functionname>
<description> Prepare reset, delete all IEC tasks in error state</description>
<result>ERR_OK</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION *pApp, int bResetOrigin)">SchedResetDone</functionname>
<description> Restart all IEC tasks in error state</description>
<result>ERR_OK</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION *pApp)">SchedStart</functionname>
<description>
<p>Start scheduling of all tasks of an application</p>
</description>
<param name="pApp" type="IN" range="[NULL,VALID_APPLICATION]">APPLICATION object</param>
<parampseudo name="bTaskIsValid" type="IN" range="[0,1]">Task is valid</parampseudo>
<parampseudo name="bTimerIsStarted" type="IN" range="[0,1]">Timer was started</parampseudo>
<parampseudo name="_pApp" type="IN" range="[NULL,VALID_APPLICATION]">Application registered for this Task</parampseudo>
<result>error code</result>
<errorcode name="RTS_RESULT" type="ERR_OK">All tasks started successfully</errorcode>
<errorcode name="RTS_RESULT" type="ERR_FAILED">Internal Error of the scheduler</errorcode>
<errorcode name="RTS_RESULT" type="ERR_NO_OBJECT">No task found in application</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">pApp was NULL</errorcode>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(APPLICATION *pApp, RTS_HANDLE hTaskToExclude)">SchedStop</functionname>
<description> Stop scheduling all tasks specified by application </description>
<param name="pApp" type="IN">APPLICATION object</param>
<param name="hTaskToExclude" type="IN">Handle of task to exclude from scheduling.
hTask=RTS_INVALID_HANDLE, all tasks are disabled</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(Task_Desc **ppTask, RTS_RESULT *pResult)">SchedGetCurrentTask</functionname>
<description>Is called to get the schedule handle of the current running task</description>
<param name="ppTask" type="OUT">Task description for the IecTask component. Can be NULL.</param>
<param name="pResult" type="OUT">ERR_OK or Error code</param>
<result>Handle to the current running task or RTS_INVALID_HANDLE if failed</result>
</element>
<element function="1">
<functionname returntype="int" parameters="(APPLICATION *pApp, RTS_RESULT *pResult)">SchedGetNumOfTasks</functionname>
<description>
Is called to get the number of all registerd IEC tasks in the scheduler.
</description>
<param name="pApp" type="IN">If an application is specified, only the tasks of this application is returned.
If NULL, number of all tasks is returned.
</param>
<param name="pResult" type="OUT">ERR_OK or Error code</param>
<result>Number of tasks</result>
</element>
<element function="1">
<functionname returntype="Task_Desc *" parameters="(APPLICATION *pApp, int iIndex, RTS_RESULT *pResult)">SchedGetTaskDescByIndex</functionname>
<description>
Function returns the task description of a task specified by an index.
</description>
<param name="pApp" type="IN">If an application is specified, only the task of this application is returned.
If NULL, the task with the index in all tasks i returned.
</param>
<param name="pResult" type="OUT">ERR_OK or Error code</param>
<result>Task description</result>
</element>
<element function="1">
<functionname returntype="Task_Desc *" parameters="(RTS_HANDLE hSchedTask, RTS_RESULT *pResult)">SchedGetTaskDescByHandle</functionname>
<description>
Function returns the task description of a task specified by handle.
</description>
<param name="hSchedTask" type="IN">Handle of the task</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Task description</result>
</element>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(APPLICATION *pApp, int iIndex, RTS_RESULT *pResult)">SchedGetTaskHandleByIndex</functionname>
<description>
Function returns the task handle of a task specified by an index.
</description>
<param name="pApp" type="IN">If an application is specified, only the task of this application is returned.
If NULL, the task with the index in all tasks i returned.
</param>
<param name="pResult" type="OUT">ERR_OK or Error code</param>
<result>Handle to the task</result>
</element>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(char *pszTaskName, RTS_RESULT *pResult)">SchedGetTaskHandleByName</functionname>
<description>
Function returns the handle to the task specified by name.
</description>
<param name="pszTaskName" type="IN">Task name</param>
<param name="pResult" type="OUT">ERR_OK or Error code</param>
<result>Scheduler task handle</result>
</element>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(RTS_HANDLE hSchedTask, RTS_RESULT *pResult)">SchedGetTaskEventByHandle</functionname>
<description>
Function returns the handle to the task event. With this event a task can be activaed externally,
e.g. for external triggered event tasks. The event can be sent by SysEventSet(EventHandle);
</description>
<param name="hSchedTask" type="IN">Scheduler task handle</param>
<param name="pResult" type="OUT">ERR_OK or Error code</param>
<result>Event handle</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(void)">SchedTimeslicePlcBegin</functionname>
<description>Begin of the plc timeslice. Can be called by an external component, if external timselicing
is enabled.
</description>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(void)">SchedTimeslicePlcEnd</functionname>
<description>End of the plc timeslice. Can be called by an external component, if external timselicing
is enabled.
</description>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="unsigned long" parameters="(RTS_RESULT *pResult)">SchedGetProcessorLoad</functionname>
<description>Returns the processor load, that is consumed by all IEC tasks in %. Can be in the range of 0..100 [%].
This feature must be enabled with the setting "ProcessorLoad.Maximum" > 0.</description>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Processor load in percent</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hSchedTask, RTS_UI32 *pulInterval)">SchedGetTaskInterval</functionname>
<description>
Get the actual interval of a cyclic task. If the specified task is no cyclic task, the function return an error.
</description>
<param name="hSchedTask" type="IN">Handle to the task</param>
<param name="ptInterval" type="OUT">Pointer to the interval</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hSchedTask, RTS_UI32 ulInterval)">SchedSetTaskInterval</functionname>
<description>
Set the actual interval of a cyclic task. If the specified task is no cyclic task, the function return an error.
This interface can be used to synchronize a task to another task or to events.
</description>
<param name="hSchedTask" type="IN">Handle to the task</param>
<param name="tInterval" type="IN">New interval</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_SYSTIME *ptSleepUs)">SchedWaitSleep</functionname>
<description>
Function to sleep a specified time interval in microseconds _without_ consuming processor load!
</description>
<param name="ptSleepUs" type="IN">Time to sleep in microseconds</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_SYSTIME *ptSleepUs)">SchedWaitBusy</functionname>
<description>
Function to wait busy during a specified time interval. This consumes maximum of processor load!
</description>
<param name="ptSleepUs" type="IN">Time to sleep in microseconds</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hSchedTask)">SchedWatchdogExceptionHandler</functionname>
<description>
Handler is called, if a watchdog exception occurred.
</description>
<param name="hSchedTask" type="IN">Handle to the task</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="int" parameters="(RTS_RESULT *pResult)">SchedGetScheduleIntervalUs</functionname>
<description>
Get the actual schedule interval in microseconds.
</description>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Schedule interval in microseconds</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(int iScheduleIntervalUsNew)">SchedSetScheduleIntervalUs</functionname>
<description>
Get the actual schedule interval in microseconds.
The actual schedule interval (system base tick) has to be adapted accordingly.
</description>
<param name="iScheduleIntervalUsNew" type="IN">Schedule interval in microseconds to set</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hSysTask, RTS_UI32 ulInterval)">SchedSetTaskIntervalByTaskHandle</functionname>
<description>
Set the actual interval of a cyclic task. If the specified task is no cyclic task, the function returns an error.
This interface can be used to synchronize a task to another task or to events.
NOTE:
The provided handle is a SysTask handle, no schedule handle!
</description>
<param name="hSysTask" type="IN">Handle to the task provided by SysTask component</param>
<param name="ulInterval" type="IN">New interval</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(const char *pszExtEventName, RTS_RESULT *pResult)">SchedRegisterExternalEvent</functionname>
<description>
<p>Register an external event, which might be used later by
event tasks. You should register those events during the system
startup, so that the scheduler knows all events when the
application is loaded.</p>
<p>Valid Hook: CH_INIT2</p>
<p>Note: the parameter pszExtEventName needs to be constantly
allocated. It might either be a constant string, a global string
variable, or a dynamically allocated string. But the memory needs
to be valid during the life time of the event handle.</p>
</description>
<param name="pszExtEventName" type="IN">Name of the event, as it was specified in the device description. This parameter needs to be constantly allocated</param>
<param name="pResult" type="INOUT">Error Code</param>
<errorcode name="RTS_RESULT" type="ERR_OK">Event was registered successfully</errorcode>
<errorcode name="RTS_RESULT" type="ERR_NOMEMORY">There was not enough memory to register the new event handle</errorcode>
<result>handle to the event</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hExtEvent)">SchedUnregisterExternalEvent</functionname>
<description>
<p>Unregister an external event, which was registered by
SchedRegisterExternalEvent() before.</p>
<p>This function should be called on system shutdown</p>
<p>Valid Hook: CH_EXIT2</p>
</description>
<param name="hExtEvent" type="IN">Handle to the external event, that should be unregistered.</param>
<errorcode name="RTS_RESULT" type="ERR_OK">Event was deregistered successfully</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">The event handle was not registered before</errorcode>
<result>Error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hExtEvent)">SchedPostExternalEvent</functionname>
<description>
<p>Execute all tasks, that are registered for the given
event. The execution context may vary depending on the
scheduler type. It might be executed synchronously in the
context of the caller, or a system task (e.g. ontop of an
OS) is just signaled to execute the task code.</p>
<p>Note, that the result ERR_NO_OBJECT might not be a
real error. Depending on the system it might be OK, that
no task was registered for this event.</p>
</description>
<param name="hExtEvent" type="IN">Handle to the external event, which tasks should be signaled</param>
<errorcode name="RTS_RESULT" type="ERR_OK">Event was signaled successfully</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">The event handle was not found</errorcode>
<errorcode name="RTS_RESULT" type="ERR_NO_OBJECT">There was no task, registered on this event</errorcode>
<result>Error Code</result>
</element>
</element>
</component>
<component>
<name>CmpSettingsEmbedded</name>
<description>
This component enables the access to all runtime settings.
Each component can have separate settings.
NODE: SysSockCreate can be used to check, if SysSocket component is available. Is used actually e.g.
for the embedded settings component to evaluate for the router component.
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element interface="1" name="CmpSettingsItf">
<interfacename>CmpSettings</interfacename>
<description>
Interface for the settings component. The settings component can have different backend
components, to realise different sources for the settings (e.g. ini-File, hardcoded, XML, etc.).
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element define="1">
<name>STD_SETTINGS_DATABASE</name>
<key>CODESYSControl</key>
<condition>STD_SETTINGS_DATABASE</condition>
<category>Static defines</category>
<description>This define can be used to call always the standard settings database.
</description>
</element>
<element define="1">
<name>STD_SETTINGS_DATABASE_OLD</name>
<key>CoDeSysSP</key>
<condition>STD_SETTINGS_DATABASE_OLD</condition>
<category>Static defines</category>
<description>This define can be used to call always the standard settings database.
</description>
</element>
<element define="1">
<name>FILE_END_OF_LINE_DELIMITER</name>
<key>\r\n</key>
<condition>FILE_END_OF_LINE_DELIMITER</condition>
<category>Static defines</category>
<description>Delimiter for the end of line, if a settings file is used as backend.
</description>
</element>
<element define="1">
<name>CMPSETTINGS_NUM_OF_STATIC_FILES</name>
<key>1</key>
<condition>CMPSETTINGS_NUM_OF_STATIC_FILES</condition>
<category>Static defines</category>
<description>Number of static setting files. Only used by CmpSettings component to handle configuration
files in static data.</description>
</element>
<element define="1">
<name>CMPSETTINGS_MASTER_CONFIG</name>
<key>Master.cfg</key>
<condition>CMPSETTINGS_MASTER_CONFIG</condition>
<category>Static defines</category>
<description>Name of the master configuration file, if standard config file could not be opened</description>
</element>
<element define="1">
<name>CMPSETTINGS_STD_CONFIG</name>
<key>STD_SETTINGS_DATABASE</key>
<condition>CMPSETTINGS_STD_CONFIG</condition>
<category>Static defines</category>
<description>Name of the standard configuration file</description>
</element>
<element define="1">
<name>USERDB_OBJECT_SETTINGS</name>
<key>Device.Settings</key>
<category>Static defines</category>
<description>Predefined objects in the runtime</description>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char *pszName)">SettgSetDatabaseName</functionname>
<description>Set database name for all settings</description>
<param name="pszName" type="IN">Name of settings file. Can be *.cfg or *.ini</param>
<result>ERR_OK</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char *pszName, RTS_SIZE nNameLen)">SettgGetDatabaseName</functionname>
<description>Get database name for all settings</description>
<param name="pszName" type="OUT">Name of settings file. Can be *.cfg or *.ini</param>
<param name="nNameLen" type="IN">Lenght of the name buffer in bytes</param>
<result>Error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(int bSplitDatabases)">SettgSetOptions</functionname>
<description>Set optional settings</description>
<param name="bSeparateDatabases" type="IN">If bSeparateDatabases=1, split settings file into
each file per component</param>
<result>ERR_OK</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(void)">SettgIsOptionSplitDatabases</functionname>
<description>Is option set to split all settings databases into each file per component</description>
<result>ERR_OK</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(const char *pszComponent, const char *pszKey, RTS_I32 *piValue, int iDefault, int bCached)">SettgGetIntValue</functionname>
<description>Get an interger value from settings</description>
<param name="pszComponent" type="IN">Name of component</param>
<param name="pszKey" type="IN">Name of key</param>
<param name="piValue" type="INOUT">Pointer to value fro result</param>
<param name="iDefault" type="IN">Default value to set, if key not found</param>
<param name="bCached" type="IN">Flag, if value should be read cached or always direkt from file</param>
<result>ERR_OK</result>
<result>ERR_FAILED: Key not found</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(const char *pszComponent, const char *pszKey, RTS_I32 iValue, int iBase)">SettgSetIntValue</functionname>
<description>Get an interger value from settings</description>
<param name="pszComponent" type="IN">Name of component</param>
<param name="pszKey" type="IN">Name of key</param>
<param name="iValue" type="IN">Value to write</param>
<param name="iBase" type="IN">2=Base 2, 10=Decimal values, 16=Hex values</param>
<result>ERR_OK</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(const char *pszComponent, const char *pszKey, char *pszValue, int *piLen, char *pszDefault, int bCached)">SettgGetStringValue</functionname>
<description>Get a string value from settings</description>
<param name="pszComponent" type="IN">Name of component</param>
<param name="pszKey" type="IN">Name of key</param>
<param name="pszValue" type="INOUT">Pointer to value for result</param>
<param name="piLen" type="INOUT">Max length of string value as IN and length of copied values excluding the NUL ending as OUT!</param>
<param name="pszDefault" type="IN">Default value to set, if key not found</param>
<param name="bCached" type="IN">Flag, if value should be read cached or always direkt from file</param>
<result>ERR_OK</result>
<result>ERR_FAILED: Key not found</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(const char *pszComponent, const char *pszKey, char *pszValue, RTS_SIZE iLen)">SettgSetStringValue</functionname>
<description>Get a string value from settings</description>
<param name="pszComponent" type="IN">Name of component</param>
<param name="pszKey" type="IN">Name of key</param>
<param name="pszValue" type="IN">Pointer to write value</param>
<param name="iLen" type="IN">Length of string to write excluding the NUL ending</param>
<result>ERR_OK</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(const char *pszComponent, const char *pszKey, RTS_WCHAR *pwszValue, int *piLen, RTS_WCHAR *pwszDefault, int bCached)">SettgGetWStringValue</functionname>
<description>Get a unicode string value from settings</description>
<param name="pszComponent" type="IN">Name of component</param>
<param name="pszKey" type="IN">Name of key</param>
<param name="pwszValue" type="INOUT">Pointer to value for result</param>
<param name="piLen" type="INOUT">Max length of string in unicode characters (not bytes!) as IN and length of copied unicode characters excluding the NUL ending as OUT</param>
<param name="pwszDefault" type="IN">Default value to set, if key not found</param>
<param name="bCached" type="IN">Flag, if value should be read cached or always direkt from file</param>
<result>ERR_OK</result>
<result>ERR_FAILED: Key not found</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(const char *pszComponent, const char *pszKey, RTS_WCHAR *pwszValue, RTS_SIZE iLen)">SettgSetWStringValue</functionname>
<description>Get a unicode string value from settings</description>
<param name="pszComponent" type="IN">Name of component</param>
<param name="pszKey" type="IN">Name of key</param>
<param name="pszValue" type="IN">Pointer to write value</param>
<param name="iLen" type="IN">Length of string in unicode characters (not bytes!) to write without terminating NUL</param>
<result>ERR_OK</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(const char *pszComponent, const char *pszKey)">SettgRemoveKey</functionname>
<description>Remove the specified key</description>
<param name="pszComponent" type="IN">Name of component</param>
<param name="pszKey" type="IN">Name of key</param>
<result>ERR_OK</result>
</element>
</element>
</component>
<component>
<name>CmpSIL2</name>
<description>
<p>This component is seperated into two main parts:</p>
<ul>
<li>Generic Part (CmpSil2.c)</li>
<li>Customer specific part (CmpSIL2OEM.c)</li>
</ul>
<p>The latter should be provided in form of a template, and be implemented
by the OEM customer.</p>
</description>

<copyright>(c) 2003-2011 3S-Smart Software Solutions</copyright>
<element interface="1" name="CmpSIL2Itf">
<interfacename>CmpSIL2</interfacename>
<description>
<p>This is the interface of the SIL2 component. The CmpSIL2 is used to implement several
savety related feates, which are (in this form) only necessary in safety PLCs, following
the Safety SIL2 concept of 3S.</p>
<p>These features include the following:</p>
<ul>
<li>Safe loading of a bootproject</li>
<li>Selftest Hooks</li>
<li>Switch between safe- and unsafe contexts</li>
<li>Safe logger interface</li>
<li>Check functions, to determine the current context and operation mode</li>
<li>Control Flow</li>
</ul>
<p>1) Bootproject</p>
<p>In CoDeSys Control SIL2, the bootproject is always loaded from flash,
and from there, only in the "compact download format", as it is used
by CmpAppEmbedded. In a standard CoDeSys Control Runtime, the bootproject
is implicitely loaded, by CmpApp/CmpAppEmbedded within an init hook, that
is executed during the call of CMInit() at startup.</p>
<p>In CoDeSys Control SIL2, this implicite loading is deactivated. Instead, the
OEM customer has to call SIL2AppBoot() after CMInit().</p>
<p>The reason for this constraint is, that the function SIL2AppBoot() can make
sure that the application is loaded with the constraints that are defined
for a CoDeSys Control SIL2 system. Additionally, it is more safe to load
the application after system startup is completed, because no unsafe init code
is executed anymore after the application is loaded.</p>
<p>2) Selftest Hooks</p>
<p>Virtually every safety system needs some kind of self tests, which are either
executed in every Safety Process Cycle, or within a specific time frame in
the background.</p>
<p>While the selftests in the background need to be seperated into small chunks,
which are executed in the COMM-Cycle (= Super Loop), the selftests at startup
need to be executed at once, to prohibit the execution of the application when
there is an error in the hardware or firmware.</p>
<p>3) Switches between safe- and unsafe contexts</p>
<p>The current execution context is managed by the OEM customer. But, to have
a clear interface to switch between the contexts in a higher level, and to
be able to execute unsafe code when coming from a safe context.</p>
<p>4) Safe logger interface</p>
<p>The standard monitoring of CoDeSys as well as the standard logger are not safe.
Therefore, they may not be usable for the Endcustomer in some circumstances.</p>
<p>To have a safe interface to transport messages and data from the CoDeSys Control
Runtiem to the programming and debugging system, the component CmpSIL2 provides
it's own logger interface, which secures the data from unintended modifications
with a checksum.</p>
<p>4) Check functions</p>
<p>The CmpSIL2 interface specifies a few functions, which need to be implemented by
the OEM customer to determine the current context or operation mode. This is mainly
necessary to restrict the execution of several functions, but there might also
be other use-cases in which those functions migth be helpful for the OEM himself.</p>
<p>5) Control Flow</p>
<p>The component CmpSIL2, provides a control flow logging mechanism, that is used
for diagnostic purposes, to check the control flow of the IEC tasks, before they
are passing their outputs to the I/O drivers.</p>
<p>This interface is generically designed, and may therefore also be used by the OEM
customer, to log and check his own control flow of his subsystems.</p>
<pre>
Example usage:
SIL2_CONTROLFLOW s_IoMgrControlFlow[3];
SIL2ControlFlowLog(s_IoMgrControlFlow, 0);
SIL2ControlFlowLog(s_IoMgrControlFlow, 1);
SIL2ControlFlowLog(s_IoMgrControlFlow, 2);
SIL2ControlFlowCheck(s_IoMgrControlFlow, 3);
</pre>
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element define="1">
<name>CMPSIL2_LOGADD_MAX_STRLEN</name>
<key>36</key>
<condition>CMPSIL2_LOGADD_MAX_STRLEN</condition>
<category>Buffer sizes</category>
<description>Specifies the maximum logable string size.</description>
</element>
<element define="1">
<name>CMPSIL2_LOGADD_MAX_ENTRIES</name>
<key>50</key>
<condition>CMPSIL2_LOGADD_MAX_ENTRIES</condition>
<category>Buffer sizes</category>
<description>Specifies the maximum number of strings.</description>
</element>
<element define="1">
<name>RTS_SIL2_FAIL_GENERAL</name>
<key>0x01</key>
<category>Exceptions</category>
<description>Exceptions: Runtime has encountered an error in safety mode and passes the info to an OEM Interface function</description>
</element>
<element typedefinition="1">
<name>SIL2_CONTROLFLOW</name>
<structname>SIL2_CONTROLFLOW</structname>
<SIL2/>
<category>Typedef</category>
<description><p>Buffertype for Control Flow mechanism</p>
</description>
<rawdata>
typedef struct SIL2_CONTROLFLOW
{
	RTS_UI32 uiPattern;
	RTS_UI32 uiCRC;
} SIL2_CONTROLFLOW;
</rawdata>
</element>
<element typedefinition="1">
<name>sil2checkcallercontext_struct</name>
<structname>sil2checkcallercontext_struct</structname>
<description>sil2checkcallercontext</description>
<rawdata>
typedef struct tagsil2checkcallercontext_struct
{
	RTS_IEC_UDINT udiCallerContextExpected;	VAR_INPUT
	RTS_IEC_RESULT SIL2CheckCallerContext;	VAR_OUTPUT
} sil2checkcallercontext_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>sil2copycodeguid_struct</name>
<structname>sil2copycodeguid_struct</structname>
<description>
<p>Function to copy the current CodeGuid to a given location (by Pointer)</p>
<p>Size is always 16 BYTES! The caller must provided this much space.</p>
</description>
<param name="pDstCodeGuid" type="IN" range="[NULL,VALID_PDSTCODEGUID]">Pointer where the guid should be copied to.</param>
<errorcode name="RTS_RESULT Result" type="ERR_OK">Copy was ok</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_FAILED">Could not get requested Guid.</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_PARAMETER">Pointer invalid</errorcode>
<rawdata>
typedef struct tagsil2copycodeguid_struct
{
	RTS_IEC_BYTE *pDstCodeGuid;			VAR_INPUT
	RTS_IEC_RESULT SIL2CopyCodeGuid;	VAR_OUTPUT
} sil2copycodeguid_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>sil2copydataguid_struct</name>
<structname>sil2copydataguid_struct</structname>
<description>
<p>Function to copy the current DataGuid to a given location (by Pointer)</p>
<p>Size is always 16 BYTES! The caller must provided this much space.</p>
</description>
<param name="pDstCodeGuid" type="IN" range="[NULL,VALID_PDSTDATAGUID]">Pointer where the guid should be copied to.</param>
<errorcode name="RTS_RESULT Result" type="ERR_OK">Copy was ok</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_FAILED">Could not get requested Guid.</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_PARAMETER">Pointer invalid</errorcode>
<rawdata>
typedef struct tagsil2copydataguid_struct
{
	RTS_IEC_BYTE *pDstDataGuid;			VAR_INPUT
	RTS_IEC_RESULT SIL2CopyDataGuid;	VAR_OUTPUT
} sil2copydataguid_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>sil2oemexception_struct</name>
<structname>sil2oemexception_struct</structname>
<description>sil2oemexception</description>
<rawdata>
typedef struct tagsil2oemexception_struct
{
	RTS_IEC_UDINT udiException;			VAR_INPUT
	RTS_IEC_RESULT SIL2OEMException;	VAR_OUTPUT
} sil2oemexception_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>sil2addlog_struct</name>
<structname>sil2addlog_struct</structname>
<description>sil2addlog</description>
<rawdata>
typedef struct tagsil2addlog_struct
{
	RTS_IEC_STRING sMessage[81];		VAR_INPUT
	RTS_IEC_UDINT udiLogId;				VAR_INPUT
	RTS_IEC_RESULT SIL2AddLog;			VAR_OUTPUT
} sil2addlog_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>sil2oemgetoperationmode_struct</name>
<structname>sil2oemgetoperationmode_struct</structname>
<description>sil2oemgetoperationmode</description>
<rawdata>
typedef struct tagsil2oemgetoperationmode_struct
{
	RTS_IEC_UDINT SIL2OEMGetOperationMode;	VAR_OUTPUT
} sil2oemgetoperationmode_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>sil2oemgetcallercontext_struct</name>
<structname>sil2oemgetcallercontext_struct</structname>
<description>sil2oemgetcallercontext</description>
<rawdata>
typedef struct tagsil2oemgetcallercontext_struct
{
	RTS_IEC_UDINT SIL2OEMGetCallerContext;	VAR_OUTPUT
} sil2oemgetcallercontext_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>sil2oemgetmemorystate_struct</name>
<structname>sil2oemgetmemorystate_struct</structname>
<description>sil2oemgetmemorystate</description>
<rawdata>
typedef struct tagsil2oemgetmemorystate_struct
{
	RTS_IEC_BYTE *pAddress;				VAR_INPUT
	RTS_IEC_UDINT udiLength;			VAR_INPUT
	RTS_IEC_UDINT SIL2OEMGetMemoryState;	VAR_OUTPUT
} sil2oemgetmemorystate_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>sil2oemstackisvalid_struct</name>
<structname>sil2oemstackisvalid_struct</structname>
<description>sil2oemstackisvalid</description>
<rawdata>
typedef struct tagsil2oemstackisvalid_struct
{
	RTS_IEC_RESULT SIL2OEMStackIsValid;	VAR_OUTPUT
} sil2oemstackisvalid_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>sil2executenonsafetyjob_struct</name>
<structname>sil2executenonsafetyjob_struct</structname>
<description>sil2executenonsafetyjob</description>
<rawdata>
typedef struct tagsil2executenonsafetyjob_struct
{
	RTS_IEC_BYTE *pfNonSafetyJob;		VAR_INPUT
	RTS_IEC_BYTE *pParam;			VAR_INPUT
	RTS_IEC_ULINT ulSize;			VAR_INPUT
	RTS_IEC_RESULT SIL2ExecuteNonSafetyJob;	VAR_OUTPUT
} sil2executenonsafetyjob_struct;
</rawdata>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(void)">SIL2AppBoot</functionname>
<description>
<p>Function to load and start a Bootproject from Flash</p>
<p>Application Note: The caller must ensure that this function is called only within a safe context!</p>
<p>The SIL2 Component only loads bootprojects, which are in the "compact download format" format, and those only from flash.
This format includes an checksum to check the consistency of that bootproject.
Before loading the bootproject the CmpSIL2 checks this CRC to make sure that the bootproject was not corrupted after CoDeSys Programming System created it.
As the data-initialization is done from bootproject-code, the CRC also covers the data in the bootproject.
The main steps of loading the bootproject are:
</p>
<ul>
<li>Create an application with the given name</li>
<li>Get the Startaddress of the Bootproject in Flash</li>
<li>Allocate Application Areas (Code - Flash, Data - SysMemAllocArea())</li>
<li>Check the Bootproject (Bootproject Type, Target ID, Type, Version) and create GUIDs</li>
<li>Call the Data-Initialization-Code from the bootproject (Relocation, Code Init, Download POU, Global Init, Global Exit) </li>
<li>Set the Application State to loaded</li>
<li>If everything is correct, start the Application</li>
</ul>
<p>Function has no function parameter, but behavior is also dependant on state of bootproject</p>
</description>
<parampseudo name="bExtFuncsAreValid" type="IN" range="[TRUE,FALSE]">Specifies if the application references an unsafe or non-existent external function.</parampseudo>
<parampseudo name="bAreaIsValid" type="IN" range="[TRUE,FALSE]">Specifies if the Areas of the bootapplication are valid or not.</parampseudo>
<parampseudo name="Bootproject.CRC" type="IN" range="[BOOTP_NO_PROJECT,BOOTP_VALID_CRC,BOOTP_INVALID_CRC]">Bootproject in flash, States: valid CRC, invalid CRC </parampseudo>
<parampseudo name="Bootproject.Code" type="IN" range="[RELOC_VALID,RELOC_IDLE,RELOC_EXCEPTION,CODEINIT_VALID,CODEINIT_IDLE,CODEINIT_EXCEPTION,GLOBALINIT_VALID,GLOBALINIT_IDLE,GLOBALINIT_EXCEPTION,DOWNLOAD_POU_VALID,DOWNLOAD_POU_IDLE,DOWNLOAD_POU_EXCEPTION,GLOBALEXIT_VALID,GLOBALEXIT_IDLE,GLOBALEXIT_EXCEPTION]">valid Code, idle Code (harmless), invalid Code producing Exception</parampseudo>
<parampseudo name="Bootproject.TargetType" type="IN" range="[INVALID_TARGET_TYPE,VALID_TARGET_TYPE]">Target Type</parampseudo>
<parampseudo name="Bootproject.TargetID" type="IN" range="[INVALID_TARGET_ID,VALID_TARGET_ID]">Target ID</parampseudo>
<parampseudo name="bExceptionGenerated" type="OUT" range="[FALSE,TRUE]">TRUE, when an exception occured, during execution</parampseudo>
<errorcode name="RTS_RESULT Result" type="ERR_OK">Load Bootproject successful</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_NO_OBJECT">No Bootproject in Flash</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_FAILED">Error while loading Bootapp (memory area could not be allocated, CRC was invalid, or an external function, which was referenced by the application, is not listed in the list of safe functions)</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_TYPE_MISMATCH">wrong DeviceType in Bootproject</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_ID_MISMATCH">wrong DeviceId in Bootproject</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_VERSION_MISMATCH">wrong DeviceVersion in Bootproject</errorcode>
<result>Result of loading bootproject</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_UI32 ulCallerContextExpected)">SIL2CheckCallerContext</functionname>
<description>
<p>Function to check the current Caller Context of the Runtime</p>
<p>Expected Context is checked vs the current context, and an exception is thrown if they are different.</p>
</description>
<param name="ulCallerContextExpected" type="IN" range="[RTS_SIL2_CALLERCTX_SAFE,RTS_SIL2_CALLERCTX_UNSAFE,RTS_SIL2_CALLERCTX_ERROR]">Expected Context, that is checked against current context.</param>
<errorcode name="RTS_RESULT Result" type="ERR_OK">Context is ok</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_FAILED">Context could not be checked successfully, an internal error occured.</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_EXCEPTION">Contexts are different</errorcode>
<result>Returns if comparision was ok or not, or if problem occured.</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(void)">SIL2OEMEnterDebugMode</functionname>
<description>
<p>Function to set Runtime to DebugMode</p>
<p>This function is called from save context after receiving an "EnterDebugMode" online service to set runtime to debug mode</p>
<p>As this function is only called from within save context no further check is required</p>
</description>
<parampseudo name="SIL2OpMode" type="IN" range="[RTS_SIL2_OPMODE_SAFE,RTS_SIL2_OPMODE_DEBUG]">Specifies the current operation mode of the PLC</parampseudo>
<errorcode name="RTS_RESULT Result" type="ERR_OK">Runtime could be set to Debugmode</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_NO_CHANGE">Runtime was already set to Debugmode</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_FAILED">Runtime could not be set to Debugmode</errorcode>
<result>Result of Setting Mode</result>
</element>
<element function="1">
<functionname returntype="void" parameters="(RTS_SIL2_EXCEPTION Exception)">SIL2OEMException</functionname>
<description>
<p>Function to set Runtime into Exception-Mode</p>
<p>Whenever the runtime detects invalid behaviour, values or states, it calls this function with a specific Exception Code.</p>
<p>Depending on the implementation this function may not return!</p>
</description>
<param name="Exception" type="IN" range="[RTS_SIL2_EXCEPTION_LOADBOOTPROJECT,RTS_SIL2_EXCEPTION_BOOTPROJECT_INVALID,RTS_SIL2_EXCEPTION_COMPACTPREPARECODE,RTS_SIL2_EXCEPTION_COMPACTFINISH,RTS_SIL2_EXCEPTION_EXTREFS,RTS_SIL2_EXCEPTION_RUNAFTERDOWNLOAD,RTS_SIL2_EXCEPTION_MEMORY,RTS_SIL2_EXCEPTION_RUNTIME_INIT,RTS_SIL2_EXCEPTION_SCHED_WD,RTS_SIL2_EXCEPTION_CRC_CYCLIC,RTS_SIL2_EXCEPTION_CRC_COMPLETE,RTS_SIL2_EXCEPTION_CRC_INIT,RTS_SIL2_EXCEPTION_LIFE_COUNTER,RTS_SIL2_EXCEPTION_CALLERCONTEXT]">Exception Code</param>
<parampseudo name="bExceptionGenerated" type="OUT" range="[FALSE,TRUE]">TRUE, when an exception occured, during execution</parampseudo>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_UI32 ulCRCExpected)">SIL2OEMRuntimeCheckCyclic</functionname>
<description>
<p>Function to start/continue cyclic Runtime CRC Check</p>
<p>If the check fails, the function SIL2OEMException is called with exception code RTS_SIL2_EXCEPTION_CRC_CYCLIC</p>
<p>The returnvalue ERR_PENDING could be used to control if a cyclic check takes too long</p>
<p>Function does not return if CRC is wrong, as SIL2OEMException is called!</p>
</description>
<param name="ulCRCExpected" type="IN" range="[VALID_CRC,INVALID_CRC]">Expected CRC, that is compared to the one that is calculated</param>
<errorcode name="RTS_RESULT Result" type="ERR_FAILED">Check failed</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_NOTINITIALIZED">Check could not be initialized or is not implemented</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_OK">Check finished calculation and CRC was correct</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_PENDING">Check pending</errorcode>
<result>Result of Cyclic Check</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_UI32 ulCRCExpected)">SIL2OEMRuntimeCheckComplete</functionname>
<description>
<p>Function to start complete Runtime CRC Check</p>
<p>If the check fails, the function SIL2OEMException is called with exception code RTS_SIL2_EXCEPTION_CRC_COMPLETE</p>
<p>Function does not return if CRC is wrong, as SIL2OEMException is called!</p>
</description>
<param name="uiCRCExpected" type="IN" range="[VALID_CRC,INVALID_CRC]">Expected CRC, that is compared to the one that is calculated</param>
<errorcode name="RTS_RESULT Result" type="ERR_FAILED">CRC Check failed</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_NOTINITIALIZED">Check could not be initialized or is not implemented</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_OK">Check finished calculation and CRC was correct</errorcode>
<result>Result of Complete Check</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char* pszMessage,RTS_UI32 ulLogId)">SIL2AddLog</functionname>
<description>
<p>Function to add a secure Logentry</p>
<p>These secure logentries don't use the standard Logging mechanism! With this function it is possible to add secure messages to a Messagequeue within CmpSIL2.
This Messagequeue can be fetched by an Onlineservice from the SIL2 Programmingsystemplugin. The messages are stored and transmitted with a CRC to provide a secure logging.
The maximal length of the string is restricted (CMPSIL2_LOGADD_MAX_STRLEN).
</p>

</description>
<errorcode name="RTS_RESULT Result" type="ERR_FAILED">Entry could not be added to log</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_PARAMETER">Message pointer was NULL, or message was longer than CMPSIL2_LOGADD_MAX_STRLEN</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_OK">Entry could be added to log correctly</errorcode>
<param name="pszMessage" type="IN" range="[NULL,VALID_STRING,LONG_STRING]">String containing the message, must not be longer than CMPSIL2_LOGADD_MAX_STRLEN</param>
<param name="ulLogId" type="IN" range="[RTS_RANGE_OF_ULONG]">Id for own Identification purposes</param>
<result>Result of adding secure Logentry</result>
</element>
<element function="1">
<functionname returntype="RTS_SIL2_OPMODE" parameters="(void)">SIL2OEMGetOperationMode</functionname>
<description>
<p>Function to get the Operationmode of the Runtime</p>
<p>Returns RTS_SIL2_OPMODE_DEBUG or RTS_SIL2_OPMODE_SAFE depending on Operationmode, returns RTS_SIL2_OPMODE_ERROR if error occured or if in unknown state</p>
</description>
<parampseudo name="SIL2OpMode" type="IN" range="[RTS_SIL2_OPMODE_SAFE,RTS_SIL2_OPMODE_DEBUG]">Specifies the current operation mode of the PLC</parampseudo>
<result>Returns SIL2 Operation Mode: RTS_SIL2_OPMODE_DEBUG or RTS_SIL2_OPMODE_SAFE if operation was successful, RTS_SIL2_OPMODE_ERROR if error occured or if in unknown state!</result>
</element>
<element function="1">
<functionname returntype="RTS_UI32" parameters="(void)">SIL2OEMGetCallerContext</functionname>
<description>
<p>Function to get the current Caller Context of the Runtime</p>
<p>Returns RTS_SIL2_CALLERCTX_SAFE or RTS_SIL2_CALLERCTX_UNSAFE depending on Caller context, returns RTS_SIL2_CALLERCTX_ERROR if error occured or if in unknown state</p>
</description>
<parampseudo name="bUnsafeContext" type="IN" range="[FALSE,TRUE]">By default, we are operating in the safe context. If this variable is TRUE, the function is called from an unsafe context.</parampseudo>
<result>Returns SIL2 Caller Context: RTS_SIL2_CALLERCTX_SAFE or RTS_SIL2_CALLERCTX_UNSAFE if operation was successful, RTS_SIL2_CALLERCTX_ERROR if error occured or if in unknown state!</result>
</element>
<element function="1">
<functionname returntype="RTS_SIL2_ADDRESSSTATE" parameters="(RTS_UI8 *pAddress, RTS_UI32 ulLength)">SIL2OEMGetMemoryState</functionname>
<description>
<p>Function to get the MemoryState (safe/unsafe) for a specific Memoryrange </p>
<p>The Addressrange where pAddress points to with the length of ulLength is checked and the corresponding RTS_SIL2_ADDRESSSTATE is returned: RTS_SIL2_ADDRESS_SAFE or RTS_SIL2_ADDRESS_UNSAFE</p>
</description>
<param name="pAddress" type="IN" range="[NULL,SAFE_POINTER,UNSAFE_POINTER]">Pointer to Addressrange to check for Addressstate</param>
<param name="ulLength" type="IN" range="[0,VALID_POINTER_SIZE,ULONG_MAX]">Length of Addressrange to check for Addressstate</param>
<errorcode name="RTS_SIL2_ADDRESSSTATE Result" type="RTS_SIL2_ADDRESS_SAFE">This Addressrange is in Safe Range</errorcode>
<errorcode name="RTS_SIL2_ADDRESSSTATE Result" type="RTS_SIL2_ADDRESS_UNSAFE">This Addressrange is in Unsafe Range</errorcode>
<result>Result for Memoryaddress check</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(void)">SIL2OEMStackIsValid</functionname>
<description>
<p>Function to check if Stack is Valid</p>
<p>This function is called before entering the Safemode, it returns ERR_OK if the stack is valid, and ERR_FAILED if an error occured or was detected!</p>
</description>
<parampseudo name="bStackIsValid" type="IN" range="[FALSE,TRUE]">Define if the current stack is valid.</parampseudo>
<errorcode name="RTS_RESULT Result" type="ERR_OK">Check stack was successful</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_FAILED">Check stack was not successful</errorcode>
<result>Result of Stackcheck</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(void (*pfNonSafetyJob)(void * pParam),void * pParam)">SIL2OEMExecuteNonSafetyJob</functionname>
<description>
<p>Function to delegate a Non-Safety Job</p>
<p>This function can be used to delegate a non-safety job from within the safe-context to be executed from the Unsafe context</p>
<p>The function pfNonSafetyJob has to be called from Unsafe Context with pParam as argument</p>
</description>
<param name="pfNonSafetyJob" type="IN" range="[NULL,VALID_NONSAFETY_FUNCTION]">Function Pointer to NonSafety Job</param>
<param name="pParam" type="IN" range="[NULL,VALID_POINTER]">Pointer to Parameter for NonSafety Job</param>
<parampseudo name="uiCallerCtx" type="IN" range="[RTS_SIL2_CALLERCTX_SAFE,RTS_SIL2_CALLERCTX_UNSAFE]">Specifies the context of the caller</parampseudo>
<errorcode name="RTS_RESULT Result" type="ERR_OK">Job was done correctly</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_FAILED">Job could not be done</errorcode>
<result>Result of delegating a Non-Safety Job</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(void (*pfNonSafetyJob)(void * pParam),void * pParam,RTS_SIZE iSize)">SIL2OEMExecuteNonSafetyJob2</functionname>
<description>
<p>Function to delegate a Non-Safety Job</p>
<p>This function behaves the exact same way as SIL2OEMExecuteNonSafetyJob(), but
it provides also the size of the parameter to the function. This way, the OEM customer
is able to copy the parameter temporarily to a shared memory, message box or a different stack.</p>
</description>
<param name="pfNonSafetyJob" type="IN" range="[NULL,VALID_NONSAFETY_FUNCTION]">Function Pointer to NonSafety Job</param>
<param name="pParam" type="IN" range="[NULL,VALID_POINTER]">Pointer to Parameter for NonSafety Job</param>
<param name="iSize" type="IN" range="[0..VALID_PARAM_SIZE]">Size of Parameter for NonSafety Job</param>
<parampseudo name="uiCallerCtx" type="IN" range="[RTS_SIL2_CALLERCTX_SAFE,RTS_SIL2_CALLERCTX_UNSAFE]">Specifies the context of the caller</parampseudo>
<errorcode name="RTS_RESULT Result" type="ERR_OK">Job was done correctly</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_PARAMETER">A parameter was passed, but the size is 0 or parameter is NULL and size > 0</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_FAILED">Job could not be done</errorcode>
<result>Result of delegating a Non-Safety Job</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(SIL2_CONTROLFLOW* pControlFlow, RTS_UI8 uiCurrID)">SIL2ControlFlowLog</functionname>
<description>
<p>Function to log the program flow</p>
<p>The caller is responsible for providing buffer for storing the control flow data. After having logged, the function
SIL2ControlFlowCheck can be used to check if all control positions have been logged in the correct order. </p>
<p>The Log IDs may not be out of range of the specified log buffer.</p>
</description>
<param name="pControlFlow" type="IN" range="[NULL,VALID_CONTROLFLOW_BUFFER]">Buffer to store control flow data in</param>
<param name="uiCurrID" type="IN" range="[0..NUM_OF_CONTROLFLOW_LOGENTRIES]">Current Log Nr</param>
<errorcode name="RTS_RESULT Result" type="ERR_OK">successfully added logentry to control flow</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_NOBUFFER">pControlFlow was NULL</errorcode>
<result>Result of Log to control-flow</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(SIL2_CONTROLFLOW* pControlFlow, RTS_UI8 uiTotalNr)">SIL2ControlFlowCheck</functionname>
<description>
<p>Function to check the previously logged program flow</p>
<p>The caller is responsible for providing buffer for storing the control flow data. After having logged, the function
SIL2ControlFlowCheck can be used to check if all control positions have been logged in the correct order. </p>
<p>The number of IDs may not be out of range of the specified log buffer.</p>
</description>
<param name="pControlFlow" type="IN" range="[NULL,VALID_CONTROLFLOW_BUFFER,INVALID_CONTROLFLOW_BUFFER]">Buffer to store control flow data in</param>
<param name="uiTotalNr" type="IN" range="[0,NUM_OF_CONTROLFLOW_LOGENTRIES]">Nr of Logs expected or to check</param>
<errorcode name="RTS_RESULT Result" type="ERR_OK">all logentries were added in the correct order, check successfull</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_OUT_OF_LIMITS">uiTotalNr exceeds buffersize</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_NOBUFFER">pControlFlow is NULL</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_FAILED">check failed, order wrong or not all logentries correct</errorcode>
<result>Result of control-flow check</result>
</element>
</element>
</component>
<component>
<name>CmpSrv</name>
<description>
Level 7 communication component of the runtime system. Realizes the server part in the
communication system. Other components can register at this component, if they intend to use
communication services. The communication services are organized in service groups, so one component can
only register one handler to one single service group. This handler will be called, if a service of
the assigned service group is sent.
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element interface="1" name="CmpSrvItf">
<interfacename>CmpSrv</interfacename>
<description>
Interface of the level 7 server.
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element define="1">
<name>HEADERTAG_3S</name>
<key>0xCD55</key>
<description>
Defines the default CoDeSys layer 7 protocol.
</description>
</element>
<element define="1">
<name>HEADERTAG_SAFETY</name>
<key>0x5AF4</key>
<description>
Defines the default safety communication layer 7 protocol.
</description>
</element>
<element define="1">
<name>SG_REPLY_PREFIX</name>
<key>0x0080</key>
<category>Service Groups</category>
<description>
Service groups for the layer 7 communication
</description>
</element>
<element define="1">
<name>SRV_SESSION_ID_EMPTY</name>
<key>0</key>
<description>
Defines some special values for session ids
</description>
</element>
<element define="1">
<name>SRV_NUM_OF_STATIC_GROUPS</name>
<key>SG_MAX_DEFINED</key>
<condition>SRV_NUM_OF_STATIC_GROUPS</condition>
<category>Static defines</category>
<description>Number of static groups</description>
</element>
<element define="1">
<name>SRV_NUM_OF_SYNC_SERVICES</name>
<key>10</key>
<condition>SRV_NUM_OF_SYNC_SERVICES</condition>
<category>Static defines</category>
<description>Max number of services that can be defined for synchronous execution</description>
</element>
<element define="1">
<name>TAG_ERROR</name>
<key>0xFF7F</key>
<category>Service reply tags</category>
<description>
Global service reply tags
</description>
</element>
<element define="1">
<name>EVT_ExecuteOnlineService</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>
NOTE: Every service group can be opened, as it is still provided by the server component! The corresponding
event will created implicitly by the server component, if EventOpen() is called.
Example:
Client calls:				hEvent = CAL_EventOpen([Service group], CMPID_CmpSrv, NULL);
CmpSrv created the event:	hEvent = CAL_EventCreate2([Service group], CMPID_CmpSrv, 1, NULL);

ATTENTION: This feature is only available right after CH_INIT3 step!

</description>
<param name="pEventParam" type="IN">EVTPARAM_CmpSrv</param>
</element>
<element typedefinition="1">
<name>EVTPARAM_CmpSrv</name>
<structname>EVTPARAM_CmpSrv</structname>
<category>Event parameter</category>
<element name="pServceHandlerParameter" type="IN">Pointer to service handler structure</element>
<rawdata>
typedef struct
{
	SERVICEHANDLER_PARAMETER *pServceHandlerParameter;
} EVTPARAM_CmpSrv;
</rawdata>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_UI32 ulChannelId, PROTOCOL_DATA_UNIT pduRequest, PROTOCOL_DATA_UNIT pduReply)">ServerAppHandleRequest</functionname>
<description>Handle one request from the communication layer below (router)</description>
<param name="ulChannelId" type="IN">Id of the channel on which the request arrived</param>
<param name="pduRequest" type="IN">Pointer to the request</param>
<param name="pduReply" type="OUT">Pointer to the request reply</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hRouter, RTS_UI32 ulChannelId, PROTOCOL_DATA_UNIT pduRequest, PROTOCOL_DATA_UNIT pduReply)">ServerAppHandleRequest2</functionname>
<description>
<p>Obsolete: Use ServerAppHandleRequest instead. Will be removed in future versions!</p>
<p>Handle one request from the communication layer below (router)</p></description>
<param name="hRouter" type="IN">Obsolete parameter, should be set to RTS_INVALID_HANDLE.</param>
<param name="ulChannelId" type="IN">Id of the channel on which the request arrived</param>
<param name="pduRequest" type="IN">Pointer to the request</param>
<param name="pduReply" type="OUT">Pointer to the request reply</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_UI32 ulServiceGroup, PFServiceHandler pfServiceHandler)">ServerRegisterServiceHandler</functionname>
<description>Register a handler for requests to a specific service group</description>
<param name="ulServiceGroup" type="IN">The service group which is handled by the provided function</param>
<param name="pfServiceHandler" type="IN">A handler function.</param>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_UI32 ulServiceGroup, PFServiceHandler pfServiceHandler, char *pszRouter)">ServerRegisterServiceHandler2</functionname>
<description>
<p>Obsolete: Use ServerRegisterServiceHandler instead. Will be removed in future versions!</p>
<p>Register a handler for requests to a specific service group</p></description>
<param name="ulServiceGroup" type="IN">The service group which is handled by the provided function</param>
<param name="pfServiceHandler" type="IN">A handler function.</param>
<param name="pszRouter" type="IN">Obsolete parameter, should be set to NULL.</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_UI32 ulServiceGroup, PFServiceHandler2 pfServiceHandler2)">ServerRegisterServiceHandler3</functionname>
<description>
<p>Obsolete: Use ServerRegisterServiceHandler instead. Will be removed in future versions!</p>
<p>Register a handler for requests to a specific service group</p></description>
<param name="ulServiceGroup" type="IN">The service group which is handled by the provided function</param>
<param name="pfServiceHandler2" type="IN">A handler function.</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_UI32 ulServiceGroup, PFServiceHandler pfServiceHandler)">ServerUnRegisterServiceHandler</functionname>
<description>Unregister a handler for requests to a specific service group</description>
<param name="ulServiceGroup" type="IN">The service group which is handled by the provided function</param>
<param name="pfServiceHandler" type="IN">A handler function.</param>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_UI16 usProtocolId, PFServiceHandler pfServiceHandler)">ServerRegisterProtocolHandler</functionname>
<description>
Register a handler for requests of a specific protocol other then HEADERTAG_3S. All requests with that protocol
will be sent to this handler.
</description>
<param name="usProtocolId" type="IN">The protocol id which is handled by the provided function</param>
<param name="pfServiceHandler" type="IN">A handler function.</param>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_UI16 usProtocolId, PFServiceHandler pfServiceHandler, char *pszRouter)">ServerRegisterProtocolHandler2</functionname>
<description>
<p>Obsolete: Use ServerRegisterProtocolHandler instead. Will be removed in future versions!</p>
<p> Register a handler for requests of a specific protocol other then HEADERTAG_3S. All requests with that protocol
will be sent to this handler.</p>
</description>
<param name="usProtocolId" type="IN">The protocol id which is handled by the provided function</param>
<param name="pfServiceHandler" type="IN">A handler function.</param>
<param name="pszRouter" type="IN">Obsolete parameter, should be set to NULL.</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_UI16 usProtocolId, PFServiceHandler pfServiceHandler)">ServerUnRegisterProtocolHandler</functionname>
<description>
Unregister a handler for requests of a specific protocol.
</description>
<param name="usProtocolId" type="IN">The protocol id which is handled by the provided function</param>
<param name="pfServiceHandler" type="IN">A handler function.</param>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_UI32 ulChannelId, PROTOCOL_DATA_UNIT pduData)">ServerFinishRequest</functionname>
<description>
Send a reply to a request previously received by a service handler
</description>
<param name="ulChannelId" type="IN">
Id of the channel on which to answer a reply. Must be the same that was passed in to the service
handler function.
</param>
<param name="pduData" type="IN">
Contains the buffer and the length of the reply data. Buffer must be the same as the one passed in
to the service handler function, the length must not be greater then the maximum reply buffer length.
</param>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_UI32 *pulSessionId)">ServerGenerateSessionId</functionname>
<description>Generates a unique session Id</description>
<param name="pulSessionId" type="OUT">Pointer to get back the generated session Id</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_UI32 ulChannelHandle, RTS_UI32 ulSessionId)">ServerSetSessionId</functionname>
<description>
Stores the session id in the channel instance.
</description>
<param name="ulChannelHandle" type="IN">Id of the channel for which the session id should be set.</param>
<param name="ulSessionId" type="IN">New session id fo the channel.</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_UI32 ulChannelHandle, RTS_UI32 *pulSessionId)">ServerGetSessionId</functionname>
<description>
Retrieves the stored session id from the channel instance.
</description>
<param name="ulChannelHandle" type="IN">Id of the channel for which the session id should be read.</param>
<param name="pulSessionId" type="OUT">Pointer to return the session id.</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_BOOL bRedundant)">ServerSetRedundancyMode</functionname>
<description>Set redundancy mode to enable synchronous execution of services.</description>
<param name="bRedundant" type="IN"></param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(void)">ServerExecuteOnlineService</functionname>
<description>Set flag to execute online service</description>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_UI32 ulChannelId, PROTOCOL_DATA_UNIT pduRequest, PROTOCOL_DATA_UNIT pduReply)">ServerHandleRequest</functionname>
<description>Handle one request (called by CmpRedundancy)</description>
<param name="ulChannelId" type="IN">Id of the channel on which the request arrived</param>
<param name="pduRequest" type="IN">Pointer to the request</param>
<param name="pduReply" type="OUT">Pointer to the request reply</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(BINTAGWRITER *pWriter, PROTOCOL_DATA_UNIT *pduSendBuffer)">SrvGetUserNotificationService</functionname>
<description>Get the last log entry of class LOG_USER_NOTIFY as a toplevel online service tag</description>
<param name="pWriter" type="IN">Pointer to the bintag writer to get the service tag</param>
<param name="pduSendBuffer" type="IN">Pointer to the send buffer to reset the content of the bintag writer</param>
<result>Error code:
<ul>
<li>ERR_OK: There is still an unread log entry of the type LOG_USER_NOTIFY</li>
<li>ERR_NO_OBJECT: No pending log entry of the type LOG_USER_NOTIFY</li>
<li>ERR_NOT_SUPPORTED: Service not supported</li>
</ul>
</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(BINTAGWRITER *pWriter, PROTOCOL_DATA_UNIT *pduSendBuffer, unsigned long ulTagId)">SrvGetUserNotificationService2</functionname>
<description>Get the last log entry of class LOG_USER_NOTIFY as a toplevel online service tag</description>
<param name="pWriter" type="IN">Pointer to the bintag writer to get the service tag</param>
<param name="pduSendBuffer" type="IN">Pointer to the send buffer to reset the content of the bintag writer</param>
<param name="ulTagId" type="IN">TagId to send user notify info</param>
<result>Error code:
<ul>
<li>ERR_OK: There is still an unread log entry of the type LOG_USER_NOTIFY</li>
<li>ERR_NO_OBJECT: No pending log entry of the type LOG_USER_NOTIFY</li>
<li>ERR_NOT_SUPPORTED: Service not supported</li>
</ul>
</result>cmpsrv
</element>
</element>
</component>
<component>
<name>IoDrvUnsafeBridge</name>
<description>
<p>Interface of IoDrvBridge, which links unsafe IO drivers to safe context.</p>
<p>The IoDrvBridge is used to handle unsafe IO drivers. This is done by copying the whole
IO configuration of the downloaded application to unsafe memory and to call the unsafe IO
drivers with the CmpSIL2 interface function SIL2OEMExecuteNonSafetyJob()</p>
<p>The following drawing illustrates how an IO configuration with IoDrvBridge looks like in
CoDeSys. Safe IO drivers are placed directly underneath the device and unsafe IO drivers are
placed underneath the IoDrvBridge. Both the safe IO drivers under the device and the unsafe
IO drivers under IoDrvBridge may be C or IEC IO drivers.</p>
<pre>
. +--------+
. | Device |
. +--------+
.     |
.     |  +----------------+
.     +--| Safe IO driver |
.     |  +----------------+
.     |  +----------------+
.     +--|  IoDrvBridge   |
.        +----------------+
.                |
.                |  +--------------------+
.                +--| Unsafe IO driver 1 |
.                |  +--------------------+
.                |  +--------------------+
.                +--| Unsafe IO driver n |
.                   +--------------------+
</pre>
<p>To handle the copied IO configuration and the supported IO drivers, the following mem pools
and memory is used:</p>
<p>Copied IO configuration: The copied IO configuration is stored in a static buffer, which is
handled by the following local functions:</p>
<ul>
<li>AllocatorBufferInit()</li>
<li>AllocatorAdd()</li>
<li>AllocatorSpaceLeft()</li>
</ul>
<p>These functions take care about the alignment, the current position and the available space left
of the buffer. It is only possible to allocate and not to free memory blocks. The memory blocks to
allocate may be of any size as long as it fits to the memory. The size of the static buffer is defined
by COPIED_IO_CONFIG_SIZE. The alignment of an element depends on the size of the element as follows:</p>
<ul>
<li>(size &gt;= 8) --&gt; align 8</li>
<li>(size &lt; 8 &amp;&amp; &gt;= 4) --&gt; align 4</li>
<li>(size &lt; 4 &amp;&amp; &gt;= 2) --&gt; align 2</li>
<li>(size &gt; 2) --&gt; align 1</li>
</ul>
<p>Example:</p>
<pre>
. s_byCopiedIoConfig
. +---------------------------+
. |        ElementA_1         |
. |             +-------------+
. |             |  ALIGNMENT  |
. +---------------------------+
. |        ElementA_n         |
. |             +-------------+
. |             |  ALIGNMENT  |
. +-------------+-------------+
. | ElementB_1  | ElementB_2  |
. +-------------+-------------+
. | ElementB_3  |  ALIGNMENT  |
. +-------------+-------------+
. |        ElementC_1         |
. +---------------------------+
. |        ElementC_n         |
. +---------------------------+
. |            ...            |
. +---------------------------+
</pre>
<p>Copied IO configuration elements: To be able to link original and copied IO configuration
elements, this local mem pool stores a pointer to the original element list, a pointer to
the copied element list and the number of elements in the list. There is no need to lock this
mem pool for every access, because elements are only added/deleted in IoDrvUpdateConfiguration()
and IoDrvUpdateMapping, which are called from communication context. This mem pool is handled
by the following local functions:</p>
<ul>
<li>MappingListAdd() - to add an element</li>
<li>MappingListGetCopiedElement() - to get the corresponding copied element to an original element</li>
<li>MappingListGetOriginalElement() - to get the corresponding original element to a copied element</li>
<li>MappingListDeleteAllElements() - to remove all elements from the pool</li>
</ul>
<p>The following drawing illustrates an example IO configuration</p>
<pre>
. Original IO config      ElementMappingPool       Copied IO config
.
. +---------------+      +------------------+      +---------------+
. |  Connector_1  |&lt;-----| pOriginalElement |   +-&gt;|  Connector_1  |
. +---------------+      +------------------+   |  +---------------+
. |  Connector_2  |      |  pCopiedElement  |---+  |  Connector_2  |
. +---------------+      +------------------+      +---------------+
. |  Connector_n  |      | NumOfElement = n |      |  Connector_n  |
. +---------------+      +------------------+      +---------------+
. +---------------+      +------------------+      +---------------+
. |  Parameter_1  |&lt;-----| pOriginalElement |   +-&gt;|  Parameter_1  |
. +---------------+      +------------------+   |  +---------------+
. |  Parameter_2  |      |  pCopiedElement  |---+  |  Parameter_2  |
. +---------------+      +------------------+      +---------------+
. |  Parameter_m  |      | NumOfElement = m |      |  Parameter_m  |
. +---------------+      +------------------+      +---------------+
</pre>
<p>Handled IO drivers: s_DriverMappingPool stores elements of DriverMapEntry, which contain the
instance information of the IO driver. There is no need to lock this mem pool for every access,
because elements are only added/deleted in IoDrvUpdateConfiguration() and IoDrvUpdateMapping,
which are called from comm cycle.</p>
<p>The IoDrvBridge is implementing the IoDrv interface and is using the IoMgr interface as
all other IO drivers. The following points describe the handling of unsafe IO drivers in
IoDrv interface function implementations of IoDrvBridge.</p>

<p>IoDrvCreate()</p>

<p>To be able to handle all unsafe IO drivers underneath this IO driver, the IoDrvBridge
must be the first IO driver registered in the IoMgr. This is checked in the IoDrvCreate function
of IoDrvBridge by calling the IoMgr interface function IoMgrGetFirstDriverInstance. If this
function returns an instance of an IO driver, an exception is thrown. If no driver is registered
yet, an instance of the IoDrvBridge is created. After that all other IO drivers may register
in IoMgr as usual.</p>

<p>IoDrvUpdateConfiguration()</p>

<p>This is the first function, which is called by the IoMgr, after an application, containing an
IO configuration was downloaded to the device. The complete connector list and the number of
connectors are passed as parameters. As the IoDrvBridge is the first IO driver, which was
registered in IoMgr, it is also the first IO driver, which is called by the IoMgr. This allows the
IoDrvBridge to take care about the unsafe IO drivers before they are called by the IoMgr from
safe context.</p>
<p>First of all the whole connector list is copied to the copied IO configuration memory by using
the AllocatorAdd() function and an element is added to the CopiedElementListMappingPool with the
MappingListAdd() function. After that all parameter lists of all connectors are copied and mapping
list elements are added similarly to the connector list. To make the copied connector list
consistent, each parameter list pointer is updated to the copied parameter list.</p>
<p>To get the IO driver instances the IoMgr functions IoMgrGetFirstDriverInstance() and
IoMgrGetNextDriverInstance() are used. Those IO drivers, whose module ID is matching one of the
module IDs SUPPORTED_UNSAFE_DRIVERS_LIST, are added to the DriverMappingPool. To avoid calls
from IoMgr to IO drivers, which are handled by the IoDrvBridge, they are unregisters from
IoMgr. The remaining registered IO drivers in IoMgr must be safe IO drivers.</p>
<p>After that, IoDrvUpdateConfiguration() of every supported IO driver is called with
the copied connector list. As every IO driver is registering to connectors in the copied
connector list, the IoDrvBridge must register to all corresponding connectors in the original
connector list and also copy the flags of the copied connectors to the original connectors.</p>
<p>The following example shows an original and a copied connector list. As IoDrvTest is registered
for Connector_1 in the copied connector list, IoDrvBridge must register for the same connector
in the original connector list and copy the flags. When IoDrvBridge is called with an specific,
connector for example to read inputs, it is possible to get the corresponding IO driver, which
is registered for this connector.</p>
<pre>
.
. Original connector list   ElementMappingPool      Copied connector list
.
. +------------------+     +------------------+      +------------------+
. |   Connector_1    |&lt;----| pOriginalElement |   +-&gt;|  Connector_1     |
. |                  |     +------------------+   |  |                  |
. |hIoDrv=IoDrvBridge|     |  pCopiedElement  |---+  |hIoDrv=IoDrvTest_1|
. | dwFlags = 0x1234 |     +------------------+      | dwFlags = 0x1234 |
. |                  |     | NumOfElement = n |      |                  |
. |                  |     +------------------+      |                  |
. +------------------+                               +------------------+
. |   Connector_2    |                               |    Connector_2   |
. |                  |                               |                  |
. |hIoDrv=IoDrvBridge|                               |hIoDrv=IoDrvTest_2|
. | dwFlags = 0x4321 |                               | dwFlags = 0x4321 |
. |                  |                               |                  |
. |                  |                               |                  |
. +------------------+                               +------------------+
. |   Connector_n    |                               |    Connector_n   |
. |                  |                               |                  |
. |hIoDrv=IoDrvBridge|                               |hIoDrv=IoDrvTest_x|
. | dwFlags = 0xAA55 |                               | dwFlags = 0xAA55 |
. |                  |                               |                  |
. |                  |                               |                  |
. +------------------+                               +------------------+
</pre>
<p>When a reset is performed, IoDrvUpdateConfiguration() is called without a connector list to allow
the IO driver to clean up the environment. In case of the IoDrvBridge the copied IO configuration
buffer and all mem pools are cleared. Before the supported IO driver mem pool is cleared, the C
IO drivers are registered in IoMgr again and the IEC driver instances are deleted.</p>

<p>IoDrvUpdateMapping()</p>

<p>IoDrvUpdateMapping() copies the IoConfigTaskMap, IoConfigConnectorMap and IoConfigChannelMap of
the original IO configuration as described in IoDrvUpdateConfiguration. The connector pointers
of the copied IoDrvConnectorMap list are updated to the copied connectors and the parameter
pointers of the copied IoDrvChannelMap list are updated to the copied parameters. Additionally the
memory of every IO channel is duplicated. This means that memory is allocated in the CopiedIoConfig
buffer and the pointer to IEC address is set to this memory in the copied IoDrvChannelMap. The same
thing is done for every parameter of IoConfigParameter, as the parameters may change. Therefore the
pointer dwValue is set to the new memory in every copied IoConfigParameter. At the end all supported
IO drivers are called with the copied IoConfigTaskMap.</p>

<p>IoDrvReadInputs()</p>

<p>The IoDrvReadInputs() function of IoDrvBridge gets the corresponding copied connector map, gets the
registered supported IO driver as described in the example in IoDrvUpdateConfiguration() and calls the
IO driver with the copied connector map. After the IO driver wrote the inputs to the copied memory, the
IoDrvBridge copies this data to the real IEC memory.</p>

<p>IoDrvWriteOutputs()</p>

<p>This function of the IoDrvBridge works similar to IoDrvReadInputs, but it copies the outputs to the
copied IO memory before the IO driver is called.</p>

<p>IoDrvStartBusCycle()</p>

<p>This function gets the corresponding copied connector to the original connector, which is passed as
parameter. Then the unsafe IO driver, which is registered to the copied connector is called with the
copied connector list.</p>

<p>IoDrvGetModuleDiagnosis()</p>

<p>This function may be called from IoMgr and from IO driver context. Usually from IoDrvStartBusCycle.
It sets the connector flags corresponding to the state of the IO driver. The IoDrvGetModuleDiagnosis()
implementation is never called by the supported IO drivers, because they always call their own
implementation of this function and it is not possible to get the changed flags in IoDrvBridge.
Because of this, all flags of the copied connector list are copied in the safe COMM_CYCLE_HOOK of
IoDrvBridge. The period is defined by IODRVBRIDGE_CONNECTOR_FLAGS_UPDATE_PERIOD. When this function is
called from IoMgr(the passed parameter p_IBase handle is equal to s_pIBase of IoDrvBridge) the
corresponding IO driver implementation of IoDrvGetModuleDiagnosis() is called with the corresponding
copied connector.</p>
</description>
<copyright>(c) 2003-2012 3S-Smart Software Solutions</copyright>
<element interface="1" name="IoDrvUnsafeBridgeModuletestItf">
<interfacename>IoDrvUnsafeBridgeModuletest</interfacename>
<description>
<p>IO-driver interface implementation for unsafe IO drivers.</p>
<p>This interface file is only used to create module tests for
the IoDrvUnsafeBridge implementation.</p>
<p>The IoDrvUnsafeBridge is used for usafe I/O drivers written
in C as well as unsafe I/O drivers written in IEC. </p>
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(RTS_HANDLE hIIoDrv, CLASSID ClassId, int iId, RTS_RESULT *pResult)">IoDrvCreate</functionname>
<description>
<p>Create a new I/O driver instance.</p>
<p>This function is obsolete, because the instance has to be created
by the caller before he registers the I/O driver in the I/O Manager.</p>
</description>
<param name="hIIoDrv" type="IN" range="[RTS_INVALID_HANDLE,VALID_IIODRIVER_HANDLE]">Handle to the IO-driver interface. Must be 0 and is filled automatically by calling the CAL_IoDrvCreate() macro!</param>
<param name="ClassId" type="IN" range="[RTS_RANGE_OF_RTS_UI32]">ClassID of the driver. See "Class IDs" section in CmpItf.h or in the Dep.h file of the IO-driver.</param>
<param name="iId" type="IN" range="[RTS_I16_MIN,RTS_I16_MIN+1,0,RTS_I16_MAX/2,RTS_I16_MAX]">Instance number of the IO-driver</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Should return RTS_INVALID_HANDLE</result>
<errorcode name="RTS_RESULT pResult" type="ERR_NOTIMPLEMENTED">Not provided by the driver</errorcode>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hIoDrv, IoDrvInfo **ppInfo)">IoDrvGetInfo</functionname>
<description>
<p>Get a driver specific info structure.</p>
<p>This structure contains IDs and names of the driver.</p>
<p>In the IoDrvUnsafeBridge implementation, the info structure
of the IoDrvUnsafeBridge is returned.</p>
</description>
<param name="hIoDrv" type="IN" range="[RTS_INVALID_HANDLE,VALID_IODRIVER_HANDLE]">Handle to the IO-driver instance</param>
<param name="ppInfo" type="OUT" range="[NULL,VALID_IODRVIERINFO]">Pointer to pointer to the driver info. Pointer must be set by the driver to its internal driver info structure!</param>
<result>Error code</result>
<errorcode name="RTS_RESULT" type="ERR_OK">The info structure was returned successfully</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">hIoDrv was invalid or *ppInfo was NULL</errorcode>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hIoDrv, IoConfigConnector *pConnector)">IoDrvGetModuleDiagnosis</functionname>
<description>
<p>Update Connector Flags in the device tree.</p>
<p>The driver should write the current diagnostic information (available, no driver,
bus error,...) with the function IoDrvSetModuleDiagnosis() to the I/O connector.</p>
<p>This function can be used by other components or from the IEC application to
update the diagnostic flags of the connector. To update the status from the
driver, it has to call this function manually.</p>
<p>The IoDrvUnsafeBridge implementation calls the corresponding unsafe IO driver, which
is responsible for the given connector, with the corresponding copied IO configuration
via SIL2OEMExecuteNonSafetyJob function and copies the updated flags to the original
configuration afterwards.</p>
</description>
<param name="hIoDrv" type="IN" range="[RTS_INVALID_HANDLE,VALID_IODRIVER_HANDLE]">Handle to the IO-driver instance</param>
<param name="pConnector" type="IN" range="[NULL,VALID_CONNECTOR]">Pointer to the connector, that the diagostic information is requested</param>
<parampseudo name="bConnectorCopied" type="IN" range="[TRUE,FALSE]">Given connector was copied before.</parampseudo>
<parampseudo name="bIoDrvStubRegistered" type="IN" range="[TRUE,FALSE]">Is IoDrvStub registered for this connector in the corresponding copied connector.</parampseudo>
<parampseudo name="IoDrvReturnValue" type="OUT">Return value, which should be returned by called IoDrvStub</parampseudo>
<parampseudo name="bRealIODrvFctFailed" type="IN" range="[TRUE,FALSE]">The IoDrvGetModuleDiagnosis function of the real IO driver returned error.</parampseudo>
<result>Error code</result>
<errorcode name="RTS_RESULT" type="ERR_OK">The flags have been updated</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">hIoDrv was invalid or pConnector was NULL</errorcode>
<errorcode name="RTS_RESULT" type="ERR_FAILED">Internal Error</errorcode>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hIoDrv, IoConfigConnector *pConnector)">IoDrvIdentify</functionname>
<description>
<p>Identify plugable I/O card or slave.</p>
<p>If the configurator supports scanning of modules, this
function can be used our of a communication service to
identify a module on the bus or locally on the PLC. This
This might be done by a blinking LED or whatever the hardware
supports.</p>
<p>This function is not implemented in the IoDrvUnsafeBridge implementation and ERR_NOTIMPLEMENTED is returned.</p>
</description>
<param name="hIoDrv" type="IN" range="[RTS_INVALID_HANDLE,VALID_IODRIVER_HANDLE]">Handle to the IO-driver instance</param>
<param name="pConnector" type="IN" range="[NULL,VALID_CONNECTOR]">Pointer to the connector, that should identify itself physically</param>
<parampseudo name="bConnectorCopied" type="IN" range="[TRUE,FALSE]">Given connector was copied before.</parampseudo>
<parampseudo name="bIoDrvStubRegistered" type="IN" range="[TRUE,FALSE]">Is IoDrvStub registered for this connector in the corresponding copied connector.</parampseudo>
<result>Error code</result>
<errorcode name="RTS_RESULT" type="ERR_NOTIMPLEMENTED">Not provided by the driver</errorcode>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hIoDrv, IoConfigConnectorMap *pConnectorMapList, int nCount)">IoDrvReadInputs</functionname>
<description>
<p>Read inputs for one task</p>
<p>This function is called cyclically from every task
that is using inputs. A part of the task map list,
which contains only the data of one connector are passed
to the driver (called connector map list).</p>
<p>If a driver has registered one instance to more
than one connector, it might get more than one call with
a different subset of the task map list.</p>
<p>The I/O driver should read the data from the local
hardware or a buffer and write them to the corresponding
IEC variables.</p>
<p>The IoDrvUnsafeBridgeImplementation passes this call to the corresponding
unsafe io driver with the copied connector list. The inputs are copied to the
original configuration afterwards.</p>
</description>
<param name="hIoDrv" type="IN" range="[RTS_INVALID_HANDLE,VALID_IODRIVER_HANDLE]">Handle to the IO-driver instance</param>
<param name="pConnectorMapList" type="IN" range="[NULL,VALID_CONNECTORMAPLIST]">Pointer to the connector map list</param>
<param name="nCount" type="IN" range="[0..CONNECTORMAPLIST_LEN-1]">Number of entries in the connector map list</param>
<parampseudo name="bConnectorCopied" type="IN" range="[TRUE,FALSE]">Given connector in connector map list was copied before.</parampseudo>
<parampseudo name="bIoDrvStubRegistered" type="IN" range="[TRUE,FALSE]">Is IoDrvStub registered for this connector in the corresponding copied connector.</parampseudo>
<parampseudo name="nContinuousConnectorsA" type="IN" range="[1,2]">Number of connectors for stub driver A</parampseudo>
<parampseudo name="nContinuousConnectorsB" type="IN" range="[0,2]">Number of connectors for stub driver B</parampseudo>
<parampseudo name="bDriverBCalled" type="OUT" range="[TRUE,FALSE]">Driver B called.</parampseudo>
<parampseudo name="IoDrvReturnValue" type="OUT" range="[ERR_OK,ERR_FAILED]">Return value, which should be returned by called IoDrvStub</parampseudo>
<result>Error code</result>
<errorcode name="RTS_RESULT" type="ERR_OK">ReadInputs was executed successfully.</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">hIoDrv was invalid or pConnectorMapList was NULL.</errorcode>
<errorcode name="RTS_RESULT" type="ERR_FAILED">Internal error</errorcode>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hIoDrv, IoConfigConnector *pConnector, IoConfigConnector **ppConnectorList, int *pnCount)">IoDrvScanModules</functionname>
<description>
<p>Scan for submodules of a connector.</p>
<p>This function is executed when the driver is downloaded. It
is called over a communication service.</p>
<p>The I/O driver should search for connected subumodules and
return them via ppConnectorList.</p>
<p>NOTE: This interface is called synchronously and the buffer for
the connector list has to be allocated by the driver.</p>
<p>The buffer might be freed at the next scan or at the next
UpdateConfiguration.</p>
<p>This function is not implemented in the IoDrvUnsafeBridge implementation and ERR_NOTIMPLEMENTED is returned.</p>
</description>
<param name="hIoDrv" type="IN" range="[RTS_INVALID_HANDLE,VALID_IODRIVER_HANDLE]">Handle to the IO-driver instance</param>
<param name="pConnector" type="IN" range="[NULL,VALID_CONNECTOR]">Pointer to the connector, which layout should be scanned</param>
<param name="ppConnectorList" type="OUT" range="[NULL]">Pointer to the scanned connectors (devices) to return</param>
<param name="pnCount" type="OUT" range="[0]">Pointer to the number of entries in the connector list to return</param>
<parampseudo name="bConnectorCopied" type="IN" range="[TRUE,FALSE]">Given connector was copied before.</parampseudo>
<parampseudo name="bIoDrvStubRegistered" type="IN" range="[TRUE,FALSE]">Is IoDrvStub registered for this connector in the corresponding copied connector.</parampseudo>
<result>Error code</result>
<errorcode name="RTS_RESULT" type="ERR_NOTIMPLEMENTED">Scan feature is not implemented</errorcode>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hIoDrv, IoConfigConnector *pConnector)">IoDrvStartBusCycle</functionname>
<description>
<p>Start bus cycle for a specific connector.</p>
<p>The bus cycle task is defined globally for the whole PLC
or locally for a specific I/O connector in the CoDeSys project.
This call can be used by the I/O driver to flush the I/O data
if it was cached before.</p>
<p>This way we can get a better and consistent timing on the bus.</p>d
<p>Note: This function is called for every connector which has a
registered I/O driver and "needsbuscycle" set in the device description
(this means that it might also be called for children of the connector).</p>
<p>Depending on the device description, this function might be executed
at the beginning or at the end of the task cycle.</p>
<p>The IoDrvUnsafeBridgeImplementation passes this call to the corresponding
unsafe io driver with the copied connector list.</p>
</description>
<param name="hIoDrv" type="IN" range="[RTS_INVALID_HANDLE,VALID_IODRIVER_HANDLE]">Handle to the IO-driver instance</param>
<param name="pConnector" type="IN" range="[NULL,VALID_CONNECTOR]">Pointer to the connector, on which the buscycle must be triggered</param>
<parampseudo name="bConnectorCopied" type="IN" range="[TRUE,FALSE]">Given connector was copied before.</parampseudo>
<parampseudo name="bIoDrvStubRegistered" type="IN" range="[TRUE,FALSE]">Is IoDrvStub registered for this connector in the corresponding copied connector.</parampseudo>
<parampseudo name="IoDrvReturnValue" type="OUT">Return value, which should be returned by called IoDrvStub</parampseudo>
<parampseudo name="bRealIODrvFctFailed" type="IN" range="[TRUE,FALSE]">The IoDrvStartBusCycle function of the real IO driver returned error.</parampseudo>
<result>Error code</result>
<errorcode name="RTS_RESULT" type="ERR_OK">Bus cycle was triggered</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">hIoDrv was invalid or pConnector NULL</errorcode>
<errorcode name="RTS_RESULT" type="ERR_FAILED">Internal Error</errorcode>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hIoDrv, IoConfigConnector *pConnectorList, int nCount)">IoDrvUpdateConfiguration</functionname>
<description>
<p>Propagate I/O configuration to the drivers.</p>
<p>This call passes the I/O configuration (based on the
configuration tree in the CoDeSys programming system) to
all registered I/O drivers. Every driver has the chance
to pass this tree and to register itself for a specific
connector.</p>
<p>The driver can use the I/O Manager Interface to iterate
over the I/O Connectors and to read the I/O Parameters.
If it decides to handle the I/Os of one of those connectors,
it can register it's driver handle (IBase) to the connector
in the member hIoDrv.</p>
<p>This function is called when the application is initialized
as well as when it is de- or reinitialized. In this case it is
called with pConnectorList = NULL.</p>
<p>The implementation of the IoDrvUnsafeBridge copies the io configuration
to unsafe memory, unregisteres supported IO drivers from IoMgr and puts them
to local administration and calls the IoDrvUpdateConfiguration functions of
the supported IO drivers.</p>
</description>
<param name="hIoDrv" type="IN" range="[RTS_INVALID_HANDLE,VALID_IODRIVER_HANDLE]">Handle to the IO-driver instance</param>
<param name="pConnectorList" type="IN" range="[NULL,CONNECTORLIST_HUGE,CONNECTORLIST_HUGE_PARAMETERLIST,CONNECTORLIST_HUGE_PARAMETERVALUES,CONNECTORLIST_VALID_UNSAFE_PARAMETERVALUES,CONNECTORLIST_VALID]">Pointer to the complete connector list</param>
<param name="nCount" type="IN" range="[0,CONNECTORLIST_LEN]">Number of entries in the connector list</param>
<parampseudo name="bFirstIoDrv" type="IN" range="[TRUE,FALSE]">Is IoDrvUnsafeBridge the first registered IO driver</parampseudo>
<parampseudo name="bInitialized" type="IN" range="[TRUE,FALSE]">UpdateConfiguration initialized and connector and parameter lists copied before</parampseudo>
<parampseudo name="nIoDrvStub" type="IN" range="[NOIODRVSTUB,CIODRVSTUB,IECIODRVSTUB]">Is IoDrvStub registered for this connector in the corresponding copied connector and is a C or IEC driver.</parampseudo>
<parampseudo name="bRealIODrvFctFailed" type="IN" range="[TRUE,FALSE]">The IoDrvUpdateConfiguration function of the real IO driver returned error.</parampseudo>
<parampseudo name="IoDrvReturnValue" type="OUT" range="[ERR_OK,ERR_FAILED]">Return value, which should be returned by called IoDriver</parampseudo>
<parampseudo name="bParamValuesCopied" type="OUT" range="[TRUE,FALSE]">Return value, which should be returned by called IoDriver</parampseudo>
<result>Error code</result>
<errorcode name="RTS_RESULT" type="ERR_OK">UpdateConfiguration was successfull and found a driver</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">hIoDrv was invalid or pConnector NULL</errorcode>
<errorcode name="RTS_RESULT" type="ERR_NOMEMORY">Not enought space to copy configuration</errorcode>
<errorcode name="RTS_RESULT" type="ERR_FAILED">Internal Error</errorcode>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hIoDrv, IoConfigTaskMap *pTaskMapList, int nCount)">IoDrvUpdateMapping</functionname>
<description>
<p>Propagate the task map lists to the drivers.</p>
<p>This functions gives the drivers a chance to optimize
their internal data structures based on the real task map
lists. The function is called on every initialization
of the application (download, bootproject,...).</p>
</description>
<param name="hIoDrv" type="IN" range="[RTS_INVALID_HANDLE,VALID_IODRIVER_HANDLE]">Handle to the IO-driver instance</param>
<param name="pTaskMapList" type="IN" range="[NULL,TASKMAPLIST_HUGE,TASKMAPLIST_HUGE_CONNECTORMAPLIST,TASKMAPLIST_HUGE_CHANNELMAPLIST,TASKMAPLIST_HUGE_IOMEM,TASKMAPLIST_VALID]">Pointer to the task map list of one task</param>
<param name="nCount" type="IN" range="[0,TASKMAPLIST_LEN]">Number of entries in the map list</param>
<parampseudo name="bInitialized" type="IN" range="[TRUE,FALSE]">UpdateConfiguration initialized and connector and parameter lists copied before</parampseudo>
<parampseudo name="bIoDrvStubRegistered" type="IN" range="[TRUE,FALSE]">Is IoDrvStub registered for this connector in the corresponding copied connector.</parampseudo>
<parampseudo name="bRealIODrvFctFailed" type="IN" range="[TRUE,FALSE]">The IoDrvUpdateMapping function of the real IO driver returned error.</parampseudo>
<parampseudo name="IoDrvReturnValue" type="OUT" range="[ERR_OK,ERR_FAILED]">Return value, which should be returned by called IoDriver</parampseudo>
<result>Error code</result>
<errorcode name="RTS_RESULT" type="ERR_OK">UpdateMapping successful</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">hIoDrv was invalid</errorcode>
<errorcode name="RTS_RESULT" type="ERR_NOMEMORY">Not enought space to copy configuration</errorcode>
<errorcode name="RTS_RESULT" type="ERR_FAILED">Internal Error</errorcode>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hIoDrv, IoConfigConnector *pConnector)">IoDrvWatchdogTrigger</functionname>
<description>
<p>Trigger the hardware watchdog of a driver.</p>
<p>This function is depricated and not used anymore.</p>
<p>This function is not implemented in the IoDrvUnsafeBridge implementation and ERR_NOTIMPLEMENTED is returned.</p>
</description>
<param name="hIoDrv" type="IN" range="[RTS_INVALID_HANDLE,VALID_IODRIVER_HANDLE]">Handle to the IO-driver instance</param>
<param name="pConnector" type="IN" range="[NULL,VALID_CONNECTOR]">Pointer to the connector, on which the watchdog should be retriggered</param>
<parampseudo name="bConnectorCopied" type="IN" range="[TRUE,FALSE]">Given connector was copied before.</parampseudo>
<parampseudo name="bIoDrvStubRegistered" type="IN" range="[TRUE,FALSE]">Is IoDrvStub registered for this connector in the corresponding copied connector.</parampseudo>
<result>Error code</result>
<errorcode name="RTS_RESULT" type="ERR_NOTIMPLEMENTED">Not provided by the driver</errorcode>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hIoDrv, IoConfigConnectorMap *pConnectorMapList, int nCount)">IoDrvWriteOutputs</functionname>
<description>
<p>Write outputs for one task</p>
<p>This function is called cyclically from every task
that is using outputs. A part of the task map list,
which contains only the data of one connector are passed
to the driver (called connector map list).</p>
<p>If a driver has registered one instance to more
than one connector, it might get more than one call with
a different subset of the task map list.</p>
<p>The I/O driver should write out the data to the local
hardware, a buffer or a fieldbus.</p>
<p>The IoDrvUnsafeBridgeImplementation copies the output values to unsafe
memory and passes this call to the corresponding unsafe io driver with the
copied connector list.</p>
</description>
<param name="hIoDrv" type="IN" range="[RTS_INVALID_HANDLE,VALID_IODRIVER_HANDLE]">Handle to the IO-driver instance</param>
<param name="pConnectorMapList" type="IN" range="[NULL,VALID_CONNECTORMAPLIST]">Pointer to the connector map list</param>
<param name="nCount" type="IN" range="[0..CONNECTORMAPLIST_LEN-1]">Number of entries in the connector map list</param>
<parampseudo name="bConnectorCopied" type="IN" range="[TRUE,FALSE]">Given connector was copied before.</parampseudo>
<parampseudo name="bIoDrvStubRegistered" type="IN" range="[TRUE,FALSE]">Is IoDrvStub registered for this connector in the corresponding copied connector.</parampseudo>
<parampseudo name="nContinuousConnectorsA" type="IN" range="[1,2]">Number of connectors for stub driver A</parampseudo>
<parampseudo name="nContinuousConnectorsB" type="IN" range="[0,2]">Number of connectors for stub driver B</parampseudo>
<parampseudo name="bDriverBCalled" type="OUT" range="[TRUE,FALSE]">Driver B called.</parampseudo>
<parampseudo name="IoDrvReturnValue" type="OUT" range="[ERR_OK,ERR_FAILED]">Return value, which should be returned by called IoDrvStub</parampseudo>
<result>Error code</result>
<errorcode name="RTS_RESULT" type="ERR_OK">Outputs successfully written</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">hIoDrv was invalid or pConnectorMapList NULL</errorcode>
<errorcode name="RTS_RESULT" type="ERR_FAILED">Internal Error</errorcode>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hDevice, IoConfigConnector *pConnector, IoConfigParameter *pParameter, void *pData, RTS_SIZE ulBitSize, RTS_SIZE ulBitOffset)">IoDrvReadParameter</functionname>
<description>
<p>Read a driver specific parameters.</p>
<p>These parameters can be read by the application, as
well as, by an online service, which is triggered from
the device configurator plugin in the CoDeSys programming
system.</p>
<p>Note: If the I/O driver returns an error, the I/O
Manager may try to read the parameter himself</p>
<p>Note2: On SIL2 runtimes, this interface is not supported.</p>
</description>
<param name="hDevice" type="IN" range="[RTS_INVALID_HANDLE,VALID_IODRIVER_HANDLE]">Handle to the IO-driver instance</param>
<param name="pConnector" type="IN" range="[NULL,VALID_CONNECTOR]">Pointer to the connector (might be determined with IoMgrConfigGetConnector).</param>
<param name="pParameter" type="IN" range="[NULL,VALID_PARAMETER]">Pointer to the parameter (might be determined with IoMgrConfigGetParameter)</param>
<param name="pData" type="IN" range="[NULL,VALID_DATABUFFER]">Buffer where the read data is stored</param>
<param name="ulBitSize" type="IN" range="[0..PARAM_SIZE-1]">Size of the part of the parameter data, that should be read</param>
<param name="ulBitOffset" type="IN" range="[0..PARAM_SIZE-1]">Offset of the part of the parameter, that should be read</param>
<result>Error code</result>
<errorcode name="RTS_RESULT" type="ERR_NOTIMPLEMENTED">Not provided by the driver</errorcode>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hDevice, IoConfigConnector *pConnector, IoConfigParameter *pParameter, void *pData, RTS_SIZE ulBitSize, RTS_SIZE ulBitOffset)">IoDrvWriteParameter</functionname>
<description>
<p>Write a driver specific parameters.</p>
<p>These parameters can be written by the application, as
well as, by an online service, which is triggered from
the device configurator plugin in the CoDeSys programming
system.</p>
<p>Note: On SIL2 runtimes, this interface is not supported.</p>
</description>
<param name="hDevice" type="IN" range="[RTS_INVALID_HANDLE,VALID_IODRIVER_HANDLE]">Handle to the IO-driver instance</param>
<param name="pConnector" type="IN" range="[NULL,VALID_CONNECTOR]">Pointer to the connector (might be determined with IoMgrConfigGetConnector).</param>
<param name="pParameter" type="IN" range="[NULL,VALID_PARAMETER]">Pointer to the parameter (might be determined with IoMgrConfigGetParameter)</param>
<param name="pData" type="IN" range="[NULL,VALID_DATABUFFER]">Buffer where the read data is stored</param>
<param name="ulBitSize" type="IN" range="[0..PARAM_SIZE-1]">Size of the part of the parameter data, that should be written</param>
<param name="ulBitOffset" type="IN" range="[0..PARAM_SIZE-1]">Offset of the part of the parameter, that should be written</param>
<result>Error code</result>
<errorcode name="RTS_RESULT" type="ERR_NOTIMPLEMENTED">Not provided by the driver</errorcode>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hIoDrv, RTS_HANDLE hIIoDrv)">IoDrvDelete</functionname>
<description>
<p>Delete an I/O driver instance.</p>
<p>This function is obsolete, because the instance has to be deleted
by the caller after he unregisters the I/O driver from the I/O Manager.</p>
</description>
<description>Delete an IO-driver instance</description>
<param name="hIoDrv" type="IN" range="[RTS_INVALID_HANDLE,VALID_IODRIVER_HANDLE]">Handle to the IO-driver instance</param>
<param name="hIIoDrv" type="IN" range="[RTS_INVALID_HANDLE,VALID_IIODRIVER_HANDLE]">Handle of the ITFID_ICmpIoDrv interface</param>
<result>Error code</result>
<errorcode name="RTS_RESULT pResult" type="ERR_NOTIMPLEMENTED">Not provided by the driver</errorcode>
</element>
</element>
</component>
<component>
<name>SysCom</name>
<description>
System component that allows access to the serial interface.
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element interface="1" name="SysComItf">
<interfacename>SysCom</interfacename>
<description>
<p>The SysCom interface is projected to connect to a serial COM port (RS232) and
to send and receive data via this port.</p>
<p>IMPLEMENTATION NODE: All routines must be realized asynchronous! You have to use the FIFO of
the serial device! Don't block the read and write routines, until the operations are finished.</p>
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element define="1">
<name>EVT_SysComOpenBefore</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Platform dependent event. Sent before the physical driver open.</description>
<param name="pEventParam" type="IN">EVTPARAM_SysComOpenBefore</param>
</element>
<element define="1">
<name>EVT_SysComOpenAfter</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Platform dependent event. Sent directly after the physical driver open.</description>
<param name="pEventParam" type="IN">EVTPARAM_SysComOpenAfter</param>
</element>
<element define="1">
<name>SYS_NOWAIT</name>
<key>0UL</key>
<category>Timeouts</category>
<description></description>
</element>
<element define="1">
<name>SYS_BR_4800</name>
<key>4800UL</key>
<category>Baudrates</category>
<description></description>
</element>
<element typedefinition="1">
<name>EVTPARAM_SysComOpen</name>
<structname>EVTPARAM_SysComOpen</structname>
<category>Event parameter</category>
<element name="device" type="IN">Name of serial device</element>
<rawdata>
typedef struct
{
	unsigned char* name;
} EVTPARAM_SysComOpen;
</rawdata>
</element>
<element typedefinition="1">
<name>COM_SettingsEx</name>
<structname>COM_SettingsEx</structname>
<category>Com port extended settings</category>
<description></description>
<element name="byByteSize" TYPE="IN">Number OF bits/BYTE, 4-8</element>
<element name="bBinary" TYPE="IN">binary mode, no EOF check</element>
<element name="bOutxCtsFlow" TYPE="IN">CTS handshaking on output</element>
<element name="bOutxDsrFlow" TYPE="IN">DSR handshaking on output</element>
<element name="bDtrControl" TYPE="IN">DTR Flow control</element>
<element name="bDsrSensitivity" TYPE="IN">DSR Sensitivity</element>
<element name="bRtsControl" TYPE="IN">Rts Flow control</element>
<element name="bTXContinueOnXoff" TYPE="IN">XOFF continues Tx</element>
<element name="bOutX" TYPE="IN">XON/XOFF out flow control</element>
<element name="bInX" TYPE="IN">XON/XOFF in flow control</element>
<element name="XonChar" TYPE="IN">Tx AND Rx XON character</element>
<element name="XoffChar" TYPE="IN">Tx AND Rx XOFF character</element>
<element name="XonLim" TYPE="IN">transmit XON threshold</element>
<element name="XoffLim" TYPE="IN">transmit XOFF threshold</element>
<rawdata>
typedef struct tagCOM_SettingsEx
{
	RTS_IEC_BYTE byByteSize;
	RTS_IEC_BOOL bBinary;
	RTS_IEC_BOOL bOutxCtsFlow;
	RTS_IEC_BOOL bOutxDsrFlow;
	RTS_IEC_BOOL bDtrControl;
	RTS_IEC_BOOL bDsrSensitivity;
	RTS_IEC_BOOL bRtsControl;
	RTS_IEC_BOOL bTXContinueOnXoff;
	RTS_IEC_BOOL bOutX;
	RTS_IEC_BOOL bInX;
	RTS_IEC_BYTE byXonChar;
	RTS_IEC_BYTE byXoffChar;
	RTS_IEC_WORD wXonLim;
	RTS_IEC_WORD wXoffLim;
} COM_SettingsEx;
</rawdata>
</element>
<element typedefinition="1">
<name>COM_Settings</name>
<structname>COM_Settings</structname>
<category>Com port settings</category>
<description></description>
<element name="sPort" type="IN">Port number: 0=disabled, 1=COM1, 2=COM2, .... See category "Com ports"</element>
<element name="ulBaudRate" type="IN">Baudrate. See "category "Baudrates"</element>
<element name="byStopBits" type="IN">Stop bits. See category "Stop bits"</element>
<element name="byParity" type="IN">Parity. See category "Parity"</element>
<element name="ulTimeout" TYPE="IN">Hardware timeout. The Timeout is the TIME between two received OR sent
characters until the read or write operation will return.
Typically this value should be 0 (returns immediately)</element>
<element name="ulBufferSize" type="IN">Buffersize of FIFO buffer</element>
<rawdata>
typedef struct tagCOM_Settings
{
	RTS_IEC_INT sPort;
	RTS_IEC_BYTE byStopBits;
	RTS_IEC_BYTE byParity;
	RTS_IEC_DWORD ulBaudrate;
	RTS_IEC_UDINT ulTimeout;
	RTS_IEC_UDINT ulBufferSize;
} COM_Settings;
</rawdata>
</element>
<element typedefinition="1">
<name>syscompurge_struct</name>
<structname>syscompurge_struct</structname>
<description>syscompurge</description>
<rawdata>
typedef struct tagsyscompurge_struct
{
	RTS_IEC_BYTE *hCom;					VAR_INPUT
	RTS_IEC_UDINT SysComPurge;			VAR_OUTPUT
} syscompurge_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>syscomread_struct</name>
<structname>syscomread_struct</structname>
<description>syscomread</description>
<rawdata>
typedef struct tagsyscomread_struct
{
	RTS_IEC_BYTE *hCom;					VAR_INPUT
	RTS_IEC_BYTE *pbyBuffer;			VAR_INPUT
	RTS_IEC_UDINT ulSize;				VAR_INPUT
	RTS_IEC_UDINT ulTimeout;			VAR_INPUT
	RTS_IEC_UDINT *pResult;				VAR_INPUT
	RTS_IEC_UDINT SysComRead;			VAR_OUTPUT
} syscomread_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>syscomclose_struct</name>
<structname>syscomclose_struct</structname>
<description>syscomclose</description>
<rawdata>
typedef struct tagsyscomclose_struct
{
	RTS_IEC_BYTE *hCom;					VAR_INPUT
	RTS_IEC_UDINT SysComClose;			VAR_OUTPUT
} syscomclose_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>syscomwrite_struct</name>
<structname>syscomwrite_struct</structname>
<description>syscomwrite</description>
<rawdata>
typedef struct tagsyscomwrite_struct
{
	RTS_IEC_BYTE *hCom;					VAR_INPUT
	RTS_IEC_BYTE *pbyBuffer;			VAR_INPUT
	RTS_IEC_UDINT ulSize;				VAR_INPUT
	RTS_IEC_UDINT ulTimeout;			VAR_INPUT
	RTS_IEC_UDINT *pResult;				VAR_INPUT
	RTS_IEC_UDINT SysComWrite;			VAR_OUTPUT
} syscomwrite_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>syscomopen_struct</name>
<structname>syscomopen_struct</structname>
<description>Open a serial communication device</description>
<param name="wPort" type="IN">Number of the port to open: 1=COM1, 2=COM2, ...</param>
<param name="pResult" type="OUT">Pointer to error code </param>
<result>Handle to the interface or RTS_INVALID_HANDLE if failed</result>
<rawdata>
typedef struct tagsyscomopen_struct
{
	RTS_IEC_INT sPort;					VAR_INPUT
	RTS_IEC_UDINT *pResult;				VAR_INPUT
	RTS_IEC_BYTE *SysComOpen;			VAR_OUTPUT
} syscomopen_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>syscomsettimeout_struct</name>
<structname>syscomsettimeout_struct</structname>
<description>syscomsettimeout</description>
<rawdata>
typedef struct tagsyscomsettimeout_struct
{
	RTS_IEC_BYTE *hCom;					VAR_INPUT
	RTS_IEC_UDINT ulTimeout;			VAR_INPUT
	RTS_IEC_UDINT SysComSetTimeout;		VAR_OUTPUT
} syscomsettimeout_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>syscomgetsettings_struct</name>
<structname>syscomgetsettings_struct</structname>
<description>syscomgetsettings</description>
<rawdata>
typedef struct tagsyscomgetsettings_struct
{
	RTS_IEC_BYTE *hCom;					VAR_INPUT
	COM_Settings *pSettings;			VAR_INPUT
	COM_SettingsEx *pSettingsEx;		VAR_INPUT
	RTS_IEC_UDINT SysComGetSettings;	VAR_OUTPUT
} syscomgetsettings_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>syscomsetsettings_struct</name>
<structname>syscomsetsettings_struct</structname>
<description>syscomsetsettings</description>
<rawdata>
typedef struct tagsyscomsetsettings_struct
{
	RTS_IEC_BYTE *hCom;					VAR_INPUT
	COM_Settings *pSettings;			VAR_INPUT
	COM_SettingsEx *pSettingsEx;		VAR_INPUT
	RTS_IEC_UDINT SysComSetSettings;	VAR_OUTPUT
} syscomsetsettings_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>syscomopen2_struct</name>
<structname>syscomopen2_struct</structname>
<description>syscomopen2</description>
<rawdata>
typedef struct tagsyscomopen2_struct
{
	COM_Settings *pSettings;			VAR_INPUT
	COM_SettingsEx *pSettingsEx;		VAR_INPUT
	RTS_IEC_UDINT *pResult;				VAR_INPUT
	RTS_IEC_BYTE *SysComOpen2;			VAR_OUTPUT
} syscomopen2_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>COM_Parity</name>
<enumname>COM_Parity</enumname>
<category>Parity</category>
<description></description>
<rawdata>
typedef enum
{
	SYS_NOPARITY = 0,
	SYS_ODDPARITY = 1,
	SYS_EVENPARITY = 2
} COM_Parity;
</rawdata>
</element>
<element typedefinition="1">
<name>COM_StopBits</name>
<enumname>COM_StopBits</enumname>
<category>Stop bits</category>
<description></description>
<rawdata>
typedef enum
{
	SYS_ONESTOPBIT = 1,
	SYS_ONE5STOPBITS = 2,
	SYS_TWOSTOPBITS = 3
} COM_StopBits;
</rawdata>
</element>
<element typedefinition="1">
<name>COM_Ports</name>
<enumname>COM_Ports</enumname>
<category>Com ports</category>
<description>Com port numbers</description>
<rawdata>
typedef enum
{
	SYS_COMPORT_NONE = 0,
	SYS_COMPORT1 = 1,
	SYS_COMPORT2 = 2,
	SYS_COMPORT3 = 3,
	SYS_COMPORT4 = 4
} COM_Ports;
</rawdata>
</element>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(short sPort, RTS_RESULT *pResult)">SysComOpen</functionname>
<description>Open a serial communication device</description>
<param name="sPort" type="IN">Number of the Port to open: 1=COM1, 2=COM2, ...</param>
<param name="pResult" type="OUT">Pointer to error code </param>
<result>Handle to the interface or RTS_INVALID_HANDLE if failed</result>
</element>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(COM_Settings *pSettings, COM_SettingsEx *pSettingsEx, RTS_RESULT *pResult)">SysComOpen2</functionname>
<description>Opens a serial communication device specified with settings</description>
<param name="pSettings" type="IN">Settings for the communication device.
See category "Com port settings" for detailed information</param>
<param name="pSettingsEx" type="IN">Optional extended settings for the serial device. Can be NULL.</param>
<param name="pResult" type="OUT">Pointer to error code </param>
<result>Handle to the interface or RTS_INVALID_HANDLE if failed</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hCom, COM_Settings *pSettings, COM_SettingsEx *pSettingsEx)">SysComSetSettings</functionname>
<description>Set the parameter of the interface specified by handle</description>
<param name="hCom" type="IN">Handle to Com Port</param>
<param name="pSettings" type="IN">Pointer to new settings</param>
<param name="pSettingsEx" type="IN">Pointer to extended settings</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hCom, COM_Settings *pSettings, COM_SettingsEx *pSettingsEx)">SysComGetSettings</functionname>
<description>Get the parameter of the interface specified by handle</description>
<param name="hCom" type="IN">Handle to Com Port</param>
<param name="pSettings" type="IN">Pointer to new settings</param>
<param name="pSettingsEx" type="IN">Pointer to extended settings</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="unsigned int" parameters="(RTS_HANDLE hCom, unsigned char *pbyBuffer, unsigned int uiSize, unsigned long ulTimeout, RTS_RESULT *pResult)">SysComRead</functionname>
<description>Reads a number bytes from the specifed device to the receive buffer.

<p>IMPLEMENTATION NOTE: If the timeout elapsed until the requested number of bytes are received,
the function returns with the bytes still received! This must be considered in the caller and
the implementation!</p></description>

<param name="hCom" type="IN">Handle to com port</param>
<param name="pbyBuffer" type="IN">Pointer to data buffer for received data</param>
<param name="uiSize" type="IN">Requested number of bytes to read. Must be less or equal the size
of the receive buffer!</param>
<param name="ulTimeout" type="IN">Timeout to read data from the device. 0=Immediate return.
If the timeout elapsed, the function returns with the still received data (could be less then the
requested number of bytes!)</param>
<param name="pResult" type="IN">Pointer to error code, ERR_TIMEOUT if timeout elapsed</param>
<result>Number of actually read bytes</result>
</element>
<element function="1">
<functionname returntype="unsigned int" parameters="(RTS_HANDLE hCom, unsigned char *pbyBuffer, unsigned int uiSize, unsigned long ulTimeout, RTS_RESULT *pResult)">SysComWrite</functionname>
<description>Writes a number bytes to the specifed device from the sent buffer.

<p>IMPLEMENTATION NOTE: If the timeout elapsed until the requested number of bytes are sent,
the function returns with the bytes still sent! This must be considered in the caller and
the implementation!</p></description>

<param name="hCom" type="IN">Handle to com port</param>
<param name="pbyBuffer" type="IN">Pointer to data buffer for sent data</param>
<param name="uiSize" type="IN">Requested number of bytes to sent. Must be less or equal the size
of the sent buffer!</param>
<param name="ulTimeout" type="IN">Timeout to sent data to the device. 0=Immediate return.
If the timeout elapsed, the function returns with the still sent data (could be less then the
requested number of bytes!)</param>
<param name="pResult" type="IN">Pointer to error code, ERR_TIMEOUT if timeout elapsed</param>
<result>Number of actually written bytes</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hCom)">SysComPurge</functionname>
<description>Clear the fifo buffer of the serial interface</description>
<param name="hCom" type="IN">Handle to com port</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hCom, unsigned long ulTimeout)">SysComSetTimeout</functionname>
<description>Set the timeout of the specified serial interface (hardware timeout).
The Timeout is the time between two received or sent characters until the read or write operation
will return. Typically this value should be 0 (returns immediately)</description>
<param name="hCom" type="IN">Handle to com port</param>
<param name="ulTimeout" type="IN">Timeout to set</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hCom)">SysComClose</functionname>
<description>Close a serial communication device</description>
<param name="hCom" type="IN">Handle to com port</param>
<result>error code</result>
</element>
</element>
</component>
<component>
<name>SysCpuHandling</name>
<description>
System component that allows access to Cpu specific features.
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element interface="1" name="SysCpuHandlingItf">
<interfacename>SysCpuHandling</interfacename>
<description>
<p>The SysCpuHandling interface contains all cpu specific routines.</p>
<p>To detect, for which platform the component is compiled, there are special defines that must be set
in sysdefines.h dependant of the compiler specific options (see category "Processor ID" in SysTargetItf.h)</p>
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element typedefinition="1">
<name>syscpucalliecfuncwithparams_struct</name>
<structname>syscpucalliecfuncwithparams_struct</structname>
<SIL2/>
<description>
Call an IEC function from plain C code.
Since different CPU's/systems use different calling conventions, this function
should be used as a wrapper.
<p>IEC functions or methods of function block use all the same calling convention:
They have no return value and exactly one parameter, which is a pointer to a struct that contains all required
IN and OUT parameters.</p>
</description>
<result><p>RESULT: Returns the runtime system error code (see CmpErrors.library).</p></result>
<rawdata>
typedef struct tagsyscpucalliecfuncwithparams_struct
{
	RTS_VOID_FCTPTR pfIECFunc;			VAR_INPUT
	RTS_IEC_BYTE *pParam;				VAR_INPUT
	RTS_IEC_UDINT ulSize;				VAR_INPUT
	RTS_IEC_UDINT SysCpuCallIecFuncWithParams;	VAR_OUTPUT
} syscpucalliecfuncwithparams_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>syscputestandset_struct</name>
<structname>syscputestandset_struct</structname>
<description>
Test and set a bit in an ULONG variable in one processor step. This operation is to provide
a multitasking save operation.
</description>
<result><p>RESULT: Returns the runtime system error code (see CmpErrors.library).
ERR_OK: If bit could be set and was set before,
ERR_FAILED: If bit is still set
</p></result>
<rawdata>
typedef struct tagsyscputestandset_struct
{
	RTS_IEC_UDINT *pulValue;			VAR_INPUT
	RTS_IEC_UDINT ulBit;				VAR_INPUT
	RTS_IEC_UDINT SysCpuTestAndSet;		VAR_OUTPUT
} syscputestandset_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>syscputestandreset_struct</name>
<structname>syscputestandreset_struct</structname>
<description>
Test and reset a bit in an ULONG variable in one processor step. This operation is to provide
a multitasking save operation.
</description>
<result><p>RESULT: Returns the runtime system error code (see CmpErrors.library).
ERR_OK: If bit could be reset and was set before,
ERR_FAILED: If bit is still reset
</p></result>
<rawdata>
typedef struct tagsyscputestandreset_struct
{
	RTS_IEC_UDINT *pulValue;			VAR_INPUT
	RTS_IEC_UDINT ulBit;				VAR_INPUT
	RTS_IEC_UDINT SysCpuTestAndReset;	VAR_OUTPUT
} syscputestandreset_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>syscputestandsetbit_struct</name>
<structname>syscputestandsetbit_struct</structname>
<SIL2/>
<description>
<p>The function test and set or clear a bit in a variable in one processor step. This operation must be atomic to provide a multitasking save operation.</p>
<p>IMPLEMENTATION NOTE: Try to use a processor opcode, that provides this operation. If such an opcode
is not available, use SysCpuTestAndSetBitBase in your platform adaptation.</p>
</description>
<result><p>RESULT: Returns the runtime system error code (see CmpErrors.library).</p>
<ul>
<li>ERR_OK: bSet=1: If bit could be set and was not set before
bSet=0: If bit could be cleared and was set before</li>
<li>ERR_FAILED: bSet=1: If bit is still set
bSet=0: If bit is still cleared</li>
<li>ERR_PARAMETER: If pAddress=NULL or pAddress is unaligned or iBit is out nSize range</li>
<li>ERR_NOT_SUPPORTED: If function is not available because of missing components (e.g. SysInt for locking bit access)</li>
<li>ERR_NOTIMPLEMENTED: If function is not implemented on this platform</li>
</ul>
</result>
<rawdata>
typedef struct tagsyscputestandsetbit_struct
{
	RTS_IEC_BYTE *pAddress;				VAR_INPUT
	RTS_IEC_UDINT nLen;					VAR_INPUT
	RTS_IEC_DINT iBit;					VAR_INPUT
	RTS_IEC_DINT bSet;					VAR_INPUT
	RTS_IEC_UDINT SysCpuTestAndSetBit;	VAR_OUTPUT
} syscputestandsetbit_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>syscpuatomicadd_struct</name>
<structname>syscpuatomicadd_struct</structname>
<SIL2/>
<description>
Function to increment the content of the given pointer by 1 in one atomic operation (task safe).
IMPLEMENTATION NOTE:
- Add/Sub the value to the content of the pointer
- Return the value after the Add/Sub operation
Both things must be done atomic!
</description>
<result><p>RESULT: Returns the value after the increment operation in an atomic way!
</p></result>
<rawdata>
typedef struct tagsyscpuatomicadd_struct
{
	RTS_IEC_DINT *piValue;				VAR_INPUT
	RTS_IEC_DINT nSum;					VAR_INPUT
	RTS_IEC_UDINT *pResult;				VAR_INPUT
	RTS_IEC_DINT SysCpuAtomicAdd;		VAR_OUTPUT
} syscpuatomicadd_struct;
</rawdata>
</element>
<element function="1">
<functionname returntype="void" parameters="(void)">syscpudebughandler</functionname>
<description>
<p>Routine is the entry of the IEC code debugger. Is called out of the IEC task if breakpoint is reached.</p>
<p>IMPLEMENTATION NOTE: In this routine, the AppDebugHandler() function of CmpApp must be called with
the appropriate parameters. See CmpAppItf.h for detailed information. The return value of
AppDebugHandler() must be used to set the return address in the IEC code. To this address we will return
when leaving syscpudebughandler().</p>
<p>SIL2 IMPLEMENTATION NOTE: This routine may never be reached within safety mode. If it is called in safety mode
an Exception must be generated immediately! The Execution may not proceed to further debug mechanism!</p>
</description>
<parampseudo name="OperationMode" type="IN" range="[RTS_SIL2_OPMODE_SAFE,RTS_SIL2_OPMODE_DEBUG]">Specifies only that the function should be called</parampseudo>
<parampseudo name="bExceptionOccured" type="OUT" range="[TRUE,FALSE]">Specifies, if an exception should occure, or not</parampseudo>
<result>no return value</result>
</element>
<element function="1">
<functionname returntype="int" parameters="(void * pBaseAddress, unsigned long ulSize)">SysCpuFlushInstructionCache</functionname>
<description>
On some processors/operating systems this function must be called after code
has been changed, so that the CPU is notified about the change.
</description>
<param name="pBaseAddress" type="IN">Start address of the region to be flushed. Set to NULL to flush the
complete instruction cache.</param>
<param name="ulSize" type="IN">Length of the region to be flushed. This parameter is ignored if
pBaseAddress is NULL.</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_VOID_FCTPTR pfIECFunc, void* pParam, int iSize)">SysCpuCallIecFuncWithParams</functionname>
<description>
<p>Call an IEC function from plain C code.
Since different CPU's/systems use different calling conventions, this function
should be used as a wrapper.</p>
<p>IEC functions or methods of function block use all the same calling convention:
They have no return value and exactly one parameter, which is a pointer to a struct that contains all required
IN and OUT parameters.</p>

<p>IMPLEMENTATION NOTE: The content of the parameter structure must be copied completely on the stack as
an input parameter! Don't copy only the pointer! Because of this, the size of the structure is provided as a
separate parameter to this function. Additionally, the structure of the IEC function must be copied back into the
give parameter to return result values of the IEC function! For all this operations you have to ensure the stack
alignment, but avoid copying more bytes than iSize</p>

<p>IMPLEMENTATION NOTE:
Unused parameter pParam can be NULL, if function has no argument and no result (e.g. CodeInit)!
</p>
</description>
<param name="pfIECFunc" type="IN" range="[NULL,VALID_IEC_FUNC,INVALID_IEC_FUNC]">Pointer to the IEC function that should be called</param>
<param name="pParam" type="INOUT" range="[NULL,VALID_PARAMETER]">Pointer to the parameter struct that contains the function parameters. ATTENTION: Can be NULL!</param>
<param name="iSize" type="IN" range="[0,VALID_SIZE]">Size of the parameter structure to copy the content on stack. ATTENTION: Can be 0!</param>
<errorcode name="RTS_RESULT Result" type="ERR_OK">Parameter check was successfull and pfIECFunc was called</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_PARAMETER">pfIECFunc is NULL or for a paramter size > 0 pParam is NULL</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_NOTIMPLEMENTED">Function is not implemented</errorcode>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(unsigned char* pbyAreaStart, unsigned char* pbyBPAddress, unsigned char* pbyOpCode, int *piOpcodeSize)">SysCpuGetBreakpointCode</functionname>
<description>
Routine retrieves the breakpoint opcode for IEC code debugging.
This is cpu dependant and depends additionally on the
CoDeSys codegenerator.
</description>
<param name="pbyAreaStart" type="IN">Pointer to start of the area.</param>
<param name="pbyBPAddress" type="IN">Pointer to breakpoint address (where the breakpoint will be set).
This parameter is used for breakpoints that uses absolut jumps.</param>
<param name="pbyOpCode" type="OUT">Pointer to get opcode</param>
<param name="piOpcodeSize" type="INOUT">Pointer to maximum size of opcode buffer and return the real size
of the opcode</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_UINTPTR *pBP, void **ppAddress)">SysCpuGetCallstackEntry</functionname>
<description>
<p>Routine retrieves an IEC callstack entry, if the IEC code execution is stopped in the
IEC code (breakpoint, exception, etc.). The callstack can be investigated out of the stack frames of each
entered nested function. The first callstack entry is calculated outside this routine from the
instruction pointer address (IP) that is provided for the AppDebugHandler() routine from syscpudebughandler().
All further entries are called from this routine.</p>
<p>IMPLEMENTATION NOTE: The stack frame has typically the following structure:</p>
<pre>
.         STACK                        CODE
.         -----                        ----
.
.         BP0 /--------|               Fct0:
.                      |                    ...
.         Return Fct0  |                    Call Fct1
.    |--\ BP1 ---------|                    Return Fct0
.    |
.    |    Return Fct1                  Fct1:
.    |--- BP2 /--------|                    ...
.         ...          |                    Call Fct2
.         Stop         |                    Return Fct1
.                      |-- pulBP
.                                      Fct2:
.                                        ...
.                           IP --------/    Stop
</pre>
<p>In this example, Fct0 calls Fct1 and Fct1 calls Fct2. This is a nested call with 3 Functions.
Inside Fct2 we do a halt (e.g. stop on breakpoint). If we take a look on the stack, we see the return
addresses from Fct0 and Fct1 on the stack. At the entry of each function, the base- (or frame-) pointer
is pushed on the stack with the previous content. So you can see, the BP entries on the stack
are organized as a chained list from stackframe to stack frame.</p>
<p>The first stack entry is the current position. This is calculated out of the IP address and cannot be
investigated from stack.</p>
<p>The pulBP Parameter is a pointer, thats content is the address of the stack, where the BP entry resides.</p>
</description>
<param name="pBP" type="INOUT">Pointer to last base pointer entry (or frame pointer) and returns
the pointer to the next base pointer in the stack frame</param>
<param name="ppAddress" type="OUT">Pointer pointer to return address in the code of the caller</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(int bIecCode, RTS_UINTPTR *pBP, void **ppAddress)">SysCpuGetCallstackEntry2</functionname>
<description>Routine retrieves a callstack entry. The additional parameter bIecCode specifies, if the callstack
should be retrieved in IEC-code (bIecCode = 1) or in C-code of the runtime system (bIecCode = 0).
IMPLEMENTATION NOTE:
The callstack in C-code is sometimes compiler dependant and must be implemented here specific to the compiler.
</description>
<param name="bIecCode" type="IN"></param>
<param name="pBP" type="INOUT">Pointer to last base pointer entry (or frame pointer) and returns
the pointer to the next base pointer in the stack frame</param>
<param name="ppAddress" type="OUT">Pointer pointer to return address in the code of the caller</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_UINTPTR *pBP, void** ppInstancePointer)">SysCpuGetInstancePointer</functionname>
<description>Routine to retrieve the instance pointer of an FB. Is used to get an instance specific callstack.
The position of the instance pointer depends on the CoDeSys codegenerator and is cpu dependant.</description>
<param name="pBP" type="INOUT">Pointer to last base pointer entry (or frame pointer) and returns
the pointer to the next base pointer in the stack frame</param>
<param name="ppInstancePointer" type="OUT">Pointer pointer to the instance pointer of an FB</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_UINTPTR *pBP)">SysCpuGetMonitoringBase</functionname>
<description>Routine to retrieve the frame pointer for monitoring data access.</description>
<param name="pBP" type="INOUT">Pointer to last base pointer entry (or frame pointer) and returns
the pointer on the stack for monitoring data access</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_UI32* pul, int iBit)">SysCpuTestAndSet</functionname>
<description>Obsolete: Use SysCpuTestAndSetBit instead!
<p>OBSOLETE function to test and set a bit in an ULONG variable in one processor step. This operation must be atomic to provide
a multitasking save operation.</p>
<p>IMPLEMENTATION NOTE: Try to use a processor opcode, that provides this operation. If such an opcode
is not available, use SysCpuTestAndSetBase in your platform adaptation.</p>
</description>
<param name="pul" type="IN">Pointer to the unsigned value to test an set a bit inside in one atomic
processor step</param>
<parampseudo name="iBitOut" type="OUT">Bit that was really set</parampseudo>
<result>Error code:
<ul>
<li>ERR_OK: If bit could be set and was not set before</li>
<li>ERR_FAILED: If bit is still set</li>
</ul>
</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_UI32* pul, int iBit)">SysCpuTestAndReset</functionname>
<description>Obsolete: Use SysCpuTestAndSetBit instead!
<p>OBSOLETE function to reset a bit in an ULONG variable in one processor step. This operation must be atomic to provide
a multitasking save operation.</p>
<p>IMPLEMENTATION NOTE: Try to use a processor opcode, that provides this operation. If such an opcode
is not available, use SysCpuTestAndResetBase in your platform adaptation.</p>
</description>
<param name="pul" type="IN">Pointer to the unsigned value to test an reset a bit inside in one atomic
processor step</param>
<param name="iBit" type="IN">Bit number inside the variable to test and reset. 0=first bit, 31=last bit</param>
<result>
<ul>
<li>ERR_OK: If bit could be reset</li>
<li>ERR_FAILED: If bit reset failed</li>
</ul>
</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(void* pAddress, int nLen, int iBit, int bSet)">SysCpuTestAndSetBit</functionname>
<description>
<p>The function test and set or clear a bit in a variable in one processor step. This operation must be atomic to provide a multitasking save operation.</p>
<p>IMPLEMENTATION NOTE: Try to use a processor opcode, that provides this operation. If such an opcode
is not available, use SysCpuTestAndSetBitBase in your platform adaptation. The function returns ERR_FAILED if the bit was already set or reset.</p>
</description>
<param name="pAddress" type="IN" range="[NULL,ADDR_ALIGN0,ADDR_ALIGN1,ADDR_ALIGN2,ADDR_ALIGN3]">Pointer to test and set or clear a bit inside in one atomic processor step.
NOTE: The pointer must be natural aligned! nLen=2: pAddress must be 2Byte aligned; nLen=4: pAddress must be 4Byte aligned</param>
<param name="nLen" type="IN" range="[1,2,4,INVALID_LEN]">Size of the value behind the address. Can only be 1 (unsigned char), 2 (unsigned short) or 4 (unsigned long)</param>
<param name="iBit" type="IN" range="[INT_MIN..0,0..7,8..15,16..31,32..INT_MAX]">Bit number inside the variable to test and set or clear:
<ul>
<li>nLen = 1: iBit 0..7</li>
<li>nLen = 2: iBit 0..15</li>
<li>nLen = 4: iBit 0..31</li>
</ul>
</param>
<param name="bSet" type="IN" range="[0,1]">1=Set bit, 0=Clear bit</param>
<param name="iBit" type="IN">Bit number inside the variable to test and set. 0=first bit, 31=last bit</param>
<errorcode name="RTS_RESULT pResult" type="ERR_OK">Bit could be set/reset successfully</errorcode>
<errorcode name="RTS_RESULT pResult" type="ERR_FAILED">Bit could not be set/reset successfully, perhaps it already was set/reset</errorcode>
<errorcode name="RTS_RESULT pResult" type="ERR_PARAMETER">pAddress may not be null or misaligned, nLen may only be 1,2,4, iBit must be in correct range</errorcode>
<result>Error code: returns if Bit could be set/reset successfully, or if any  problem occured</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RegContext *pContext)">SysCpuGetContext</functionname>
<description>
Get the actual register context.
</description>
<param name="pContext" type="OUT">Actual register context</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_I32" parameters="(RTS_I32 *piValue, RTS_I32 nSum, RTS_RESULT *pResult)">SysCpuAtomicAdd</functionname>
<description>
<p>Function to increment the content of the given pointer by nSum in one atomic operation (task safe).</p>
<p>IMPLEMENTATION NOTE: Add or substract the value to/from the content of the pointer,
and return the value after this operation atomically.</p>
</description>
<param name="piValue" type="INOUT" range="[NULL,VALID_ATOMICADD_ADDR]">Pointer to the value to increment</param>
<param name="nSum" type="IN" range="[RTS_RANGE_OF_RTS_I32]">Summand for the operation. greater 0 to increment, lower 0 to decrement</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Returns the value after the increment operation in an atomic way!</result>
<errorcode name="RTS_RESULT pResult" type="ERR_OK">Call was sucessfull</errorcode>
<errorcode name="RTS_RESULT pResult" type="ERR_PARAMETER">piValue was NULL</errorcode>
<errorcode name="RTS_RESULT pResult" type="ERR_NOTIMPLEMENTED">Function is not supported</errorcode>
</element>
</element>
</component>
<component>
<name>SysExcept</name>
<description>
Component for first level exception handling
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<p><h1>Compiler Switch</h1></p>
<ul>
<li>
<csdef>#define RTS_STRUCTURED_EXCEPTION_HANDLING</csdef>
<csdesc>Switch to enabled structired exception handling. See rts_try/rts_catch for details.</csdesc>
<p></p>
</li>
</ul>
<element interface="1" name="SysExceptItf">
<interfacename>SysExcept</interfacename>
<description>
<p>The SysExcept interface is projected to handle all exceptions in the runtime system. All
available exceptions on the target should be handled. Exception handling is typically cpu
and operating system dependant.</p>
<p>All active code parts in the runtime system (tasks, timer, interrupt handler) must be protected
against software errors, because this could lead to an unpredictable behaviour or crash of the
complete runtime system.</p>
<p>All exceptions are handled in this component as first level.
If the first level handling is done in another component, the component has to call the
SysExceptGenerateException() routine to	enable second level handling. In this case, the first
level handling must be disabled with a config setting (see below).</p>
<p>The SysExcept component forwards every exception to the component, that manages the active
code, mostly the SysTask, SysTimer or SysInt component. These components must register exception
handlers to the SysExcept component.</p>
<p>As the last station of exception handling, the exception handler of the component, that creates
the active object, was called from the SysTask, SysTimer or SysInt component. Below you can see
the structure and the layers of exception handling:</p>

<pre>
. +----------------------------------------------------------+
. | XXX component:                       Code that generates |
. | Registered exceptionhandler          exception (1)       |
. | of component, is called. (4)                             |
. +----------------------------------------------------------+
.      ^                                                 |
.      |                                                 |
.      |                                                 |
. +-----------------------------------------------+      |
. | SysTask or SysTimer component:                |      |
. | Registered exception handler is called (3)    |      |
. +-----------------------------------------------+      |
.      ^                                                 |
.      |                                                 |
.      |                                                 |
. +-----------------------------------------------+      |
. | SysExcept component:                          |      |
. | ::SysExceptGenerateException() is called (2)  |      |
. +-----------------------------------------------+      |
.      ^                                                 |
.      |                                                 |
.      |                    Exception occurred (1a)      |
.      |&lt;------------------------------------------------|
.      |                                                 |
. +-----------------------------------------------+      |
. | OEM component:                                |      | (1b)
. | First level exception handling. If the        |      |
. | exception is not in the OEM context, it is    |      |
. | forwarded to the SysExcept component          |      |
. +-----------------------------------------------+      |
.      ^                                                 |
.      '-------------------------------------------------'
</pre>
<p>If RTS_STRUCTURED_EXCEPTION_HANDLING is set as a define, the structured exception handling is activated.
To use this exception handling, the following functions must be imported:</p>
<ul>
<li>SysExceptRegisterJmpBuf</li>
<li>SysExceptCatch</li>
<li>SysExceptUnregisterJmpBuf</li>
</ul>

<p>Here is an example of the usage:</p>
<pre>
.    Variant 1:
.     ----------
.    rts_try
.    {
.        ...
.    }
.    rts_catch_first(RTSEXCPT_DIVIDEBYZERO)
.    {
.        RTS_UI32 exceptionCode = EXCPT_GET_CODE();
.        RegContext *pExceptionContext = EXCPT_GET_CONTEXT();
.        ...
.    }
.    rts_catch_next(RTSEXCPT_DIVIDEBYZERO)
.    {
.        ...
.    }
.    rts_catch_remaining
.    {
.        ...
.    }
.    rts_finally
.    {
.        ...
.    }
.    rts_try_end
.
.
.    Variant 2:
.     ----------
.
.    rts_try
.    {
.        ...
.    }
.    rts_catch
.    {
.        RTS_UI32 exceptionCode = EXCPT_GET_CODE();
.        RegContext *pExceptionContext = EXCPT_GET_CONTEXT();
.        ...
.    }
.    rts_finally
.    {
.        ...
.    }
.    rts_try_end
</pre>
</description>

<copyright>(c) 2003-2012 3S-Smart Software Solutions</copyright>
<element define="1">
<name>EXCPT_DEFAULT_NUM_OF_INTERFACES</name>
<key>5</key>
<condition>EXCPT_DEFAULT_NUM_OF_INTERFACES</condition>
<category>Static defines</category>
<description>Default number of static interfaces that can be registered on exceptions</description>
</element>
<element define="1">
<name>EXCPT_MAX_NUM_OF_SEH_HANDLER</name>
<key>5</key>
<condition>EXCPT_MAX_NUM_OF_SEH_HANDLER</condition>
<category>Static defines</category>
<description>Maximum number of nested structured exception handler on the same task</description>
</element>
<element define="1">
<name>EXCPT_NUM_OF_STATIC_CONTEXT</name>
<key>10</key>
<condition>EXCPT_NUM_OF_STATIC_CONTEXT</condition>
<category>Static defines</category>
<description>Maximum number of static contexts to store for structured exception handling</description>
</element>
<element define="1">
<name>RTSEXCPT_UNKNOWN</name>
<key>UINT32_MAX</key>
<category>Exception code</category>
<description>Invalid</description>
</element>
<element define="1">
<name>RTSEXCPT_NOEXCEPTION</name>
<key>0x00000000</key>
<category>Exception code</category>
<description>No exception</description>
</element>
<element define="1">
<name>RTSEXCPT_WATCHDOG</name>
<key>0x00000010</key>
<category>Exception code</category>
<description>Software watchdog of IEC-task expired</description>
</element>
<element define="1">
<name>RTSEXCPT_HARDWAREWATCHDOG</name>
<key>0x00000011</key>
<category>Exception code</category>
<description>Hardware watchdog expired. Global software error</description>
</element>
<element define="1">
<name>RTSEXCPT_IO_CONFIG_ERROR</name>
<key>0x00000012</key>
<category>Exception code</category>
<description>IO config error</description>
</element>
<element define="1">
<name>RTSEXCPT_PROGRAMCHECKSUM</name>
<key>0x00000013</key>
<category>Exception code</category>
<description>Checksum error after program download</description>
</element>
<element define="1">
<name>RTSEXCPT_FIELDBUS_ERROR</name>
<key>0x00000014</key>
<category>Exception code</category>
<description>Fieldbus error</description>
</element>
<element define="1">
<name>RTSEXCPT_IOUPDATE_ERROR</name>
<key>0x00000015</key>
<category>Exception code</category>
<description>IO-update error</description>
</element>
<element define="1">
<name>RTSEXCPT_CYCLE_TIME_EXCEED</name>
<key>0x00000016</key>
<category>Exception code</category>
<description>Cycle time exceed</description>
</element>
<element define="1">
<name>RTSEXCPT_ONLCHANGE_PROGRAM_EXCEEDED</name>
<key>0x00000017</key>
<category>Exception code</category>
<description>Online change program too large</description>
</element>
<element define="1">
<name>RTSEXCPT_UNRESOLVED_EXTREFS</name>
<key>0x00000018</key>
<category>Exception code</category>
<description>Unresolved external references</description>
</element>
<element define="1">
<name>RTSEXCPT_DOWNLOAD_REJECTED</name>
<key>0x00000019</key>
<category>Exception code</category>
<description>Download was rejected</description>
</element>
<element define="1">
<name>RTSEXCPT_BOOTPROJECT_REJECTED_DUE_RETAIN_ERROR</name>
<key>0x0000001A</key>
<category>Exception code</category>
<description>Boot project not loaded because retain variables could not be relocated</description>
</element>
<element define="1">
<name>RTSEXCPT_LOADBOOTPROJECT_FAILED</name>
<key>0x0000001B</key>
<category>Exception code</category>
<description>Boot project not loaded and deleted</description>
</element>
<element define="1">
<name>RTSEXCPT_OUT_OF_MEMORY</name>
<key>0x0000001C</key>
<category>Exception code</category>
<description>Out of heap memory</description>
</element>
<element define="1">
<name>RTSEXCPT_RETAIN_MEMORY_ERROR</name>
<key>0x0000001D</key>
<category>Exception code</category>
<description>Retain memory corrupt or cannot be mapped</description>
</element>
<element define="1">
<name>RTSEXCPT_BOOTPROJECT_CRASH</name>
<key>0x0000001E</key>
<category>Exception code</category>
<description>Boot project that could be loaded but caused a crash later</description>
</element>
<element define="1">
<name>RTSEXCPT_BOOTPROJECTTARGETMISMATCH</name>
<key>0x00000021</key>
<category>Exception code</category>
<description>Target of the bootproject doesn't match the current target</description>
</element>
<element define="1">
<name>RTSEXCPT_SCHEDULEERROR</name>
<key>0x00000022</key>
<category>Exception code</category>
<description>Error at scheduling tasks</description>
</element>
<element define="1">
<name>RTSEXCPT_FILE_CHECKSUM_ERR</name>
<key>0x00000023</key>
<category>Exception code</category>
<description>Checksum of downloaded file does not match</description>
</element>
<element define="1">
<name>RTSEXCPT_RETAIN_IDENTITY_MISMATCH</name>
<key>0x00000024</key>
<category>Exception code</category>
<description>Retain identity does not match to current bootproject program identity</description>
</element>
<element define="1">
<name>RTSEXCPT_IEC_TASK_CONFIG_ERROR</name>
<key>0x00000025</key>
<category>Exception code</category>
<description>Iec task configuration failed</description>
</element>
<element define="1">
<name>RTSEXCPT_APP_TARGET_MISMATCH</name>
<key>0x00000026</key>
<category>Exception code</category>
<description>Application is running on wrong target. Can be used for library protection!</description>
</element>
<element define="1">
<name>RTSEXCPT_ILLEGAL_INSTRUCTION</name>
<key>0x00000050</key>
<category>Exception code, hardware exceptions</category>
<description>Illegal instruction</description>
</element>
<element define="1">
<name>RTSEXCPT_ACCESS_VIOLATION</name>
<key>0x00000051</key>
<category>Exception code, hardware exceptions</category>
<description>Access violation</description>
</element>
<element define="1">
<name>RTSEXCPT_PRIV_INSTRUCTION</name>
<key>0x00000052</key>
<category>Exception code, hardware exceptions</category>
<description>Privileged instruction</description>
</element>
<element define="1">
<name>RTSEXCPT_IN_PAGE_ERROR</name>
<key>0x00000053</key>
<category>Exception code, hardware exceptions</category>
<description>Page fault</description>
</element>
<element define="1">
<name>RTSEXCPT_STACK_OVERFLOW</name>
<key>0x00000054</key>
<category>Exception code, hardware exceptions</category>
<description>Stack overflow</description>
</element>
<element define="1">
<name>RTSEXCPT_INVALID_DISPOSITION</name>
<key>0x00000055</key>
<category>Exception code, hardware exceptions</category>
<description>Invalid disposition</description>
</element>
<element define="1">
<name>RTSEXCPT_INVALID_HANDLE</name>
<key>0x00000056</key>
<category>Exception code, hardware exceptions</category>
<description>Invalid handle</description>
</element>
<element define="1">
<name>RTSEXCPT_GUARD_PAGE</name>
<key>0x00000057</key>
<category>Exception code, hardware exceptions</category>
<description>Guard page</description>
</element>
<element define="1">
<name>RTSEXCPT_DOUBLE_FAULT</name>
<key>0x00000058</key>
<category>Exception code, hardware exceptions</category>
<description>Double fault</description>
</element>
<element define="1">
<name>RTSEXCPT_INVALID_OPCODE</name>
<key>0x00000059</key>
<category>Exception code, hardware exceptions</category>
<description>Invalid OpCode</description>
</element>
<element define="1">
<name>RTSEXCPT_MISALIGNMENT</name>
<key>0x00000100</key>
<category>Exception code, hardware exceptions</category>
<description>Datatype misalignment</description>
</element>
<element define="1">
<name>RTSEXCPT_ARRAYBOUNDS</name>
<key>0x00000101</key>
<category>Exception code, hardware exceptions</category>
<description>Array bounds exceeded</description>
</element>
<element define="1">
<name>RTSEXCPT_DIVIDEBYZERO</name>
<key>0x00000102</key>
<category>Exception code, hardware exceptions</category>
<description>Division by zero</description>
</element>
<element define="1">
<name>RTSEXCPT_OVERFLOW</name>
<key>0x00000103</key>
<category>Exception code, hardware exceptions</category>
<description>Overflow</description>
</element>
<element define="1">
<name>RTSEXCPT_NONCONTINUABLE</name>
<key>0x00000104</key>
<category>Exception code, hardware exceptions</category>
<description>Non continuable</description>
</element>
<element define="1">
<name>RTSEXCPT_PROCESSORLOAD_WATCHDOG</name>
<key>0x00000105</key>
<category>Exception code</category>
<description>Processor load watchdog of all IEC-tasks detected</description>
</element>
<element define="1">
<name>RTSEXCPT_FPU_ERROR</name>
<key>0x00000150</key>
<category>Exception code, hardware FPU exceptions</category>
<description>FPU: Unspecified error</description>
</element>
<element define="1">
<name>RTSEXCPT_FPU_DENORMAL_OPERAND</name>
<key>0x00000151</key>
<category>Exception code, hardware FPU exceptions</category>
<description>FPU: Denormal operand</description>
</element>
<element define="1">
<name>RTSEXCPT_FPU_DIVIDEBYZERO</name>
<key>0x00000152</key>
<category>Exception code, hardware FPU exceptions</category>
<description>FPU: Division by zero</description>
</element>
<element define="1">
<name>RTSEXCPT_FPU_INEXACT_RESULT</name>
<key>0x00000153</key>
<category>Exception code, hardware FPU exceptions</category>
<description>FPU: Inexact result</description>
</element>
<element define="1">
<name>RTSEXCPT_FPU_INVALID_OPERATION</name>
<key>0x00000154</key>
<category>Exception code, hardware FPU exceptions</category>
<description>FPU: Invalid operation</description>
</element>
<element define="1">
<name>RTSEXCPT_FPU_OVERFLOW</name>
<key>0x00000155</key>
<category>Exception code, hardware FPU exceptions</category>
<description>FPU: Overflow</description>
</element>
<element define="1">
<name>RTSEXCPT_FPU_STACK_CHECK</name>
<key>0x00000156</key>
<category>Exception code, hardware FPU exceptions</category>
<description>FPU: Stack check</description>
</element>
<element define="1">
<name>RTSEXCPT_FPU_UNDERFLOW</name>
<key>0x00000157</key>
<category>Exception code, hardware FPU exceptions</category>
<description>FPU: Underflow</description>
</element>
<element define="1">
<name>RTSEXCPT_VENDOR_EXCEPTION_BASE</name>
<key>0x00002000</key>
<category>Exception code, vendor specific</category>
<description>Base number for vendor specific exception codes. VendorID must be specified as prefix
inside the exception code:
RTS_UI32 ulException = ADDVENDORID([VendorId], RTSEXCPT_VENDOR_EXCEPTION_BASE + [Exception]);
</description>
</element>
<element define="1">
<name>EVT_EXCPT_GenerateException</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>The event is sent if an exception occurred (see category exception code for
detailed information).
NOTE:
This event is fired for every exception! That means also for handled exceptions via SEH (Structured Exception Handling)
with rts_try/rts_catch!
</description>
<param name="pEventParam" type="IN">EVTPARAM_SysExcept</param>
</element>
<element define="1">
<name>EVT_EXCPT_GenerateException2</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>The event is sent if an exception occurred (see category exception code for
detailed information).
NOTE:
This event is fired only for exceptions that are not handled via SEH (Structured Exception Handling)
with rts_try/rts_catch!
</description>
<param name="pEventParam" type="IN">EVTPARAM_SysExcept</param>
</element>
<element define="1">
<name>EXCPT_GET_CODE</name>
<key></key>
* <description>Structured exception handling:
* rts_try:			macro to enter a exception handling section
* rts_catch_first: macro to handle the first exception code
* rts_catch_next:  macro to handle the following exception codes after rts_catch_first
* rts_catch_remaining:  macro to handle all remaining exception codes after rts_catch_first/rts_catch_next
* rts_catch:		macro to handle all exception codes without previous usage of rts_catch_first/rts_catch_next/rts_catch_remaining
* rts_finally:		macro is called always after an exception or not to cleanup some stuff, that was occupied in the rts_try section
* </description>
</element>
<element typedefinition="1">
<name>ExceptionCode</name>
<structname>ExceptionCode</structname>
<category>Exception code</category>
<description></description>
<element name="ulCode" type="IN">Exception code. Can be an operating system specific exception code
or a runtime specific exception code (see exception code category)</element>
<element name="bOSException" type="IN">Exception code flag:
<p>1=exception code is an operating system specific exception code</p>
<p>0=exception code is a runtime code. See exception code category</p></element>
<rawdata>
typedef struct tagExceptionCode
{
	RTS_UI32 ulCode;
	int bOSException;
} ExceptionCode;
</rawdata>
</element>
<element typedefinition="1">
<name>RegContext</name>
<structname>RegContext</structname>
<SIL2/>
<category>Exception context</category>
<description></description>
<element name="IP" type="IN">Instruction pointer or program counter</element>
<element name="BP" type="IN">Base pointer or frame pointer</element>
<element name="SP" type="IN">Stack pointer</element>
<rawdata>
typedef struct RegContexttag
{
	RTS_UINTPTR IP;
	RTS_UINTPTR BP;
	RTS_UINTPTR SP;
} RegContext;
</rawdata>
</element>
<element typedefinition="1">
<name>EVTPARAM_SysExcept</name>
<structname>EVTPARAM_SysExcept</structname>
<category>Event parameter</category>
<description></description>
<element name="uiTaskOSHandle" type="IN">Operating system specific task handle</element>
<element name="ulException" type="IN">Exception number. See category "Exception code"</element>
<element name="Context" type="IN">Register context, where the exception occurred</element>
<rawdata>
typedef struct
{
	RTS_HANDLE uiTaskOSHandle;
	RTS_IEC_DWORD ulException;
	RegContext Context;
	RTS_RESULT Result;
} EVTPARAM_SysExcept;
</rawdata>
</element>
<element typedefinition="1">
<name>sysexceptenableseh2_struct</name>
<structname>sysexceptenableseh2_struct</structname>
<description>sysexceptenableseh2</description>
<rawdata>
typedef struct tagsysexceptenableseh2_struct
{
	RTS_IEC_VOID_FCTPTR pfExceptionHandler;	VAR_INPUT
	RTS_IEC_UDINT SysExceptEnableSEH2;	VAR_OUTPUT
} sysexceptenableseh2_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>sysexceptdisableseh2_struct</name>
<structname>sysexceptdisableseh2_struct</structname>
<description>sysexceptdisableseh2</description>
<rawdata>
typedef struct tagsysexceptdisableseh2_struct
{
	RTS_IEC_VOID_FCTPTR pfExceptionHandler;	VAR_INPUT
	RTS_IEC_UDINT SysExceptDisableSEH2;	VAR_OUTPUT
} sysexceptdisableseh2_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>sysexceptenableseh_struct</name>
<structname>sysexceptenableseh_struct</structname>
<description>sysexceptenableseh</description>
<rawdata>
typedef struct tagsysexceptenableseh_struct
{
	RTS_IEC_UDINT SysExceptEnableSEH;	VAR_OUTPUT
} sysexceptenableseh_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>sysexceptdisableseh_struct</name>
<structname>sysexceptdisableseh_struct</structname>
<description>sysexceptdisableseh</description>
<rawdata>
typedef struct tagsysexceptdisableseh_struct
{
	RTS_IEC_UDINT SysExceptDisableSEH;	VAR_OUTPUT
} sysexceptdisableseh_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>sysexceptgenerateexception_struct</name>
<structname>sysexceptgenerateexception_struct</structname>
<description>Interrupt the execution of the currently running
task, and set the application into an exception state. If the
runtime system supports it, CODESYS may even highlight the source
position where this function was called.</description>
<result><p>RESULT: If succeeded this function doesn't return at all, otherwise it returns ERR_FAILED.</p></result>
<rawdata>
typedef struct tagsysexceptgenerateexception_struct
{
	RTS_IEC_UDINT udiException;			VAR_INPUT
	RTS_IEC_RESULT SysExceptGenerateException;	VAR_OUTPUT
} sysexceptgenerateexception_struct;
</rawdata>
</element>
<element function="1">
<functionname returntype="RTS_UI32" parameters="(RTS_UI32 ulOSException)">SysExceptMapException</functionname>
<description>Map the operating system specific exception into the standard runtime exception code</description>
<param name="ulOSException" type="IN">Operating system specific exception code</param>
<result>Standard exception code (see category exception code above)</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE ulTaskOSHandle, ExceptionCode Exception, RegContext Context)">SysExceptGenerateException</functionname>
<description>
<p>Structured Exception Handling</p>
<p>This function is called from Exception handlers of the hardware,
operating systems or, in case of softerrors, within the task code.
</p>
<p>The structured exception handling calls every registered exception
handler, stops the IEC Tasks and prepares the task context of the
task that generated the exception, so that it can be read by the
CoDeSys programming system for analysation purposes.
</p>
<p>OEM customers can use this function also from their own exception
handlers to propagate generic as well as customer specific exceptions
to the application. This way, they can profit from the debugging
infrastructure of CoDeSys to find the fault adress within the IEC
application.</p>
<p><b>Note:</b> On SIL2 Platforms, this function will act only as
described above, when the PLC is currently in Debug-Mode. If it is
actually in the Safety-Mode, this call puts the PLC directly into
the safe mode, by calling the function SIL2OEMException().</p>
</description>
<param name="ulTaskOSHandle" type="IN" range="[RTS_INVALID_HANDLE,NULL,VALID_TASKHANDLE]">System specific task or timer handle or RTS_INVALID_HANDLE if unknown</param>
<param name="Exception" type="IN" range="[RTSEXCPT_UNKNOWN]">Exception code (OS or runtime specific)</param>
<param name="Context" type="IN" range="[NULL,VALID_CONTEXT]">Context to detect the code location where the exception was generated. If ulTaskOSHandle is RTS_INVALID_HANDLE, values can be 0.</param>
<parampseudo name="Mode" type="IN" range="[SAFETY,DEBUG]">Defines the current mode of the PLC.</parampseudo>
<parampseudo name="StructuredHandling" type="OUT">TRUE if structured Exception Handling was used.</parampseudo>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE ulTaskOSHandle, ExceptionCode Exception, RegContext Context, int bSuspendExceptionTask)">SysExceptGenerateException2</functionname>
<description>
<p>Structured Exception Handling</p>
<p>This function acts the same way as SysExceptGenerateException(),
except for the case, that it will try to suspend the task in the
following condition:
</p>
<ul>
<li>bSuspendExceptionTask is set to TRUE</li>
<li>None of the registered exception handlers returned ERR_DONT_SUSPEND_TASK</li>
</ul>
</description>
<param name="ulTaskOSHandle" type="IN" range="[RTS_INVALID_HANDLE,NULL,VALID_TASKHANDLE]">System specific task or timer handle or RTS_INVALID_HANDLE if unknown</param>
<param name="Exception" type="IN" range="[EXCEPTION_1]">Exception code (OS or runtime specific)</param>
<param name="Context" type="IN" range="[NULL,VALID_CONTEXT]">Context to detect the code location where the exception was generated. If ulTaskOSHandle is RTS_INVALID_HANDLE, values can be 0.</param>
<param name="bSuspendExceptionTask" type="IN" range="[0,1]">Flag to specify, if the exception task is forced to suspended</param>
<parampseudo name="bSafetyMode" type="IN" range="[0,1]">Defines the current mode of the PLC.</parampseudo>
<parampseudo name="bStructuredHandling" type="OUT">TRUE if structured Exception Handling was used.</parampseudo>
<errorcode name="RTS_RESULT" type="ERR_OK">None of the registered exception handlers returned ERR_DONT_SUSPEND_TASK</errorcode>
<errorcode name="RTS_RESULT" type="ERR_DONT_SUSPEND_TASK">An exception handler suspends the task itself</errorcode>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(PFEXCEPTIONHANDLER pExceptionHandler)">SysExceptRegisterInterface</functionname>
<description>Function to register an exception handler</description>
<param name="pExceptionHandler" type="IN">Pointer to exception handler</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(PFEXCEPTIONHANDLER pExceptionHandler)">SysExceptUnregisterInterface</functionname>
<description>Function to unregister exception handler</description>
<param name="pExceptionHandler" type="IN">Pointer to exception handler</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_UI32 ulExceptionCode, char*pszException, int iMaxExceptionLen)">SysExceptConvertToString</functionname>
<description>Convert an exception to string</description>
<param name="ulExceptionCode" type="IN">Exception code</param>
<param name="pszException" type="OUT">Pointer to exception string</param>
<param name="iMaxExceptionLen" type="IN">Maximum length of exception string pointer</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_JMP_BUF *pJmpBuf, int bEnable)">SysExceptRegisterJmpBuf</functionname>
<description>Functions for structured exception handling only. Must be imported, if SEH will be used!</description>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(void)">SysExceptEnableSEH</functionname>
<description>Enable the exception handling, if rts_try_disabled is used</description>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(void)">SysExceptDisableSEH</functionname>
<description>Disablethe exception handling, if rts_try_disabled is used</description>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(PFEXCEPTIONHANDLER pfExceptionHandler, int bIec)">SysExceptEnableSEH2</functionname>
<description>Enable the exception handling, if rts_try_disabled is used! Additionally the specified exception handler is called at the exception.</description>
<param name="pfExceptionHandler" type="IN">Function pointer to the exception handler</param>
<param name="bIec" type="IN">Specified, whether the function pointer is an IEC function (bIec=1) or a C function (bIec=0)</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(PFEXCEPTIONHANDLER pfExceptionHandler, int bIec)">SysExceptDisableSEH2</functionname>
<description>Disable the exception handling, if rts_try_disabled is used! The specified exception handler will be removed.</description>
<param name="pfExceptionHandler" type="IN">Function pointer to the exception handler</param>
<param name="bIec" type="IN">Specified, whether the function pointer is an IEC function (bIec=1) or a C function (bIec=0)</param>
<result>error code</result>
</element>
</element>
</component>
<component>
<name>SysFile</name>
<description>
System component that allows access to file functions.
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<p><h1>Compiler Switch</h1></p>
<ul>
<li>
<csdef>#define SYSFILE_DISABLE_FILE_CACHE</csdef>
<csdesc>For each transmitted file, the CRC and size is stored in a central config file (cache). This can be disabled by this compiler switch.</csdesc>
<p></p>
</li>
</ul>
<element interface="1" name="SysFileItf">
<interfacename>SysFile</interfacename>
<description>
<p>The SysFile interface is projected to get access to the files of a filesystem.
The filesystem can be on harddisk, a flash/flash disk, a RAM disk or what ever. The only
requirement is, that the filesystem is non volatile!</p>
<p>Please read following notes if using the SysFileFlash with our SysFlash:
This component needs a global
define of the file table FILE_MAP. It has to be declared in sysdefines.h. Here is an example
with the neccessay initializations:
#define FILE1_SIZE	0x4000
#define FILE2_SIZE	0x2000
#define FILE3_SIZE	0x2000
#define FILE4_SIZE	0x38000
#define FILE5_SIZE	0x40000
#define SYSFILEFLASH_MAX_SIZE			(FILE1_SIZE + FILE2_SIZE + FILE3_SIZE + FILE4_SIZE + FILE5_SIZE)
#define FILE_MAP	static FILE_DESC m_FileSystem[] = \
{ \
*	Name		Offset											MaxSize				read index	write index * \
{"file1.txt",	0x0,											FILE1_SIZE,			0xFFFFFFFF, 0xFFFFFFFF}, \
{"app.crc",		FILE1_SIZE,										FILE2_SIZE,			0xFFFFFFFF, 0xFFFFFFFF}, \
{"file2.txt",	FILE1_SIZE+FILE2_SIZE,							FILE3_SIZE,			0xFFFFFFFF, 0xFFFFFFFF}, \
{"file4.txt",	FILE1_SIZE+FILE2_SIZE+FILE3_SIZE,				FILE4_SIZE,			0xFFFFFFFF, 0xFFFFFFFF}, \
{"app.app",		FILE1_SIZE+FILE2_SIZE+FILE3_SIZE+FILE4_SIZE,	FILE5_SIZE,			0xFFFFFFFF, 0xFFFFFFFF}, \
};
Please note that the offsets of the files have to correspond with sector borders of the flash. One file should be
stored in one sector.</p>
</description>

<copyright>(c) 2003-2013 3S-Smart Software Solutions</copyright>
<element define="1">
<name>MAX_PATH_LEN</name>
<key>255</key>
<condition>MAX_PATH_LEN</condition>
<category>Static defines</category>
<description>Maximum length of a file path</description>
</element>
<element define="1">
<name>SYSFILE_TEMP_BUFFER_SIZE</name>
<key>256</key>
<condition>SYSFILE_TEMP_BUFFER_SIZE</condition>
<category>Static defines</category>
<description>Size for temporary buffer e.g. to calculate CRC. If size is larger than 256, buffer is allocated from heap!</description>
</element>
<element define="1">
<name>SYSFILE_INVISIBLE_FILENAME_PREFIX</name>
<key>.</key>
<condition>SYSFILE_INVISIBLE_FILENAME_PREFIX</condition>
<category>Static defines</category>
<description>File name prefix to make a file invisible e.g. for the filetransfer dialog. This prevents the corresponding file to be overwritten/read/compromized from outside.
</description>
</element>
<element define="1">
<name>SYSFILE_MAP_SECTION_NAME</name>
<key>SysFileMap</key>
<condition>SYSFILE_MAP_SECTION_NAME</condition>
<category>Static defines</category>
<description>This is the name for a section which contains the name, CRC and size of a file. Is used as a cache for these values.
Improves for example the performance of the file transfer. SYSFILE_DISABLE_FILE_CACHE disables this feature.
NOTE:
It is recommended to use a filereference in the configuration, to move these entries into a separate cfg-file. e.g.:
[CmpSettings]
FileReference.0=SysFileMap.cfg, SysFileMap
</description>
</element>
<element define="1">
<name>SYSFILE_VISU_FOLDER</name>
<key>visu/</key>
<condition>SYSFILE_VISU_FOLDER</condition>
<category>Static defines</category>
<description>Defines to specify the visu folder that is requested by every filetransfer/fileaccess on visu files. And we specify the placeholder for there files, for which
the destination folder can be specified with the setting "PlaceholderFilePath" (see details above).
</description>
</element>
<element define="1">
<name>RTS_ACCESS_MODE_AM_READ</name>
<key>0</key>
Access mode
File modes to open a file.
ATTENTION: For all _PLUS modes be aware, that after reading from a file, writing can only be done after a call
to SysFileGetPos() or SysFileSetPos()! If you call SysFileWrite right after SysFileRead, the file pointer
could be on an invalid position!
Correct example:
SysFileRead();
SysFileGetPos();
SysFileWrite();
</element>
<element define="1">
<name>SYS_FILE_STATUS_FS_OK</name>
<key>0</key>
File status
Actual file status of the specified file.
</element>
<element typedefinition="1">
<name>SYS_FILETIME</name>
<structname>SYS_FILETIME</structname>
File TIME in UTC
Timestamps of the specified file.
<rawdata>
typedef struct tagSYS_FILETIME
{
	RTS_IEC_UDINT tCreation;
	RTS_IEC_UDINT tLastAccess;
	RTS_IEC_UDINT tLastModification;
} SYS_FILETIME;
</rawdata>
</element>
<element typedefinition="1">
<name>sysfileclose_struct</name>
<structname>sysfileclose_struct</structname>
Close a file specified by handle
RETURN: Returns the runtime system error code (see CmpErrors.library)
<rawdata>
typedef struct tagsysfileclose_struct
{
	RTS_IEC_HANDLE hFile;				VAR_INPUT    Handle of the file
	RTS_IEC_RESULT SysFileClose;		VAR_OUTPUT    
} sysfileclose_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>sysfilecopy_struct</name>
<structname>sysfilecopy_struct</structname>
Copy one file to another.
A standard path will be added to the filename, if no path is specified.
RETURN: Returns the runtime system error code (see CmpErrors.library)
<rawdata>
typedef struct tagsysfilecopy_struct
{
	RTS_IEC_STRING *szDestFileName;		VAR_INPUT    Destination file name. File name can contain an absolute or relative path to the file.
	RTS_IEC_STRING *szSourceFileName;	VAR_INPUT    Source file name. File name can contain an absolute or relative path to the file.
	RTS_IEC_XWORD *pulCopied;			VAR_INPUT    Number of bytes copied
	RTS_IEC_RESULT SysFileCopy;			VAR_OUTPUT    
} sysfilecopy_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>sysfiledelete_struct</name>
<structname>sysfiledelete_struct</structname>
Delete the file specified by name.
A standard path will be added in the runtime system to the filename, if no path is specified.
RETURN: Returns the runtime system error code (see CmpErrors.library)
<rawdata>
typedef struct tagsysfiledelete_struct
{
	RTS_IEC_STRING *szFileName;			VAR_INPUT    File name. File name can contain an absolute or relative path to the file.
	RTS_IEC_RESULT SysFileDelete;		VAR_OUTPUT    
} sysfiledelete_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>sysfiledeletebyhandle_struct</name>
<structname>sysfiledeletebyhandle_struct</structname>
Delete the file specified by handle
RETURN: Returns the runtime system error code (see CmpErrors.library)
<rawdata>
typedef struct tagsysfiledeletebyhandle_struct
{
	RTS_IEC_HANDLE hFile;				VAR_INPUT    Handle of the file
	RTS_IEC_RESULT SysFileDeleteByHandle;	VAR_OUTPUT    
} sysfiledeletebyhandle_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>sysfileeof_struct</name>
<structname>sysfileeof_struct</structname>
Check, if end of file is reached
RETURN: Returns the runtime system error code (see CmpErrors.library)
<rawdata>
typedef struct tagsysfileeof_struct
{
	RTS_IEC_HANDLE hFile;				VAR_INPUT    Handle of the file
	RTS_IEC_RESULT SysFileEOF;			VAR_OUTPUT    
} sysfileeof_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>sysfileflush_struct</name>
<structname>sysfileflush_struct</structname>
Flush the file cache and write into the file
RETURN: Returns the runtime system error code (see CmpErrors_Itfs.library):
+ ERR_OK: Succeeded flushing the file
+ ERR_FAILED: Error occurred during file flush
+ ERR_NOTIMPLEMENTED: File flush is not implemented
+ ERR_NOT_SUPPORTED: File flush not available on the target
<rawdata>
typedef struct tagsysfileflush_struct
{
	RTS_IEC_HANDLE hFile;				VAR_INPUT    Handle of the file
	RTS_IEC_RESULT SysFileFlush;		VAR_OUTPUT    
} sysfileflush_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>sysfilegetname_struct</name>
<structname>sysfilegetname_struct</structname>
Get the file name from file specified by handle
RETURN: File name of the specified file
<rawdata>
typedef struct tagsysfilegetname_struct
{
	RTS_IEC_HANDLE hFile;				VAR_INPUT    Handle of the file
	RTS_IEC_STRING *SysFileGetName;		VAR_OUTPUT    
} sysfilegetname_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>sysfilegetname2_struct</name>
<structname>sysfilegetname2_struct</structname>
Get the file name from file specified by handle
RETURN: File name of the specified file
<rawdata>
typedef struct tagsysfilegetname2_struct
{
	RTS_IEC_HANDLE hFile;				VAR_INPUT    Handle of the file
	RTS_IEC_RESULT *pResult;			VAR_INPUT    Pointer to runtime system error code (see CmpErrors.library)
	RTS_IEC_STRING *SysFileGetName2;	VAR_OUTPUT    
} sysfilegetname2_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>sysfilegetpath_struct</name>
<structname>sysfilegetpath_struct</structname>
Get the path of this file.
If a path is specified in the filename, the path will be extracted from the filename.
If no path is specified in the filename, the standard path for this file extension type will be returned.
RETURN: Returns the runtime system error code (see CmpErrors.library)
<rawdata>
typedef struct tagsysfilegetpath_struct
{
	RTS_IEC_STRING *szFileName;			VAR_INPUT    File name. Can contain an absolute or relative path
	RTS_IEC_STRING *szPath;				VAR_INPUT    Path for this file
	RTS_IEC_DINT diMaxLen;				VAR_INPUT    Maximum size in bytes of path length
	RTS_IEC_RESULT SysFileGetPath;		VAR_OUTPUT    
} sysfilegetpath_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>sysfilegetpos_struct</name>
<structname>sysfilegetpos_struct</structname>
Get actual file pointer position
RESULT: Returns the runtime system error code (see CmpErrors.library)
<rawdata>
typedef struct tagsysfilegetpos_struct
{
	RTS_IEC_HANDLE hFile;				VAR_INPUT    Handle of the file
	RTS_IEC_XWORD *pulPos;				VAR_INPUT    Pointer to get actual position of the file pointer from the beginning of the file
	RTS_IEC_RESULT SysFileGetPos;		VAR_OUTPUT    
} sysfilegetpos_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>sysfilegetsize_struct</name>
<structname>sysfilegetsize_struct</structname>
Get file size of the file specified by name.
A standard path will be added to the filename, if no path is specified.
RETURN: Size of the file in bytes
<rawdata>
typedef struct tagsysfilegetsize_struct
{
	RTS_IEC_STRING *szFileName;			VAR_INPUT    File name. File name can contain an absolute or relative path to the file.
	RTS_IEC_RESULT *pResult;			VAR_INPUT    Pointer to runtime system error code (see CmpErrors.library):
	RTS_IEC_XWORD SysFileGetSize;		VAR_OUTPUT    
} sysfilegetsize_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>sysfilegetsizebyhandle_struct</name>
<structname>sysfilegetsizebyhandle_struct</structname>
Get file size of the file specified by handle
RESULT: Size of the file in bytes
<rawdata>
typedef struct tagsysfilegetsizebyhandle_struct
{
	RTS_IEC_HANDLE hFile;				VAR_INPUT    Handle of the file
	RTS_IEC_RESULT *pResult;			VAR_INPUT    Pointer to runtime system error code (see CmpErrors.library)
	RTS_IEC_XWORD SysFileGetSizeByHandle;	VAR_OUTPUT    
} sysfilegetsizebyhandle_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>sysfilegetstatus_struct</name>
<structname>sysfilegetstatus_struct</structname>
Get the file status
RETURN: File status. See category file status
<rawdata>
typedef struct tagsysfilegetstatus_struct
{
	RTS_IEC_HANDLE hFile;				VAR_INPUT    Handle of the file
	RTS_IEC_INT SysFileGetStatus;		VAR_OUTPUT, Enum: SYS_FILE_STATUS
} sysfilegetstatus_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>sysfilegetstatus2_struct</name>
<structname>sysfilegetstatus2_struct</structname>
Get the file status
RETURN: File status. See category file status
<rawdata>
typedef struct tagsysfilegetstatus2_struct
{
	RTS_IEC_HANDLE hFile;				VAR_INPUT    Handle of the file
	RTS_IEC_RESULT *pResult;			VAR_INPUT    Pointer to runtime system error code (see CmpErrors.library)
	RTS_IEC_INT SysFileGetStatus2;		VAR_OUTPUT, Enum: SYS_FILE_STATUS
} sysfilegetstatus2_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>sysfilegettime_struct</name>
<structname>sysfilegettime_struct</structname>
Get file time of the specified file.
A standard path will be added to the filename, if no path is specified.
RETURN: Returns the runtime system error code (see CmpErrors.library)
<rawdata>
typedef struct tagsysfilegettime_struct
{
	RTS_IEC_STRING *szFileName;			VAR_INPUT    File name. File name can contain an absolute or relative path to the file.
	SYS_FILETIME *ptFileTime;			VAR_INPUT    Pointer to get the file time results.
	RTS_IEC_RESULT SysFileGetTime;		VAR_OUTPUT    
} sysfilegettime_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>sysfileopen_struct</name>
<structname>sysfileopen_struct</structname>
Open or create file. A standard path will be added to the filename, if no path is specified in the file name.
If a file extension is specified in the settings, this path will be used (see category settings).
IMPLEMENTATION NOTE: File name can contain an absolute or relative path to the file. Path entries
must be separated with a '/' and not with a '\"!
RETURN: Handle to the file or RTS_INVALID_HANDLE if failed
<rawdata>
typedef struct tagsysfileopen_struct
{
	RTS_IEC_STRING *szFile;				VAR_INPUT    File name. File name can contain an absolute or relative path to the file.
	RTS_IEC_UDINT am;					VAR_INPUT, Enum: ACCESS_MODE
	RTS_IEC_RESULT *pResult;			VAR_INPUT    Pointer to runtime system error code (see CmpErrors.library)
	RTS_IEC_HANDLE SysFileOpen;			VAR_OUTPUT    
} sysfileopen_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>sysfileread_struct</name>
<structname>sysfileread_struct</structname>
Read number of bytes out of the file
RETURN: Number of bytes read from file. 0=if failed
<rawdata>
typedef struct tagsysfileread_struct
{
	RTS_IEC_HANDLE hFile;				VAR_INPUT    Handle of the file
	RTS_IEC_BYTE *pbyBuffer;			VAR_INPUT    Pointer to buffer for read data
	RTS_IEC_XWORD ulSize;				VAR_INPUT    Number of bytes to read from file. Must be less or equal the buffer size!
	RTS_IEC_RESULT *pResult;			VAR_INPUT    Pointer to runtime system error code (see CmpErrors.library)
	RTS_IEC_XWORD SysFileRead;			VAR_OUTPUT    
} sysfileread_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>sysfilerename_struct</name>
<structname>sysfilerename_struct</structname>
Rename the file.
A standard path will be added to the filename, if no path is specified.
RETURN: Returns the runtime system error code (see CmpErrors.library)
<rawdata>
typedef struct tagsysfilerename_struct
{
	RTS_IEC_STRING *szOldFileName;		VAR_INPUT    Old file name. File name can contain an absolute or relative path to the file.
	RTS_IEC_STRING *szNewFileName;		VAR_INPUT    New file name. File name can contain an absolute or relative path to the file.
	RTS_IEC_RESULT SysFileRename;		VAR_OUTPUT    
} sysfilerename_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>sysfilesetpos_struct</name>
<structname>sysfilesetpos_struct</structname>
Set the file pointer to the specified position
RESULT: Returns the runtime system error code (see CmpErrors.library)
<rawdata>
typedef struct tagsysfilesetpos_struct
{
	RTS_IEC_HANDLE hFile;				VAR_INPUT    Handle of the file
	RTS_IEC_XWORD ulOffset;				VAR_INPUT    Offset to set from the beginning of the file
	RTS_IEC_RESULT SysFileSetPos;		VAR_OUTPUT    
} sysfilesetpos_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>sysfilewrite_struct</name>
<structname>sysfilewrite_struct</structname>
Write number of bytes to the file. File must be opened with AM_WRITE or AM_APPEND.
RESULT: Number of bytes written to the file. 0=if failed
<rawdata>
typedef struct tagsysfilewrite_struct
{
	RTS_IEC_HANDLE hFile;				VAR_INPUT    Handle of the file
	RTS_IEC_BYTE *pbyBuffer;			VAR_INPUT    Pointer to buffer with data to write to file
	RTS_IEC_XWORD ulSize;				VAR_INPUT    Number of bytes to write in the file. Must be less or equal the buffer size!
	RTS_IEC_RESULT *pResult;			VAR_INPUT    Pointer to runtime system error code (see CmpErrors.library)
	RTS_IEC_XWORD SysFileWrite;			VAR_OUTPUT    
} sysfilewrite_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>SYS_FILE_INFO</name>
<structname>SYS_FILE_INFO</structname>
<category>File info</category>
<description>
<element name="pszName" type="IN">Name of the file</element>
<element name="am" type="IN">Access mode. See corresponding category</element>
<element name="status" type="IN">File status. See corresponding category</element>
<element name="hOSFile" type="IN">Operating system file handle</element>
</description>
<rawdata>
typedef struct SYS_FILE_INFO_
{
	char szName[MAX_PATH_LEN];
	RTS_ACCESS_MODE am;
	SYS_FILE_STATUS status;
	RTS_HANDLE hOSFile;
} SYS_FILE_INFO;
</rawdata>
</element>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(char *pszFile, RTS_ACCESS_MODE am, RTS_RESULT *pResult)">SysFileOpen</functionname>
<description>
<p>Open or create file. A standard path will be added to the filename, if no path is specified in the
file name.</p>
<p>If a file extension is specified in the settings, this path will be used (see category settings).</p>
<p>IMPLEMENTATION NOTE: File name can contain an absolute or relative path to the file. Path entries
must be separated with a '/' and not with a '\"!</p>
</description>
<param name="pszFile" type="IN">File name. File name can contain an absolute or relative path to the
file. Path entries must be separated with a '/' and not with a '\"!</param>
<param name="am" type="IN"><p>Requested access mode to the file:</p>
<ul>
<li>AM_READ: If file does not exist, an error is returned. If the file exists, the file
will be opened</li>
<li>AM_WRITE: If file does not exist, a new file will be created. If the file exists,
it will be overwritten!</li>
<li>AM_APPEND: If the file does not exist, an error is returned. If the file exists, the file
will be opened</li>
</ul>
</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Handle to the file or RTS_INVALID_HANDLE if failed</result>
</element>
<element function="1">
<functionname returntype="SYS_FILE_STATUS" parameters="(RTS_HANDLE hFile, RTS_RESULT *pResult)">SysFileGetStatus</functionname>
<description>Get the file status</description>
<param name="hFile" type="IN">Handle to the file</param>
<param name="pResult" type="IN">Pointer to error code</param>
<result>File status. See category file status</result>
</element>
<element function="1">
<functionname returntype="char*" parameters="(RTS_HANDLE hFile, RTS_RESULT *pResult)">SysFileGetName</functionname>
<description>Get the file name from file specified by handle</description>
<param name="hFile" type="IN">Handle to the file</param>
<param name="pResult" type="IN">Pointer to error code</param>
<result>File name</result>
</element>
<element function="1">
<functionname returntype="RTS_SIZE" parameters="(RTS_HANDLE hFile, unsigned char *pbyBuffer, RTS_SIZE uiSize, RTS_RESULT *pResult)">SysFileRead</functionname>
<description>
Read number of bytes out of the file
</description>
<param name="hFile" type="IN">Handle to the file</param>
<param name="pbyBuffer" type="OUT">Pointer to buffer for read data</param>
<param name="uiSize" type="IN">Number of bytes to read from file. Must be less or equal the buffer size!</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Number of bytes read from file. 0=if failed</result>
</element>
<element function="1">
<functionname returntype="RTS_SIZE" parameters="(RTS_HANDLE hFile, unsigned char *pbyBuffer, RTS_SIZE uiSize, RTS_RESULT *pResult)">SysFileWrite</functionname>
<description>
Write number of bytes to the file. File must be opened with AM_WRITE or AM_APPEND.
</description>
<param name="hFile" type="IN">Handle to the file</param>
<param name="pbyBuffer" type="IN">Pointer to buffer with data to write to file</param>
<param name="uiSize" type="IN">Number of bytes to write in the file. Must be less or equal the buffer size!</param>
<param name="pResult" type="OUT">Pointer to error code </param>
<errorcode name="RTS_RESULT" type="ERR_OK">File could be written</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">Invalid parameter (handle invalid, buffer pointer NULL or buffer size 0)</errorcode>
<errorcode name="RTS_RESULT" type="ERR_FAILED">Error occurred during writing</errorcode>
<errorcode name="RTS_RESULT" type="ERR_DISK_FULL">Disk is full so writing failed</errorcode>
<result>Number of bytes written to the file. 0=if failed</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hFile)">SysFileDeleteByHandle</functionname>
<description>
Delete the file specified by handle
</description>
<param name="hFile" type="IN">Handle to the file</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hFile, RTS_SIZE uiOffset)">SysFileSetPos</functionname>
<description>
Set the file pointer to the specified position
</description>
<param name="hFile" type="IN">Handle to the file</param>
<param name="uiOffset" type="IN">Offset to set from the beginning of the file</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hFile, RTS_SIZE *puiPos)">SysFileGetPos</functionname>
<description>
Get actual file pointer position
</description>
<param name="hFile" type="IN">Handle to the file</param>
<param name="puiPos" type="OUT">Pointer to get actual position of the file pointer from
the beginning of the file</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_SIZE" parameters="(RTS_HANDLE hFile, RTS_RESULT *pResult)">SysFileGetSizeByHandle</functionname>
<description>
Get file size of the actual opened file
</description>
<param name="hFile" type="IN">Handle to the file</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Size of the file in bytes</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hFile)">SysFileEOF</functionname>
<description>
Check, if end of file is reached at reading from the file.
IMPLEMENTATION NOTE:
End of file is only checked after a read operation with SysFileRead! But after a SysFileWrite or SysFileSetPos call, the function
returns ERR_FAILED (no end of file)!
</description>
<param name="hFile" type="IN">Handle to the file</param>
<result>Error code:
<ul>
<li>ERR_OK: End of file reached at reading beyond the end of the file</li>
<li>ERR_FAILED: No end of file reached</li>
<li>ERR_PARAMETER: hFile is invalid</li>
</ul>
</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hFile)">SysFileFlush</functionname>
<description>
Flush the file cache and write into the file.
</description>
<param name="hFile" type="IN">Handle to the file</param>
<result>Error code:
<ul>
<li>ERR_OK: Succeeded flushing the file</li>
<li>ERR_FAILED: Error occurred during file flush</li>
<li>ERR_NOTIMPLEMENTED: File flush is not implemented</li>
<li>ERR_NOT_SUPPORTED: File flush not available on the target</li>
</ul>
</result>
</element>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(char *pszFile, RTS_ACCESS_MODE am, RTS_RESULT *pResult)">SysFileOpen_</functionname>
<description>Open or create a file. File will be opened with no standard path. The file name
will be used as it is.</description>
<param name="pszFile" type="IN">File name. File name can contain an absolute or relative path to the
file. Path entries must be separated with a '/' and not with a '\"!</param>
<param name="am" type="IN"><p>Requested access mode to the file:</p>
<ul>
<li>AM_READ: If file does not exist, an error is returned. If the file exists, the file
will be opened</li>
<li>AM_WRITE: If file does not exist, a new file will be created. If the file exists,
it will be overwritten!</li>
<li>AM_APPEND: If the file does not exist, an error is returned. If the file exists, the file
will be opened</li>
</ul>
</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Handle to the file or RTS_INVALID_HANDLE if failed</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char *pszFile)">SysFileDelete</functionname>
<description>
Delete the file specified by name.
A standard path will be added to the filename, if no path is specified.
</description>
<param name="pszFile" type="IN">File name. File name can contain an absolute or relative path to the
file. Path entries must be separated with a '/' and not with a '\"!</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char *pszFile)">SysFileDelete_</functionname>
<description>
Delete the file specified by name. Filename will be used with no standard path.
</description>
<param name="pszFile" type="IN">File name. File name can contain an absolute or relative path to the
file. Path entries must be separated with a '/' and not with a '\"!</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char *pszOldFileName, char *pszNewFileName)">SysFileRename</functionname>
<description>
Rename the file.
A standard path will be added to the filename, if no path is specified.
</description>
<param name="pszOldFileName" type="IN">Old file name. File name can contain an absolute or relative path to the
file. Path entries must be separated with a '/' and not with a '\"!</param>
<param name="pszNewFileName" type="IN">New file name. File name can contain an absolute or relative path to the
file. Path entries must be separated with a '/' and not with a '\"!</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char *pszOldFileName, char *pszNewFileName)">SysFileRename_</functionname>
<description>
Rename the file. File will be renamed with no standard path.
</description>
<param name="pszOldFileName" type="IN">Old file name. File name can contain an absolute or relative path to the
file. Path entries must be separated with a '/' and not with a '\"!</param>
<param name="pszNewFileName" type="IN">New file name. File name can contain an absolute or relative path to the
file. Path entries must be separated with a '/' and not with a '\"!</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_SIZE" parameters="(char *pszFile, RTS_RESULT *pResult)">SysFileGetSize</functionname>
<description>
Get file size of the file specified by name
A standard path will be added to the filename, if no path is specified.
</description>
<param name="pszFile" type="IN">File name. File name can contain an absolute or relative path to the
file. Path entries must be separated with a '/' and not with a '\"!</param>
<param name="pResult" type="OUT">Pointer to error code:
ERR_OK: Successful
ERR_NO_OBJECT: File not available
ERR_FAILED: Failed to get file size
</param>
<result>Size of the file in bytes</result>
</element>
<element function="1">
<functionname returntype="RTS_SIZE" parameters="(char *pszFile, RTS_RESULT *pResult)">SysFileGetSize_</functionname>
<description>
Get file size of the file specified by name, No standard path will be added to the file name.
</description>
<param name="pszFile" type="IN">File name. File name can contain an absolute or relative path to the
file. Path entries must be separated with a '/' and not with a '\"!</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Size of the file in bytes</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char *pszFile, SYS_FILETIME *pftFileTime)">SysFileGetTime</functionname>
<description>
Get file time of the specified file.
A standard path will be added to the filename, if no path is specified.
</description>
<param name="pszFile" type="IN">File name. File name can contain an absolute or relative path to the
file. Path entries must be separated with a '/' and not with a '\"!</param>
<param name="pftFileTime" type="OUT">Pointer to get the file time results.
IMPLEMENTATION NOTE: All time values must be local time!</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char *pszFile, SYS_FILETIME *pftFileTime)">SysFileGetTime_</functionname>
<description>
Get file time of the file specified by name. No standard path will be added.
</description>
<param name="pszFile" type="IN">File name. File name can contain an absolute or relative path to the
file. Path entries must be separated with a '/' and not with a '\"!</param>
<param name="pftFileTime" type="OUT">Pointer to get the file time results.
IMPLEMENTATION NOTE: All time values must be local time!</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char *pszDestFileName, char *pszSourceFileName, RTS_SIZE *puiCopied)">SysFileCopy</functionname>
<description>
Copy one file to another.
A standard path will be added to the filename, if no path is specified.
IMPLEMENTATION NOTE:
If the destination file exists, the file will be overwritten and the function succeeded.
</description>
<param name="pszDestFileName" type="IN">Destination file name. File name can contain an absolute or relative path to the
file. Path entries must be separated with a '/' and not with a '\"!</param>
<param name="pszSourceFileName" type="IN">Source file name. File name can contain an absolute or relative path to the
file. Path entries must be separated with a '/' and not with a '\"!</param>
<param name="puiCopied" type="OUT">Number of bytes copied</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char *pszDestFileName, char *pszSourceFileName, RTS_SIZE *puiCopied)">SysFileCopy_</functionname>
<description>
Copy one file in another. No standard path will be added to filename.
</description>
<param name="pszFile" type="IN">File name. File name can contain an absolute or relative path to the
file. Path entries must be separated with a '/' and not with a '\"!</param>
<param name="pftFileTime" type="OUT">Pointer to get the file time results</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char *pszFileName, char *pszPath, RTS_SIZE iMaxLen)">SysFileGetPath</functionname>
<description>
Get the path of this file. If a path is specified in the filename, the path will be extracted from the filename.
If no path is specified in the filename, the standard path for this file extension type will be returned.
</description>
<param name="pszFileName" type="IN">File name. Can contain an absolute or relative path</param>
<param name="pszPath" type="OUT">Path for this file</param>
<param name="iMaxLen" type="IN">Maximum size in bytes of path length</param>
<result>error code</result>
<errorcode name="RTS_RESULT" type="ERR_OK">Resolved file path is correctly returned</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">Invalid parameter (pointer NULL or length 0)</errorcode>
<errorcode name="RTS_RESULT" type="ERR_OPERATION_DENIED">Access to this file path not allowed! The following file or directory access must be denied!</errorcode>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char *pszFileName, char *pszPath, RTS_SIZE iMaxLen)">SysFileGetIecPath</functionname>
<description>
Get the path of this file for Iec applications. If a path is specified in the filename, the path will be extracted from the filename.
If no path is specified in the filename, the standard path for this file extension type will be returned.
</description>
<param name="pszFileName" type="IN">File name. Can contain an absolute or relative path</param>
<param name="pszPath" type="OUT">Path for this file</param>
<param name="iMaxLen" type="IN">Maximum size in bytes of path length</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char *pszFile, RTS_SIZE ulSize, RTS_UI32 *pulCRC)">SysFileGenerateCRC</functionname>
<description>
Generate the CRC32 of a file. Can be used to check file integrity.
ATTENTION: Only for backward compatibility! CRC is implemented not independant from buffer size!
</description>
<param name="pszFile" type="IN">File name. Can contain an absolute or relative path</param>
<param name="ulSize" type="IN">Size to calculate checksum. 0 if real size of file should be used [default]</param>
<param name="pulCRC" type="OUT">Pointer to get CRC32 result</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char *pszFile, RTS_SIZE ulSize, RTS_UI32 *pulCRC)">SysFileGenerateCRC2</functionname>
<description>
Generate the CRC32 of a file. Can be used to check file integrity.
</description>
<param name="pszFile" type="IN">File name. Can contain an absolute or relative path</param>
<param name="ulSize" type="IN">Size to calculate checksum. 0 if real size of file should be used [default]</param>
<param name="pulCRC" type="OUT">Pointer to get CRC32 result</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char *pszFile, RTS_SIZE ulSize, RTS_UI32 *pulCRC)">SysFileGenerateCRC2_</functionname>
<description>
Generate the CRC32 of a file. Can be used to check file integrity.
IMPLEMENTATION NOTE:
This interface function is implemented operating system dependant! Optimizations can be done here.
</description>
<param name="pszFile" type="IN">File name. Can contain an absolute or relative path</param>
<param name="ulSize" type="IN">Size to calculate checksum. 0 if real size of file should be used [default]</param>
<param name="pulCRC" type="OUT">Pointer to get CRC32 result</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char *pszFileName)">SysFileIsInvisible</functionname>
<description>
Interface function to check, if the filename has a prefix that marked that this file must be invisible outside the runtime system (e.g. in CmpFileTransfer).
</description>
<param name="pszFileName" type="IN">HPointer to the filename to check</param>
<result>Error code:
<ul>
<li>ERR_OK: Invisible file! Must be invisible outside the runtime system (e.g. in CmpFileTransfer)</li>
<li>ERR_FAILED: No invisible file</li>
<li>ERR_PARAMETER: Invalid parameter pszFileName</li>
</ul>
</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hFile)">SysFileClose</functionname>
<description>Close a file specified by handle</description>
<param name="hFile" type="IN">Handle to the file</param>
<result>error code</result>
</element>
</element>
<element interface="1" name="SysDirItf">
<interfacename>SysDir</interfacename>
<description>
<p>The SysDir interface is projected to handle all system dependant directory operations.
If there is no filesystem on the target, the interface functions ERR_NOTIMPLEMENTED.</p>
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element define="1">
<name>DF_FILE</name>
<key>0x00000000</key>
<category>Directory info flags</category>
<element name="DF_FILE" type="IN">Entry is a file</element>
<element name="DF_DIRECTORY" type="IN">Entry is a directory</element>
</element>
<element typedefinition="1">
<name>DirFileTime</name>
<structname>DirFileTime</structname>
<category>Directory file time</category>
<element name="ulCreation" type="IN">Creation date of the file</element>
<element name="ulLastAccess" type="IN">Date of last access to the file</element>
<element name="ulLastModification" type="IN">Date of last modification to the file</element>
<rawdata>
typedef struct
{
	RTS_UI32 ulCreation;
	RTS_UI32 ulLastAccess;
	RTS_UI32 ulLastModification;
} DirFileTime;
</rawdata>
</element>
<element typedefinition="1">
<name>DirInfo</name>
<structname>DirInfo</structname>
<category>Directory info entry</category>
<description>
This structure contains the description of one directory entry
</description>
<element name="dft" type="IN">Directory dates</element>
<element name="ulSize" type="IN">Size of the directory</element>
<element name="ulFlags" type="IN">Flag of a directory</element>
<rawdata>
typedef struct
{
	DirFileTime dft;
	RTS_UI32 ulSize;
	RTS_UI32 ulFlags;
} DirInfo;
</rawdata>
</element>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(char *pszDir, char *pszDirEntry, int iMaxDirEntry, DirInfo *pDirInfo, RTS_RESULT *pResult)">SysDirOpen</functionname>
<description>Opens a specified directory and returns a handle and the first directory entry</description>
<param name="pszDir" type="IN">Name of directory.
IMPLEMENTATION NOTE: Empty string ("") is the request for the current working directory.</param>
<param name="pszDirEntry" type="OUT">Directory entry as string</param>
<param name="iMaxDirEntry" type="IN">Max number of bytes to write in pszDirEntry</param>
<param name="pDirInfo" type="OUT">Directory information</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>RTS_HANDLE on directory</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hDir, char *pszDirEntry, int iMaxDirEntry, DirInfo *pDirInfo)">SysDirRead</functionname>
<description>Read next directory entry. Writes the entry in pszDirEntry.</description>
<param name="hDir" type="IN">Handle to directory opened with SysDirOpen</param>
<param name="pszDirEntry" type="OUT">Directory entry as string</param>
<param name="iMaxDirEntry" type="OUT">Max number of bytes to write in pszDirEntry</param>
<param name="pDirInfo" type="OUT">Pointer to directory information.
IMPLEMENTATION NOTE:
Can be NULL (so only directory name is provided in pszDirEntry) </param>
<result>
<ul>
<li>ERR_OK: The directory string contains the next directory entry and is referenced by "pszDirEntry", "pDirInfo" references the related directory information string.</li>
<li>ERR_END_OF_OBJECT: If end of directory list was reached, the "pszDirEntry" referenced buffer stays empty.</li>
<li>ERR_PARAMETER: If one of the parameters is invalid, the function returns without updating the directory iterator.</li>
<li>ERR_BUFFERSIZE: If iMaxDirEntry is too short to get the complete directory entry string but not null.
ATTENTION: Typically if this error occurs, the "pszDirEntry" contains the string to the incomplete next entry, the iterator is updated!</li>
</ul>
</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char *pszDir)">SysDirCreate</functionname>
<description>Creates a new directory with the specified name</description>
<param name="pszDir" type="IN">Name of directory</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char *pszDir)">SysDirDelete</functionname>
<description>Deletes a directory with the specified name</description>
<param name="pszDir" type="IN">Name of directory</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char *pszOldDir, char *pszNewDir)">SysDirRename</functionname>
<description>Rename directory</description>
<param name="pszOldDir" type="IN">Name of existing directory</param>
<param name="pszNewDir" type="IN">New name</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char *pszDir, int iMaxDirLen)">SysDirGetCurrent</functionname>
<description>Get current working directory</description>
<param name="pszDir" type="OUT">Name of current directory</param>
<param name="iMaxDirLen" type="IN">Max lenght of directory buffer</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char *pszDir)">SysDirSetCurrent</functionname>
<description> Set current working directory </description>
<param name="pszDir" type="IN">Name of current directory</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hDir)">SysDirClose</functionname>
<description>Close an open directory</description>
<param name="hDir" type="IN">Handle to directory opened with SysDirOpen</param>
<result>error code</result>
</element>
</element>
</component>
<component>
<name>SysFlash</name>
<description>
System component for flash access.
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element interface="1" name="SysFlashItf">
<interfacename>SysFlash</interfacename>
<description>
<p>The SysFlash interface is projected to get access to flash memory of a controller.
It has to be adpated to your flash.</p>
<p>There are functions to read and write to flash memory. It is used by some implementations
of the file component (SysFileFlash) to store some files in flash, and by the
application component for execution of user code in flash.
The SysFlash Component divides two different kinds of flash areas:
FA_CODE and FA_FILE. FA_FILE is only needed, if SysFileFlash is used.
Please see further description for SysFileFlash and our Flash-Filesystem.
Please note that the offsets of the files have to correspond with sector borders of the flash. One file should be
stored in one sector.</p>
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(FlashArea fa)">SysFlashInit</functionname>
<description>
Init the flash system
</description>
<param name="fa" type="IN" range="[FA_UNKNOWN,FA_FILE,FA_CODE]">Flash area that shall be used for the operation. Now, FA_CODE and FA_FILE are defined.</param>
<errorcode name="RTS_RESULT Result" type="ERR_OK">Flash init was successful</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_NOT_SUPPORTED">Type of Flasharea is not supported</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_FAILED">Flash could not be initialized </errorcode>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(FlashArea fa, RTS_SIZE ulSize, RTS_SIZE ulOffset)">SysFlashErase</functionname>
<description>
Erases a block of flash memory. You must erase a flash area before writing to it.
This function is implemented in the generic part of SysFlash and splits up the block to erase in several smaller pieces with the
maximum size of EraseBlockSize. For each piece SysFlashErase_() and the CommCycleHook is called, to keep the rest of the RTS
also on single-tasking systems alive.
</description>
<param name="fa" type="IN" range="[FA_UNKNOWN,FA_FILE,FA_CODE]">Flash area that shall be used for the operation. Now, FA_CODE and FA_FILE are defined.</param>
<param name="ulSize" type="IN" range="[0,VALID_FLASH_SIZE,INVALID_FLASH_SIZE]">Size of flash area to erase</param>
<param name="ulOffset" type="IN" range="[0,VALID_FLASH_OFFSET,INVALID_FLASH_OFFSET]">Offset of flash area to erase. The function adds the start address of the flash to calculate the physical address of the area.</param>
<errorcode name="RTS_RESULT Result" type="ERR_OK">Flash erase was successful</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_NOT_SUPPORTED">Type of Flasharea is not supported</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_PARAMETER">size or offset wrong</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_FAILED">Flash could not be erased </errorcode>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(FlashArea fa, char *pcDest, RTS_SIZE ulSize, RTS_SIZE ulOffset)">SysFlashRead</functionname>
<description>
Reads a block of memory from the flash.
This function is implemented in the generic part of SysFlash and splits up the block to read in several smaller pieces with the
maximum size of ReadBlockSize. For each piece SysFlashRead_() and the CommCycleHook is called, to keep the rest of the RTS
also on single-tasking systems alive.
</description>
<param name="fa" type="IN" range="[FA_UNKNOWN,FA_FILE,FA_CODE]">Flash area that shall be used for the operation. Now, FA_CODE and FA_FILE are defined.</param>
<param name="pcDest" type="IN" range="[0,INVALID_DEST_BUFFER,VALID_DEST_BUFFER]">Pointer to buffer that receives the data</param>
<param name="ulSize" type="IN" range="[0,VALID_BUFFER_SIZE,INVALID_BUFFER_SIZE]">Size of the buffer</param>
<param name="ulOffset" type="IN" range="[0,VALID_FLASH_OFFSET,INVALID_FLASH_OFFSET]">Offset of flash area to read from. The function adds the start address of the flash to calculate the physical address of the area.</param>
<errorcode name="RTS_RESULT Result" type="ERR_OK">Flash read was successful</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_NOT_SUPPORTED">Type of Flasharea is not supported</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_PARAMETER">pcDest,size or offset wrong or null</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_FAILED">Flash could not be read </errorcode>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(FlashArea fa, char *pcSource, RTS_SIZE ulSize, RTS_SIZE ulOffset)">SysFlashWrite</functionname>
<description>
Writes a block of data to the flash. The flash area has to be erased first with SysFlashErase.
This function is implemented in the generic part of SysFlash and splits up the block to write in several smaller pieces with the
maximum size of WriteBlockSize. For each piece SysFlashWrite() and the CommCycleHook is called, to keep the rest of the RTS
also on single-tasking systems alive.
</description>
<param name="fa" type="IN" range="[FA_UNKNOWN,FA_FILE,FA_CODE]">Flash area that shall be used for the operation. Now, FA_CODE and FA_FILE are defined.</param>
<param name="pcSource" type="IN" range="[0,INVALID_SRC_BUFFER,VALID_SRC_BUFFER]">Pointer to buffer that contains the data</param>
<param name="ulSize" type="IN" range="[0,VALID_BUFFER_SIZE,INVALID_BUFFER_SIZE]">Size of the buffer</param>
<param name="ulOffset" type="IN" range="[0,VALID_FLASH_OFFSET,INVALID_FLASH_OFFSET]">Offset of flash area to write to. The function adds the start address of the flash to calculate the physical address of the area.</param>
<errorcode name="RTS_RESULT Result" type="ERR_OK">Flash read was successful</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_NOT_SUPPORTED">Type of Flasharea is not supported</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_PARAMETER">pcSrc,size or offset wrong or null</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_FAILED">Flash could not be read </errorcode>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(FlashArea fa, RTS_SIZE ulSize, RTS_SIZE ulOffset)">SysFlashFlush</functionname>
<description>
Called when a file that was opened for writing is closed.
This function is implemented in the generic part of SysFlash and splits up the block to flush in several smaller pieces with the
maximum size of FlushBlockSize. For each piece SysFlashFlush() and the CommCycleHook is called, to keep the rest of the RTS
also on single-tasking systems alive.
</description>
<param name="fa" type="IN" range="[FA_UNKNOWN,FA_FILE,FA_CODE]">Flash area that shall be used for the operation. Now, FA_CODE and FA_FILE are defined.</param>
<param name="ulSize" type="IN" range="[0,VALID_BUFFER_SIZE,INVALID_BUFFER_SIZE]">Size of the buffer</param>
<param name="ulOffset" type="IN" range="[0,VALID_FLASH_OFFSET,INVALID_FLASH_OFFSET]">Offset of flash area to write to. The function adds the start address of the flash to calculate the physical address of the area.</param>
<errorcode name="RTS_RESULT Result" type="ERR_OK">Flash flush was successful</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_NOT_SUPPORTED">Type of Flasharea is not supported</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_PARAMETER">size or offset wrong or null</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_FAILED">Flash could not be flushed </errorcode>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_UINTPTR" parameters="(FlashArea fa, RTS_RESULT *pResult)">SysFlashGetPhysicalAddress</functionname>
<description>
Retrieve the physical address of a flash area
</description>
<param name="fa" type="IN" range="[FA_UNKNOWN,FA_FILE,FA_CODE]">Flash area that shall be used for the operation. Now, FA_CODE and FA_FILE are defined.</param>
<parampseudo name="bWriteFlashPattern" type="IN" range="[TRUE,FALSE]">A pattern was written to the flash, using SysFlashWrite(), before the call to SysFlashGetPhysicalAddress().</parampseudo>
<parampseudo name="bWriteMemoryPattern" type="IN" range="[TRUE,FALSE]">A pattern was written to the flash, using direct memory access, before the call to SysFlashGetPhysicalAddress().</parampseudo>
<parampseudo name="bFlashFlush" type="IN" range="[TRUE,FALSE]">SysFlashFlush() was called before the call to SysFlashGetPhysicalAddress().</parampseudo>
<parampseudo name="bExceptionGenerated" type="OUT" range="[TRUE,FALSE]">An exception was generated.</parampseudo>
<parampseudo name="bPatternExists" type="OUT" range="[TRUE,FALSE]">The pattern could be read, using standard memory access.</parampseudo>
<param name="pResult" type="OUT">Pointer to error code</param>
<errorcode name="RTS_RESULT pResult" type="ERR_OK">Startaddress was successful retrieved</errorcode>
<errorcode name="RTS_RESULT pResult" type="ERR_NOT_SUPPORTED">Type of Flasharea is not supported</errorcode>
<errorcode name="RTS_RESULT pResult" type="ERR_FAILED">Startaddress could not be retrieved</errorcode>
<result>Physical address of flash area</result>
</element>
<element function="1">
<functionname returntype="RTS_SIZE" parameters="(FlashArea fa, RTS_RESULT *pResult)">SysFlashGetSize</functionname>
<description>
Retrieve the size of a flash area
</description>
<param name="fa" type="IN" range="[FA_UNKNOWN,FA_FILE,FA_CODE]">Flash area that shall be used for the operation. Now, FA_CODE and FA_FILE are defined.</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<errorcode name="RTS_RESULT pResult" type="ERR_OK">Flashsize was successful retrieved</errorcode>
<errorcode name="RTS_RESULT pResult" type="ERR_NOT_SUPPORTED">Type of Flasharea is not supported</errorcode>
<errorcode name="RTS_RESULT pResult" type="ERR_FAILED">Flashsize could not be retrieved</errorcode>
<result>Size of flash area</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(FlashArea fa, RTS_SIZE ulSize, RTS_SIZE ulOffset)">SysFlashErase_</functionname>
<description>
Erases a block of flash memory. You must erase a flash area before writing to it. The content of the flash area should be erased with 0 or ff.
Must be implemented in the OS-specific part of SysFlash. Should only be called by SysFlashErase().
</description>
<param name="fa" type="IN" range="[FA_UNKNOWN,FA_FILE,FA_CODE]">Flash area that shall be used for the operation. Now, FA_CODE and FA_FILE are defined.</param>
<param name="ulSize" type="IN" range="[0,VALID_BUFFER_SIZE,INVALID_BUFFER_SIZE]">Size of flash area to erase</param>
<param name="ulOffset" type="IN" range="[0,VALID_FLASH_OFFSET,INVALID_FLASH_OFFSET]">Offset of flash area to erase. The function adds the start address of the flash to calculate the physical address of the area.</param>
<errorcode name="RTS_RESULT pResult" type="ERR_OK">Flash was successfully erased</errorcode>
<errorcode name="RTS_RESULT pResult" type="ERR_NOT_SUPPORTED">Type of Flasharea is not supported</errorcode>
<errorcode name="RTS_RESULT pResult" type="ERR_PARAMETER">Size or Offset is not correct</errorcode>
<errorcode name="RTS_RESULT pResult" type="ERR_FAILED">Flash could not be erased</errorcode>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(FlashArea fa, char *pcDest, RTS_SIZE ulSize, RTS_SIZE ulOffset)">SysFlashRead_</functionname>
<description>
Reads a block of memory from the flash.
Must be implemented in the OS-specific part of SysFlash. Should only be called by SysFlashRead().
</description>
<param name="fa" type="IN" range="[FA_UNKNOWN,FA_FILE,FA_CODE]">Flash area that shall be used for the operation. Now, FA_CODE and FA_FILE are defined.</param>
<param name="pcDest" type="IN" range="[0,INVALID_DEST_BUFFER,VALID_DEST_BUFFER]">Pointer to buffer that receives the data</param>
<param name="ulSize" type="IN" range="[0,VALID_BUFFER_SIZE,INVALID_BUFFER_SIZE]">Size of the buffer</param>
<param name="ulOffset" type="IN" range="[0,VALID_FLASH_OFFSET,INVALID_FLASH_OFFSET]">Offset of flash area to read from. The function adds the start address of the flash to calculate the physical address of the area.</param>
<errorcode name="RTS_RESULT pResult" type="ERR_OK">Flash was successfully read</errorcode>
<errorcode name="RTS_RESULT pResult" type="ERR_NOT_SUPPORTED">Type of Flasharea is not supported</errorcode>
<errorcode name="RTS_RESULT pResult" type="ERR_PARAMETER">Size or Offset is not correct</errorcode>
<errorcode name="RTS_RESULT pResult" type="ERR_FAILED">Flash could not be read</errorcode>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(FlashArea fa, char *pcSource, RTS_SIZE ulSize, RTS_SIZE ulOffset)">SysFlashWrite_</functionname>
<description>
Writes a block of data to the flash. The flash area has to be erased first with SysFlashErase.
Must be implemented in the OS-specific part of SysFlash. Should only be called by SysFlashWrite().
</description>
<param name="fa" type="IN" range="[FA_UNKNOWN,FA_FILE,FA_CODE]">Flash area that shall be used for the operation. Now, FA_CODE and FA_FILE are defined.</param>
<param name="pcSource" type="IN" range="[0,INVALID_SRC_BUFFER,VALID_SRC_BUFFER]">Pointer to buffer that contains the data</param>
<param name="ulSize" type="IN" range="[0,VALID_BUFFER_SIZE,INVALID_BUFFER_SIZE]">Size of the buffer</param>
<param name="ulOffset" type="IN" range="[0,VALID_FLASH_OFFSET,INVALID_FLASH_OFFSET]">Offset of flash area to write to. The function adds the start address of the flash to calculate the physical address of the area.</param>
<errorcode name="RTS_RESULT pResult" type="ERR_OK">Flash was successfully written</errorcode>
<errorcode name="RTS_RESULT pResult" type="ERR_NOT_SUPPORTED">Type of Flasharea is not supported</errorcode>
<errorcode name="RTS_RESULT pResult" type="ERR_PARAMETER">Size or Offset is not correct</errorcode>
<errorcode name="RTS_RESULT pResult" type="ERR_FAILED">Flash could not be written</errorcode>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(FlashArea fa, RTS_SIZE ulSize, RTS_SIZE ulOffset)">SysFlashFlush_</functionname>
<description>
Called when a file that was opened for writing is closed. Normally, this function can be left empty.
It can be useful, if the data is not written to flash directly, but buffered in RAM. The call of this function indicates
that the file is closed and the data has to be written to flash.
Must be implemented in the OS-specific part of SysFlash. Should only be called by SysFlashFlush().
</description>
<param name="fa" type="IN" range="[FA_UNKNOWN,FA_FILE,FA_CODE]">Flash area that shall be used for the operation. Now, FA_CODE and FA_FILE are defined.</param>
<param name="ulSize" type="IN" range="[0,VALID_BUFFER_SIZE,INVALID_BUFFER_SIZE]">Size of the buffer</param>
<param name="ulOffset" type="IN" range="[0,VALID_FLASH_OFFSET,INVALID_FLASH_OFFSET]">Offset of flash area to write to. The function adds the start address of the flash to calculate the physical address of the area.</param>
* <errorcode name="RTS_RESULT pResult" type="ERR_OK">Flash was successfully flushed</errorcode>
<errorcode name="RTS_RESULT pResult" type="ERR_NOT_SUPPORTED">Type of Flasharea is not supported</errorcode>
<errorcode name="RTS_RESULT pResult" type="ERR_PARAMETER">Size or Offset is not correct</errorcode>
<errorcode name="RTS_RESULT pResult" type="ERR_FAILED">Flash could not be flushed</errorcode>
<result>error code</result>
</element>
</element>
</component>
<component>
<name>SysInt</name>
<description>
Component for interrupt handling
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element interface="1" name="SysIntItf">
<interfacename>SysInt</interfacename>
<description>
<p>The SysInt interface is projected to get access to the hardware interrupts of
the system.</p>
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element define="1">
<name>MAX_INT</name>
<key>2</key>
<condition>MAX_INT</condition>
<category>Static defines</category>
<description>Maximum number of interrupts</description>
</element>
<element define="1">
<name>MAX_INT_CALLBACKS</name>
<key>1</key>
<condition>MAX_INT_CALLBACKS</condition>
<category>Static defines</category>
<description>Maximum number of callback function for each interrupt</description>
</element>
<element define="1">
<name>SYS_INT_NONE</name>
<key>0</key>
<category>Interrupt handler type</category>
<description>Specification, which type of routine the handler is</description>
</element>
<element define="1">
<name>EVT_INTERRUPT_0</name>
<key>MAKE_EVENTID</key>
<category>Events</category>
<description>Hardware interrupt events</description>
<param name="pEventParam" type="IN">EVTPARAM_SysInt</param>
</element>
<element define="1">
<name>BT_Internal</name>
<key>0</key>
<category>Bus types</category>
<description>Architecture specific bus types</description>
</element>
<element define="1">
<name>IM_LevelSensitive</name>
<key>0</key>
<category>Interrupt modes</category>
<description></description>
</element>
<element typedefinition="1">
<name>EVTPARAM_SysInt</name>
<structname>EVTPARAM_SysInt</structname>
<category>Event parameter</category>
<element name="ulInterrupt" type="IN">Interrupt number</element>
<rawdata>
typedef struct
{
	unsigned long ulInterrupt;
} EVTPARAM_SysInt;
</rawdata>
</element>
<element typedefinition="1">
<name>SYS_INT_CALLBACK_INFO</name>
<structname>SYS_INT_CALLBACK_INFO</structname>
<description>Sys Int Callback Info Struct</description>
<param name="pCallback">Pointer to Callback for Sys Int Callback Info</param>
<param name="ulType">Type of Sys Int Callback Info</param>
<param name="ulAdditionalInfo">Additional Info for Sys Int Callback Info</param>
<rawdata>
typedef struct
{
	SYS_INT_INTHANDLER 	pCallback;
	unsigned long		ulType;
	RTS_UINTPTR			ulAdditionalInfo;
}SYS_INT_CALLBACK_INFO;
</rawdata>
</element>
<element typedefinition="1">
<name>SYS_INT_INFO</name>
<structname>SYS_INT_INFO</structname>
<description>Sys Int Info Struct</description>
<param name="pszName">Name for Sys Int Info</param>
<param name="pSysData">SysData Pointer for Sys Int Info</param>
<param name="hCallbackPool">Handle for CallbackPool for Sys Int Info</param>
<param name="ulInterrupt">InterruptNr for Sys Int Info</param>
<rawdata>
typedef struct
{
	char*					pszName;
	void*					pSysData;
	RTS_HANDLE				hCallbackPool;
	unsigned long			ulInterrupt;
}SYS_INT_INFO;
</rawdata>
</element>
<element typedefinition="1">
<name>PciInterrupt</name>
<structname>PciInterrupt</structname>
<description>PciInterrupt Struct</description>
<param name="ulBusNumber">Bus Nr. for PciInterrupt</param>
<param name="ulDevciceNumber">Device Nr. for PciInterrupt</param>
<param name="ulFunctionNumber">Function Nr. for PciInterrupt</param>
<param name="ulIntLine">IntLine for PciInterrupt</param>
<rawdata>
typedef struct
{
	RTS_IEC_UDINT ulBusNumber;
	RTS_IEC_UDINT ulDevciceNumber;
	RTS_IEC_UDINT ulFunctionNumber;
	RTS_IEC_UDINT ulIntLine;
} PciInterrupt;
</rawdata>
</element>
<element typedefinition="1">
<name>IsaInterrupt</name>
<structname>IsaInterrupt</structname>
<description>Isa Interrupt Struct</description>
<param name="ulBusNumber">Bus Nr. for Isa Interrupt</param>
<param name="ulDevciceNumber">Device Nr. for Isa Interrupt</param>
<param name="ulFunctionNumber">Function Nr. for Isa Interrupt</param>
<param name="ulIntLine">IntLine for Isa Interrupt</param>
<rawdata>
typedef struct
{
	RTS_IEC_UDINT ulBusNumber;
	RTS_IEC_UDINT ulDevciceNumber;
	RTS_IEC_UDINT ulFunctionNumber;
	RTS_IEC_UDINT ulIntLine;
} IsaInterrupt;
</rawdata>
</element>
<element typedefinition="1">
<name>SYS_INT_DESCRIPTION</name>
<structname>SYS_INT_DESCRIPTION</structname>
<category>Interrupt description</category>
<description>Optional description for an interrupt</description>
<param name="BusType">Bus type (architecture specific), See category "Bus types" for details.</param>
<param name="InterruptMode">Interrupt mode</param>
<param name="busSpecific">Pci bus specific definitions</param>
<rawdata>
typedef struct
{
	RTS_IEC_UDINT BusType;
	RTS_IEC_UDINT InterruptMode;
	BusSpecific	busSpecific;
} SYS_INT_DESCRIPTION;
</rawdata>
</element>
<element typedefinition="1">
<name>iecinthandlerinstance_struct</name>
<structname>iecinthandlerinstance_struct</structname>
<description>Iec Int Handler Instance Struct</description>
<param name="__VFTABLEPOINTER">Pointer to virtual function table</param>
<param name="Itf">Interface</param>
<rawdata>
typedef struct
{
	void* __VFTABLEPOINTER;
	RTS_IEC_DWORD Itf;
} iecinthandlerinstance_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>sysintregisterinstance_struct</name>
<structname>sysintregisterinstance_struct</structname>
<description>SysIntRegisterInstance Struct</description>
<param name="hInt">Handle for Register Instance</param>
<param name="dwClassId">ClassID for Register Instance</param>
<param name="dwItfId">Itf Id for Register Instance</param>
<param name="pInterface">Pointer to IecIntHandlerInstance Struct</param>
<param name="ulAdditonalInfo">Additional Info</param>
<param name="Result">Result</param>
<rawdata>
typedef struct
{
	RTS_IEC_HANDLE	hInt;
	RTS_IEC_DWORD	dwClassId;
	RTS_IEC_DWORD	dwItfId;
	iecinthandlerinstance_struct *pInterface;
	RTS_IEC_VOIDPTR	ulAdditonalInfo;
	RTS_IEC_UDINT	Result;
} sysintregisterinstance_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>sysintunregisterinstance_struct</name>
<structname>sysintunregisterinstance_struct</structname>
<description>SysIntUnRegisterInstance Struct</description>
<param name="hInt">Handle for Unregister Instance</param>
<param name="pInterface">Pointer to IecIntHandlerInstance Struct</param>
<param name="Result">Result</param>
<rawdata>
typedef struct
{
	RTS_IEC_HANDLE	hInt;
	iecinthandlerinstance_struct *pInterface;
	RTS_IEC_UDINT	Result;
} sysintunregisterinstance_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>sysintopen_struct</name>
<structname>sysintopen_struct</structname>
<description>SysIntOpen Struct</description>
<param name="ulInterrupt">Interrupt Nr. for IntOpen</param>
<param name="pIntDescription">Int Description</param>
<param name="pResult">Pointer to Result</param>
<param name="out">Output</param>
<param name="Result">Result</param>
<rawdata>
typedef struct
{
	RTS_IEC_DWORD	ulInterrupt;
	SYS_INT_DESCRIPTION *pIntDescription;
	RTS_IEC_UDINT	*pResult;
	RTS_IEC_HANDLE	out;
}sysintopen_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>sysintopenbyname_struct</name>
<structname>sysintopenbyname_struct</structname>
<description>SysIntOpenByName Struct</description>
<param name="pszIntName">Interrupt Name</param>
<param name="pResult">Pointer to Result</param>
<param name="out">Output</param>
<param name="Result">Result</param>
<rawdata>
typedef struct
{
	RTS_IEC_STRING	*pszIntName;
	RTS_IEC_UDINT	*pResult;
	RTS_IEC_HANDLE	out;
}sysintopenbyname_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>sysintclose_struct</name>
<structname>sysintclose_struct</structname>
<description>SysIntClose Struct</description>
<param name="hInt">Interrupt Handle</param>
<param name="out">Output</param>
<param name="Result">Result</param>
<rawdata>
typedef struct
{
	RTS_IEC_HANDLE	hInt;
	RTS_IEC_UDINT	out;	
}sysintclose_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>sysintenable_struct</name>
<structname>sysintenable_struct</structname>
<description>SysIntEnable Struct</description>
<param name="hInt">Interrupt Handle</param>
<param name="out">Output</param>
<param name="Result">Result</param>
<rawdata>
typedef struct
{
	RTS_IEC_HANDLE	hInt;
	RTS_IEC_UDINT	out;		
}sysintenable_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>sysintdisable_struct</name>
<structname>sysintdisable_struct</structname>
<description>SysIntDisable Struct</description>
<param name="hInt">Interrupt Handle</param>
<param name="out">Output</param>
<rawdata>
typedef struct
{
	RTS_IEC_HANDLE	hInt;
	RTS_IEC_UDINT	out;	
}sysintdisable_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>sysintregister_struct</name>
<structname>sysintregister_struct</structname>
<description>SysIntRegister Struct</description>
<param name="hInt">Interrupt Handle for SysIntRegister</param>
<param name="pHandler">Pointer to Handler for SysIntRegister</param>
<param name="ulAdditionalInfo">Additional Info for SysIntRegister</param>
<param name="out">Output</param>
<rawdata>
typedef struct
{
	RTS_IEC_HANDLE	hInt;
	SYS_INT_INTHANDLER	pHandler;
	RTS_IEC_VOIDPTR	ulAdditionalInfo;
	RTS_IEC_UDINT	out;	
}sysintregister_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>sysintunregister_struct</name>
<structname>sysintunregister_struct</structname>
<description>SysIntUnregister Struct</description>
<param name="hInt">Interrupt Handle for SysIntUnregister</param>
<param name="pHandler">Pointer to Handler for SysIntUnregister</param>
<param name="out">Output for SysIntUnregister</param>
<rawdata>
typedef struct
{
	RTS_IEC_HANDLE		hInt;
	SYS_INT_INTHANDLER	pHandler;
	RTS_RESULT			out;	
}sysintunregister_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>sysintenableall_struct</name>
<structname>sysintenableall_struct</structname>
<description>SysIntEnableAll Struct</description>
<param name="pulParam">Pointer to Params for SysIntEnableAll</param>
<param name="out">Output for SysIntEnableAll</param>
<rawdata>
typedef struct
{
	RTS_IEC_XWORD	*pulParam;
	RTS_IEC_UDINT	out;
}sysintenableall_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>sysintdisableall_struct</name>
<structname>sysintdisableall_struct</structname>
<description>SysIntDisableAll Struct</description>
<param name="pulParam">Pointer to Params for SysIntDisableAll</param>
<param name="out">Output for SysIntDisableAll</param>
<rawdata>
typedef struct
{
	RTS_IEC_XWORD	*pulParam;
	RTS_IEC_UDINT	out;	
}sysintdisableall_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>sysintlevel_struct</name>
<structname>sysintlevel_struct</structname>
<description>SysIntLevel Struct</description>
<param name="out">Output for SysIntLevel</param>
<rawdata>
typedef struct
{
	RTS_IEC_UDINT	out;
}sysintlevel_struct;
</rawdata>
</element>
<element function="1">
<functionname returntype="void" parameters="(sysintregisterinstance_struct *p)">sysintregisterinstance</functionname>
<description>Obsolete Functions: To be removed!</description>
</element>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(unsigned long ulInterrupt, SYS_INT_DESCRIPTION *pIntDescription, RTS_RESULT *pResult)">SysIntOpen</functionname>
<description>Open a valid interrupt</description>
<param name="ulInterrupt" type="IN" range="[0,VALID_INT_NR,INVALID_INT_NR]">Interrupt number</param>
<param name="pIntDescription" type="IN" range="[0,VALID_INT_DESCR,INVALID_INT_DESCR]">Pointer to optional interrupt description</param>
<param name="pResult" type="OUT">Pointer to result</param>
<errorcode name="RTS_RESULT pResult" type="ERR_OK">Interrupt could be opened, a valid Handle is returned</errorcode>
<errorcode name="RTS_RESULT pResult" type="ERR_FAILED">Interrupt could not be opened, an invalid Handle is returned</errorcode>
<errorcode name="RTS_RESULT pResult" type="ERR_PARAMETER">Invalid ulInterrupt Parameter</errorcode>
<result>Handle to interrupt, is RTS_INVALID_HANDLE if error occured, see Errorcodes.</result>
</element>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(char* pszIntName, RTS_RESULT* pResult)">SysIntOpenByName</functionname>
<description>Open a valid interrupt specified by name</description>
<param name="pszIntName" type="IN" range="[0,VALID_INT_NAMR,INVALID_INT_NAME]">Interrupt name defined in the settings component</param>
<errorcode name="RTS_RESULT pResult" type="ERR_OK">Interrupt could be opened, a valid Handle is returned</errorcode>
<errorcode name="RTS_RESULT pResult" type="ERR_FAILED">Interrupt could not be opened, an invalid Handle is returned</errorcode>
<errorcode name="RTS_RESULT pResult" type="ERR_PARAMETER">Parameter wrong, an invalid Handle is returned</errorcode>
<errorcode name="RTS_RESULT pResult" type="ERR_NO_OBJECT">No Interrupt found for given Name</errorcode>
<param name="pResult" type="OUT">Pointer to result</param>
<result>Handle to interrupt</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hInt)">SysIntEnable</functionname>
<description>Function to enable an interrupt</description>
<param name="hInt" type="IN" range="[RTS_INVALID_HANDLE,0,VALID_INT_HANDLE]">Handle to the interrupt</param>
<errorcode name="RTS_RESULT Result" type="ERR_OK">Interrupt could be enabled</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_FAILED">Interrupt could not be enabled</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_NO_OBJECT">No Interrupt found for Parameter</errorcode>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hInt)">SysIntDisable</functionname>
<description>Function to disable an interrupt</description>
<param name="hInt" type="IN" range="[RTS_INVALID_HANDLE,0,VALID_INT_HANDLE]">Handle to the interrupt</param>
<errorcode name="RTS_RESULT Result" type="ERR_OK">Interrupt could be disabled</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_FAILED">Interrupt could not be disabled</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_NO_OBJECT">No Interrupt found for Parameter</errorcode>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hInt, unsigned long ulType, SYS_INT_INTHANDLER pHandler, RTS_UINTPTR ulAdditionalInfo)">SysIntRegister</functionname>
<description>Function to register an interrupt handler</description>
<param name="hInt" type="IN" range="[RTS_INVALID_HANDLE,0,VALID_INT_HANDLE]">Handle to the interrupt</param>
<param name="ulType" type="IN" range="[SYS_INT_NONE,SYS_INT_IEC,SYS_INT_C,INVALID_INT_TYPE]">Type of interrupt handler. See category Interrupt handler type</param>
<param name="pHandler" type="IN" range="[0,VALID_INT_HANDLER,INVALID_INT_HANDLER]">Interrupt handler</param>
<param name="ulAdditionalInfo" type="IN" range="[0,VALID_INT_ADDINFO,INVALID_INT_ADDINFO]">Info value that is transmitted to the interrupt handler</param>
<errorcode name="RTS_RESULT Result" type="ERR_OK">Interrupt Handler could be registered</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_FAILED">Interrupt Handler could not be registered</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_NO_OBJECT">No Interrupt found for Parameter, Wrong Type</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_PARAMETER">pHandler may not be null</errorcode>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hInt, SYS_INT_INTHANDLER pHandler)">SysIntUnregister</functionname>
<description>Function to unregister an interrupt handler</description>
<param name="hInt" type="IN" range="[RTS_INVALID_HANDLE,0,VALID_INT_HANDLE]">Handle to the interrupt</param>
<param name="pHandler" type="IN" range="[0,VALID_INT_HANDLER,INVALID_INT_HANDLER]">Interrupt handler</param>
<errorcode name="RTS_RESULT Result" type="ERR_OK">Interrupt Handler could be unregistered</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_FAILED">Interrupt Handler could not be unregistered</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_NO_OBJECT">No Interrupt found for hInt</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_PARAMETER">pHandler may not be null</errorcode>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_UINTPTR *pulParam)">SysIntEnableAll</functionname>
<description>Function to enable all interrupts</description>
<param name="pulParam" type="IN" range="[NULL,VALID_PARAM,INVALID_PARAM_NONE,INVALID_PARAM_FULL]">Parameter for enabling all interrupts</param>
<parampseudo name="bTimerOccured" type="OUT" range="[TRUE,FALSE]">Specifies, if a timer was able to run, during the lock, or not</parampseudo>
<parampseudo name="bWatchdogOccured" type="OUT" range="[TRUE,FALSE]">Specifies, if the watchdog handler was able to run, during the lock, or not</parampseudo>
<errorcode name="RTS_RESULT Result" type="ERR_OK">Interrupts could be enabled</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_NOTIMPLEMENTED">Function is not supported by the system</errorcode>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_UINTPTR *pulParam)">SysIntDisableAll</functionname>
<description>Function to disable all interrupts</description>
<param name="pulParam" type="INOUT" range="[NULL,VALID_PARAM]">Parameter for disabling all interrupts</param>
<parampseudo name="bTimerOccured" type="OUT" range="[TRUE,FALSE]">Specifies, if a timer was able to run, during the lock, or not</parampseudo>
<parampseudo name="bWatchdogOccured" type="OUT" range="[TRUE,FALSE]">Specifies, if the watchdog handler was able to run, during the lock, or not</parampseudo>
<errorcode name="RTS_RESULT Result" type="ERR_OK">Interrupts could be disabled</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_NOTIMPLEMENTED">Function is not supported by the system</errorcode>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(void)">SysIntLevel</functionname>
<description>Function to check, if we are running actual in an interrupt context</description>
<errorcode name="RTS_RESULT Result" type="ERR_OK">We are still in an interrupt handler</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_FAILED">not in interrupt context</errorcode>
<result>Returns ERR_OK if running in an interrupt handler, ERR_FAILED if not</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hInt)">SysIntClose</functionname>
<description>Close an interrupt</description>
<param name="hInt" type="IN" range="[RTS_INVALID_HANDLE,0,VALID_INT_HANDLE]">Interrupt handle</param>
<errorcode name="RTS_RESULT Result" type="ERR_OK">Interrupt could be closed</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_FAILED">Interrupt could not be closed</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_NO_OBJECT">No Interrupt found for Parameter</errorcode>
<result>error code</result>
</element>
</element>
</component>
<component>
<name>SysInternalLib</name>
<description>
Implements functions used by the compiler like conversion routines,
LREAL arithmetic etc.
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element interface="1" name="SysInternalLibItf">
<interfacename>SysInternalLib</interfacename>
<description>
<p>The SysInternalLib interface is projected to implement all platform dependant routines for:
<ul>
<li>Standard library routines</li>
<li>Datatype conversion</li>
</ul>
This routines are used by CoDeSys for the Iec standard library implementation.</p>

<p>If the define SYSINTERNALLIB_DISABLE_INT_DIVBYZERO_CHECK is set, you can disable checking all int divisions on a zero divisor.</p>
<p>If the define SYSINTERNALLIB_DISABLE_REAL_DIVBYZERO_CHECK is set, you can disable checking all real divisions on a zero divisor.</p>
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element typedefinition="1">
<name>__memcopy_struct</name>
<structname>__memcopy_struct</structname>
/********** Structures *********
<rawdata>
typedef struct
{
	RTS_IEC_VOIDPTR pDest;
	RTS_IEC_VOIDPTR pSrc;
	RTS_IEC_DWORD dwSize;
	RTS_IEC_VOIDPTR pRet;
}__memcopy_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>get_time_struct</name>
<structname>get_time_struct</structname>
<SIL2/>
<category>External IEC interface</category>
<description>Struct for a time output as 32-bit value.</description>
<rawdata>
typedef struct
{
	RTS_IEC_DWORD out;
}get_time_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>get_ltime_struct</name>
<structname>get_ltime_struct</structname>
<SIL2/>
<category>External IEC interface</category>
<description>Struct for a time output as 64-bit value.</description>
<rawdata>
typedef struct
{
	RTS_IEC_LTIME out;
}get_ltime_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>__memset_struct</name>
<structname>__memset_struct</structname>
<category>External IEC interface</category>
<description>Struct for setting memory.</description>
<rawdata>
typedef struct
{
	RTS_IEC_BYTE *pDest;
	RTS_IEC_DINT iValue;
	RTS_IEC_DINT iCount;
	RTS_IEC_BYTE *__MemSet;
} __memset_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>real_cmp_struct</name>
<structname>real_cmp_struct</structname>
<SIL2/>
<category>External IEC interface</category>
<description>Struct to compare two 32-bit real values.</description>
<rawdata>
typedef struct
{
	RTS_IEC_REAL in1;
	RTS_IEC_REAL in2;
	RTS_IEC_SINT out;
}real_cmp_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>real_3op_struct</name>
<structname>real_3op_struct</structname>
<SIL2/>
<category>External IEC interface</category>
<description>Struct for operation with three 32-bit real values.</description>
<rawdata>
typedef struct 
{
	RTS_IEC_REAL in1;
	RTS_IEC_REAL in2;
	RTS_IEC_REAL in3;
	RTS_IEC_REAL out;
}real_3op_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>real_2op_struct</name>
<structname>real_2op_struct</structname>
<SIL2/>
<category>External IEC interface</category>
<description>Struct for operation with two 32-bit real values.</description>
<rawdata>
typedef struct 
{
	RTS_IEC_REAL in1;
	RTS_IEC_REAL in2;
	RTS_IEC_REAL out;
}real_2op_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>real_1op_struct</name>
<structname>real_1op_struct</structname>
<SIL2/>
<category>External IEC interface</category>
<description>Struct for operation with one 32-bit real value.</description>
<rawdata>
typedef struct 
{
	RTS_IEC_REAL in;
	RTS_IEC_REAL out;
}real_1op_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>lreal_cmp_struct</name>
<structname>lreal_cmp_struct</structname>
<SIL2/>
<category>External IEC interface</category>
<description>Struct to compare two 64-bit real values.</description>
<rawdata>
typedef struct 
{
	RTS_IEC_LREAL in1;
	RTS_IEC_LREAL in2;
	RTS_IEC_SINT  out;
}lreal_cmp_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>lreal_3op_struct</name>
<structname>lreal_3op_struct</structname>
<SIL2/>
<category>External IEC interface</category>
<description>Struct for operation with three 64-bit real values.</description>
<rawdata>
typedef struct 
{
	RTS_IEC_LREAL in1;
	RTS_IEC_LREAL in2;
	RTS_IEC_LREAL in3;
	RTS_IEC_LREAL out;
}lreal_3op_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>real_trunc_struct</name>
<structname>real_trunc_struct</structname>
<SIL2/>
<category>External IEC interface</category>
<description>Struct for conversion of a 32-bit real value to a 32-bit integer value.</description>
<rawdata>
typedef struct
{
	RTS_IEC_REAL in;
	RTS_IEC_DINT out;
}real_trunc_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>lreal_trunc_struct</name>
<structname>lreal_trunc_struct</structname>
<SIL2/>
<category>External IEC interface</category>
<description>Struct for conversion of a 64-bit real value to a 32-bit integer value.</description>
<rawdata>
typedef struct
{
	RTS_IEC_LREAL in;
	RTS_IEC_DINT  out;
}lreal_trunc_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>lreal_2op_struct</name>
<structname>lreal_2op_struct</structname>
<SIL2/>
<category>External IEC interface</category>
<description>Struct for operation with two 64-bit real values.</description>
<rawdata>
typedef struct 
{
	RTS_IEC_LREAL in1;
	RTS_IEC_LREAL in2;
	RTS_IEC_LREAL out;
}lreal_2op_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>lreal_1op_struct</name>
<structname>lreal_1op_struct</structname>
<SIL2/>
<category>External IEC interface</category>
<description>Struct for operation with one 64-bit real value.</description>
<rawdata>
typedef struct 
{
	RTS_IEC_LREAL in;
	RTS_IEC_LREAL out;
}lreal_1op_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>lint_cmp_struct</name>
<structname>lint_cmp_struct</structname>
<SIL2/>
<category>External IEC interface</category>
<description>Struct to compare two 64-bit integer values.</description>
<rawdata>
typedef struct 
{
	RTS_IEC_LINT in1;
	RTS_IEC_LINT in2;
	RTS_IEC_SINT out;
}lint_cmp_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>lint_3op_struct</name>
<structname>lint_3op_struct</structname>
<SIL2/>
<category>External IEC interface</category>
<description>Struct for operation with three 64-bit integer values.</description>
<rawdata>
typedef struct 
{
	RTS_IEC_LINT in1;
	RTS_IEC_LINT in2;
	RTS_IEC_LINT in3;
	RTS_IEC_LINT out;
}lint_3op_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>lint_2op_struct</name>
<structname>lint_2op_struct</structname>
<SIL2/>
<category>External IEC interface</category>
<description>Struct for operation with two 64-bit integer values.</description>
<rawdata>
typedef struct 
{
	RTS_IEC_LINT in1;
	RTS_IEC_LINT in2;
	RTS_IEC_LINT out;
}lint_2op_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>lint_1op_struct</name>
<structname>lint_1op_struct</structname>
<SIL2/>
<category>External IEC interface</category>
<description>Struct for operation with one 64-bit integer value.</description>
<rawdata>
typedef struct 
{
	RTS_IEC_LINT in;
	RTS_IEC_LINT out;
}lint_1op_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>ulint_cmp_struct</name>
<structname>ulint_cmp_struct</structname>
<SIL2/>
<category>External IEC interface</category>
<description>Struct to compare two 64-bit unsigned integer values.</description>
<rawdata>
typedef struct 
{
	RTS_IEC_ULINT in1;
	RTS_IEC_ULINT in2;
	RTS_IEC_SINT  out;
}ulint_cmp_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>ulint_3op_struct</name>
<structname>ulint_3op_struct</structname>
<SIL2/>
<category>External IEC interface</category>
<description>Struct for operation with three 64-bit unsigned integer values.</description>
<rawdata>
typedef struct 
{
	RTS_IEC_ULINT in1;
	RTS_IEC_ULINT in2;
	RTS_IEC_ULINT in3;
	RTS_IEC_ULINT out;
}ulint_3op_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>ulint_2op_struct</name>
<structname>ulint_2op_struct</structname>
<SIL2/>
<category>External IEC interface</category>
<description>Struct for operation with two 64-bit unsigned integer values.</description>
<rawdata>
typedef struct 
{
	RTS_IEC_ULINT in1;
	RTS_IEC_ULINT in2;
	RTS_IEC_ULINT out;
}ulint_2op_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>ulint_shift_struct</name>
<structname>ulint_shift_struct</structname>
<SIL2/>
<category>External IEC interface</category>
<description>Struct for shift operations on a 64-bit unsigned integer value.</description>
<rawdata>
typedef struct 
{
	RTS_IEC_ULINT in1;
	RTS_IEC_UINT  in2;
#ifdef RTS_SIXTEENBITBYTES
	RTS_IEC_USINT dummy[3];
#else
	RTS_IEC_USINT dummy[6];
#endif
	RTS_IEC_ULINT out;
}ulint_shift_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>lint_shift_struct</name>
<structname>lint_shift_struct</structname>
<SIL2/>
<category>External IEC interface</category>
<description>Struct for shift operations on a 64-bit integer value.</description>
<rawdata>
typedef struct 
{
	RTS_IEC_LINT  in1;
	RTS_IEC_UINT  in2;
#ifdef RTS_SIXTEENBITBYTES
	RTS_IEC_USINT dummy[3];
#else
	RTS_IEC_USINT dummy[6];
#endif
	RTS_IEC_LINT  out;
}lint_shift_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>ulint_1op_struct</name>
<structname>ulint_1op_struct</structname>
<SIL2/>
<category>External IEC interface</category>
<description>Struct for operation with one 64-bit unsigned integer value.</description>
<rawdata>
typedef struct 
{
	RTS_IEC_ULINT in;
	RTS_IEC_ULINT out;
}ulint_1op_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>dint_1op_struct</name>
<structname>dint_1op_struct</structname>
<SIL2/>
<category>External IEC interface</category>
<description>Struct for operation with one 32-bit integer value.</description>
<rawdata>
typedef struct 
{
	RTS_IEC_DINT in;
	RTS_IEC_DINT out;
}dint_1op_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>dint_2op_struct</name>
<structname>dint_2op_struct</structname>
<SIL2/>
<category>External IEC interface</category>
<description>Struct for operation with two 32-bit integer values.</description>
<rawdata>
typedef struct 
{	RTS_IEC_DINT in1;
	RTS_IEC_DINT in2;
	RTS_IEC_DINT out;
}dint_2op_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>dint_3op_struct</name>
<structname>dint_3op_struct</structname>
<SIL2/>
<category>External IEC interface</category>
<description>Struct for operation with three 32-bit integer values.</description>
<rawdata>
typedef struct 
{
	RTS_IEC_DINT in1;
	RTS_IEC_DINT in2;
	RTS_IEC_DINT in3;
	RTS_IEC_DINT out;
}dint_3op_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>dint_shift_struct</name>
<structname>dint_shift_struct</structname>
<SIL2/>
<category>External IEC interface</category>
<description>Struct for shift operations on a 32-bit integer value.</description>
<rawdata>
typedef struct 
{
	RTS_IEC_DINT in1;
	RTS_IEC_INT	 in2;
#ifndef TRG_C16X
	RTS_IEC_INT	 dummy;
#endif
	RTS_IEC_DINT out;
}dint_shift_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>udint_2op_struct</name>
<structname>udint_2op_struct</structname>
<SIL2/>
<category>External IEC interface</category>
<description>Struct for operation with two 32-bit unsigned integer values.</description>
<rawdata>
typedef struct 
{
	RTS_IEC_UDINT in1;
	RTS_IEC_UDINT in2;
	RTS_IEC_UDINT out;
}udint_2op_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>udint_3op_struct</name>
<structname>udint_3op_struct</structname>
<SIL2/>
<category>External IEC interface</category>
<description>Struct for operation with three 32-bit unsigned integer values.</description>
<rawdata>
typedef struct 
{
	RTS_IEC_UDINT in1;
	RTS_IEC_UDINT in2;
	RTS_IEC_UDINT in3;
	RTS_IEC_UDINT out;
}udint_3op_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>udint_shift_struct</name>
<structname>udint_shift_struct</structname>
<SIL2/>
<category>External IEC interface</category>
<description>Struct for shift operations on a 32-bit unsigned integer value.</description>
<rawdata>
typedef struct 
{
	RTS_IEC_UDINT in1;
	RTS_IEC_INT	  in2;
#ifndef TRG_C16X
	RTS_IEC_INT	  dummy;
#endif
	RTS_IEC_UDINT out;
}udint_shift_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>int64_to_any32_struct</name>
<structname>int64_to_any32_struct</structname>
<SIL2/>
<category>External IEC interface</category>
<description>Struct for conversion of a 64-bit integer value to any 32-bit value.</description>
<rawdata>
typedef struct
{
	RTS_IEC_ULINT in;
	RTS_IEC_UDINT uiType;
	RTS_IEC_UDINT out;	
}int64_to_any32_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>any32_to_int64_struct</name>
<structname>any32_to_int64_struct</structname>
<SIL2/>
<category>External IEC interface</category>
<description>Struct for conversion of any 32-bit value to a 64-bit integer value.</description>
<rawdata>
typedef struct
{
	RTS_IEC_UDINT in;
	RTS_IEC_UDINT uiType;
	RTS_IEC_ULINT out;
}any32_to_int64_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>real32_to_any32_struct</name>
<structname>real32_to_any32_struct</structname>
<SIL2/>
<category>External IEC interface</category>
<description>Struct for conversion of a 32-bit real value to any 32-bit value.</description>
<rawdata>
typedef struct
{
	RTS_IEC_REAL  in;
	RTS_IEC_UDINT uiType;
	RTS_IEC_UDINT out;
}real32_to_any32_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>any32_to_real32_struct</name>
<structname>any32_to_real32_struct</structname>
<SIL2/>
<category>External IEC interface</category>
<description>Struct for conversion of any 32-bit value to a 32-bit real value.</description>
<rawdata>
typedef struct
{
	RTS_IEC_UDINT in;
	RTS_IEC_UDINT uiType;
	RTS_IEC_REAL  out;
}any32_to_real32_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>real32_to_any64_struct</name>
<structname>real32_to_any64_struct</structname>
<SIL2/>
<category>External IEC interface</category>
<description>Struct for conversion of a 32-bit real value to any 64-bit value.</description>
<rawdata>
typedef struct
{
	RTS_IEC_REAL  in;
	RTS_IEC_UDINT uiType;
	RTS_IEC_ULINT out;
}real32_to_any64_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>any64_to_real32_struct</name>
<structname>any64_to_real32_struct</structname>
<SIL2/>
<category>External IEC interface</category>
<description>Struct for conversion of any 64-bit value to a 32-bit real value.</description>
<rawdata>
typedef struct
{
	RTS_IEC_ULINT in;
	RTS_IEC_UDINT uiType;
	RTS_IEC_REAL  out;
}any64_to_real32_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>real64_to_any32_struct</name>
<structname>real64_to_any32_struct</structname>
<SIL2/>
<category>External IEC interface</category>
<description>Struct for conversion of a 64-bit real value to any 32-bit value.</description>
<rawdata>
typedef struct
{
	RTS_IEC_LREAL in;
	RTS_IEC_UDINT uiType;
	RTS_IEC_UDINT out;
}real64_to_any32_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>any32_to_real64_struct</name>
<structname>any32_to_real64_struct</structname>
<SIL2/>
<category>External IEC interface</category>
<description>Struct for conversion of any 32-bit value to a 64-bit real value.</description>
<rawdata>
typedef struct
{
	RTS_IEC_UDINT in;
	RTS_IEC_UDINT uiType;
	RTS_IEC_LREAL out;
}any32_to_real64_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>real64_to_any64_struct</name>
<structname>real64_to_any64_struct</structname>
<SIL2/>
<category>External IEC interface</category>
<description>Struct for conversion of a 64-bit real value to any 64-bit value.</description>
<rawdata>
typedef struct
{
	RTS_IEC_LREAL in;
	RTS_IEC_UDINT uiType;
	RTS_IEC_UDINT dummy;
	RTS_IEC_ULINT out;	
}real64_to_any64_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>any64_to_real64_struct</name>
<structname>any64_to_real64_struct</structname>
<SIL2/>
<category>External IEC interface</category>
<description>Struct for conversion of any 64-bit value to a 64-bit real value.</description>
<rawdata>
typedef struct
{
	RTS_IEC_ULINT in;	
	RTS_IEC_UDINT uiType;
	RTS_IEC_UDINT dummy;
	RTS_IEC_LREAL out;
}any64_to_real64_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>real64_to_real32_struct</name>
<structname>real64_to_real32_struct</structname>
<SIL2/>
<category>External IEC interface</category>
<description>Struct for conversion of a 64-bit real value to a 32-bit real value.</description>
<rawdata>
typedef struct 
{
	RTS_IEC_LREAL in;
	RTS_IEC_REAL  out;
}real64_to_real32_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>real32_to_real64_struct</name>
<structname>real32_to_real64_struct</structname>
<SIL2/>
<category>External IEC interface</category>
<description>Struct for conversion of a 32-bit real value to a 64-bit real value.</description>
<rawdata>
typedef struct 
{
	RTS_IEC_REAL  in;
	RTS_IEC_UDINT dummy;
	RTS_IEC_LREAL out;
}real32_to_real64_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>TypeClass3</name>
<enumname>TypeClass3</enumname>
<SIL2/>
<category>Type class</category>
<description>
Describes the type class correspoding to an <see>IIECType</see> instance.
</description>
<rawdata>
typedef enum 
{
	TYPE3_BOOL,
	TYPE3_BIT,
	TYPE3_BYTE,
	TYPE3_WORD,
	TYPE3_DWORD,
	TYPE3_LWORD,
	TYPE3_SINT,
	TYPE3_INT,
	TYPE3_DINT,
	TYPE3_LINT,
	TYPE3_USINT,
	TYPE3_UINT,
	TYPE3_UDINT,
	TYPE3_ULINT,
	TYPE3_REAL,
	TYPE3_LREAL,
	TYPE3_STRING,
	TYPE3_WSTRING,
	TYPE3_TIME,
	TYPE3_DATE,
	TYPE3_DATEANDTIME,
	TYPE3_TIMEOFDAY,
	TYPE3_POINTER,
	TYPE3_REFERENCE,
	TYPE3_SUBRANGE,
	TYPE3_ENUM,
	TYPE3_ARRAY,
	TYPE3_PARAMS,
	TYPE3_USERDEF,
	TYPE3_NONE,
	TYPE3_ANY,		all types
	TYPE3_ANYBIT,	all "bit"-types: bit, byte, word, dword, lword
	TYPE3_ANYDATE,	time, dat, tod, date
	TYPE3_ANYINT, 
	TYPE3_ANYNUM, 
	TYPE3_ANYREAL,
	TYPE3_LAZY,
	TYPE3_LTIME,
	TYPE3_BITCONST,
	TYPE3_MAX_TYPE 
} TypeClass3;
</rawdata>
</element>
<element function="1">
<functionname returntype="void" parameters="(__memcopy_struct* p)">__memcopy</functionname>
/********** Functions *********
</element>
<element function="1">
<functionname returntype="void" parameters="(real_cmp_struct* p)">real32__eq</functionname>
<description>This function determines if two operands equal. The inputs are 32-bit real values.</description>
<param name="p" type="IN" range="[VALID_REAL_CMP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_REAL]">Input 1</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_REAL]">Input 2</parampseudo>
<parampseudo name="out" type="OUT">1 if the input values are equal, 0 if they are not equal. The result is a 8-bit short integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(real_cmp_struct* p)">real32__ne</functionname>
<description>This function determines if two operands are not equal. The inputs are 32-bit real values.</description>
<param name="p" type="IN" range="[VALID_REAL_CMP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_REAL]">Input 1</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_REAL]">Input 2</parampseudo>
<parampseudo name="out" type="OUT">1 if the input values are not equal, 0 if they are equal. The result is a 8-bit short integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(real_cmp_struct* p)">real32__lt</functionname>
<description>This function determines if an operand is lower than another. The inputs are 32-bit real values.</description>
<param name="p" type="IN" range="[VALID_REAL_CMP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_REAL]">Input 1</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_REAL]">Input 2</parampseudo>
<parampseudo name="out" type="OUT">1 if in1 is lower than in2, 0 if in1 is not lower than in2. The result is a 8-bit short integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(real_cmp_struct* p)">real32__le</functionname>
<description>This function determines if an operand is lower or equal than another. The inputs are 32-bit real values.</description>
<param name="p" type="IN" range="[VALID_REAL_CMP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_REAL]">Input 1</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_REAL]">Input 2</parampseudo>
<parampseudo name="out" type="OUT">1 if in1 is lower or equal than in2, 0 if in1 is not lower or equal than in2. The result is a 8-bit short integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(real_cmp_struct* p)">real32__gt</functionname>
<description>This function determines if an operand is greater than another. The inputs are 32-bit real values.</description>
<param name="p" type="IN" range="[VALID_REAL_CMP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_REAL]">Input 1</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_REAL]">Input 2</parampseudo>
<parampseudo name="out" type="OUT">1 if in1 is greater than in2, 0 if in1 is not greater than in2. The result is a 8-bit short integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(real_cmp_struct* p)">real32__ge</functionname>
<description>This function determines if an operand is greater or equal than another. The inputs are 32-bit real values.</description>
<param name="p" type="IN" range="[VALID_REAL_CMP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_REAL]">Input 1</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_REAL]">Input 2</parampseudo>
<parampseudo name="out" type="OUT">1 if in1 is greater or equal than in2, 0 if in1 is not greater or equal than in2. The result is a 8-bit short integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(real_2op_struct* p)">real32__add</functionname>
<description>This function makes an addition of two 32-bit real values.</description>
<param name="p" type="IN" range="[VALID_REAL_2OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_REAL]">First summand</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_REAL]">Second summand</parampseudo>
<parampseudo name="bNegInfinity" type="OUT">The return value is -infinity</parampseudo>
<parampseudo name="bInfinity" type="OUT">The return value is infinity</parampseudo>
<parampseudo name="out" type="OUT">Sum of the two input values as 32-bit real value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(real_2op_struct* p)">real32__sub</functionname>
<description>This function makes a subtraction of one variable from another one. The inputs are 32-bit real values.</description>
<param name="p" type="IN" range="[VALID_REAL_2OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_REAL]">Minuend</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_REAL]">Subtrahend</parampseudo>
<parampseudo name="bNegInfinity" type="OUT">The return value is -infinity</parampseudo>
<parampseudo name="bInfinity" type="OUT">The return value is infinity</parampseudo>
<parampseudo name="out" type="OUT">Difference of the two input values as 32-bit real value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(real_2op_struct* p)">real32__mul</functionname>
<description>This function makes a multiplication of two variables. The inputs are 32-bit real values.</description>
<param name="p" type="IN" range="[VALID_REAL_2OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_REAL]">First factor</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_REAL]">Second factor</parampseudo>
<parampseudo name="bNegInfinity" type="OUT">The return value is -infinity</parampseudo>
<parampseudo name="bInfinity" type="OUT">The return value is infinity</parampseudo>
<parampseudo name="out" type="OUT">Product of the two input values as 32-bit real value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(real_2op_struct* p)">real32__div</functionname>
<description>
<p>This function makes a division of two variables. The inputs are 32-bit real values.</p>
<p>The behaviour for divisor = 0.0 might be platform dependent.</p>
</description>
<param name="p" type="IN" range="[VALID_REAL_2OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_REAL]">Dividend</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_REAL]">Divisor</parampseudo>
<parampseudo name="bException" type="OUT">Exception thrown</parampseudo>
<parampseudo name="out" type="OUT">Quotient of the two input values as 32-bit real value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(real_2op_struct* p)">real32__min</functionname>
<description>This function builds the minimum of two variables. The inputs are 32-bit real values.</description>
<param name="p" type="IN" range="[VALID_REAL_2OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_REAL]">Input 1</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_REAL]">Input 2</parampseudo>
<parampseudo name="out" type="OUT">The lesser of the two values as 32-bit real value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(real_2op_struct* p)">real32__max</functionname>
<description>This function builds the maximum of two variables. The inputs are 32-bit real values.</description>
<param name="p" type="IN" range="[VALID_REAL_2OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_REAL]">Input 1</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_REAL]">Input 2</parampseudo>
<parampseudo name="out" type="OUT">The greater of the two values as 32-bit real value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(real_3op_struct* p)">real32__limit</functionname>
<description>This function limits an input value to a lower and an upper bound. The inputs are 32-bit real values.</description>
<param name="p" type="IN" range="[VALID_REAL_3OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_REAL]">Lower bound</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_REAL]">Input value</parampseudo>
<parampseudo name="in3" type="IN" range="[RTS_RANGE_OF_RTS_IEC_REAL]">Upper bound</parampseudo>
<parampseudo name="out" type="OUT">in2 if in2 is in the range between in1 and in3, in1 if in2 is lower than in1, in3 if in2 is greater than in3. The result is a 32-bit real value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(real_trunc_struct* p)">real32__trunc</functionname>
<description>This function converts a 32-bit real value to a 32-bit integer value.</description>
<param name="p" type="IN" range="[VALID_REAL_TRUNC_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in" type="IN" range="[RTS_RANGE_OF_RTS_IEC_REAL]">Input</parampseudo>
<parampseudo name="out" type="OUT">The whole number portion of the input as 32-bit integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(real_1op_struct* p)">real32__tan</functionname>
<description>
<p>This function calculates the tangent of a 32-bit real value.</p>
<p>The behaviour for input values that are multiples of PI_HALF might be platform dependent.</p>
</description>
<param name="p" type="IN" range="[VALID_REAL_1OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in" type="IN" range="[(RTS_IEC_REAL)-PI_HALF,(RTS_IEC_REAL)-PI_HALF+MIN_DELTA..(RTS_IEC_REAL)0,(RTS_IEC_REAL)0..(RTS_IEC_REAL)PI_HALF-MIN_DELTA,(RTS_IEC_REAL)PI_HALF]">Input</parampseudo>
<parampseudo name="out" type="OUT">The tangent of the input as 32-bit real value or NaN.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(real_1op_struct* p)">real32__sin</functionname>
<description>This function calculates the sine of a 32-bit real value.</description>
<param name="p" type="IN" range="[VALID_REAL_1OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in" type="IN" range="[(RTS_IEC_REAL)-PI,(RTS_IEC_REAL)-PI_HALF,0,(RTS_IEC_REAL)PI_HALF,(RTS_IEC_REAL)PI]">Input</parampseudo>
<parampseudo name="out" type="OUT">The sine of the input as 32-bit real value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(real_1op_struct* p)">real32__cos</functionname>
<description>This function calculates the cosine of a 32-bit real value.</description>
<param name="p" type="IN" range="[VALID_REAL_1OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in" type="IN" range="[(RTS_IEC_REAL)-PI,(RTS_IEC_REAL)-PI_HALF,0,(RTS_IEC_REAL)PI_HALF,(RTS_IEC_REAL)PI]">Input</parampseudo>
<parampseudo name="out" type="OUT">The cosine of the input as 32-bit real value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(real_1op_struct* p)">real32__atan</functionname>
<description>This function calculates the arc tangent (inverse function of tangent) of a 32-bit real value.</description>
<param name="p" type="IN" range="[VALID_REAL_1OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in" type="IN" range="[RTS_RANGE_OF_RTS_IEC_REAL]">Input</parampseudo>
<parampseudo name="out" type="OUT">The arc tangent of the input as 32-bit real value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(real_1op_struct* p)">real32__asin</functionname>
<description>
<p>This function calculates the arc sine (inverse function of sine) of a 32-bit real value.</p>
<p>The behaviour for input values &lt; -1.0 and &gt; 1.0 might be platform dependent.</p>
</description>
<param name="p" type="IN" range="[VALID_REAL_1OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in" type="IN" range="[(RTS_IEC_REAL)-1.01,(RTS_IEC_REAL)-1.0..(RTS_IEC_REAL)1.0,(RTS_IEC_REAL)1.01]">Input</parampseudo>
<parampseudo name="out" type="OUT">The arc sine of the input as 32-bit real value or NaN.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(real_1op_struct* p)">real32__acos</functionname>
<description>
<p>This function calculates the arc cosine (inverse function of cosine) of a 32-bit real value.</p>
<p>The behaviour for input values &lt; -1.0 and &gt; 1.0 might be platform dependent.</p>
</description>
<param name="p" type="IN" range="[VALID_REAL_1OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in" type="IN" range="[(RTS_IEC_REAL)-1.01,(RTS_IEC_REAL)-1.0..(RTS_IEC_REAL)1.0,(RTS_IEC_REAL)1.01]">Input</parampseudo>
<parampseudo name="out" type="OUT">The arc cosine of the input as 32-bit real value or NaN.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(real_1op_struct* p)">real32__ln</functionname>
<description>
<p>This function calculates the natural logarithm of a 32-bit real value.</p>
<p>The behaviour for input values &lt;= 0.0 might be platform dependent.</p>
</description>
<param name="p" type="IN" range="[VALID_REAL_1OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in" type="IN" range="[(RTS_IEC_REAL)0.0,(RTS_IEC_REAL)0.01..RTS_IEC_REAL_MAX]">Input</parampseudo>
<parampseudo name="bNegInfinity" type="OUT">The return value is -infinity</parampseudo>
<parampseudo name="out" type="OUT">The natural logarithm of the input as 32-bit real value or NaN.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(real_1op_struct* p)">real32__log</functionname>
<description>
<p>This function calculates the logarithm in Base 10 of a 32-bit real value.</p>
<p>The behaviour for input values &lt;= 0.0 might be platform dependent.</p>
</description>
<param name="p" type="IN" range="[VALID_REAL_1OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in" type="IN" range="[(RTS_IEC_REAL)0.0,(RTS_IEC_REAL)0.01..RTS_IEC_REAL_MAX]">Input</parampseudo>
<parampseudo name="bNegInfinity" type="OUT">The return value is -infinity</parampseudo>
<parampseudo name="out" type="OUT">The logarithm in Base 10 of the input as 32-bit real value or NaN.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(real_1op_struct* p)">real32__exp</functionname>
<description>This function calculates the exponential function of a 32-bit real value.</description>
<param name="p" type="IN" range="[VALID_REAL_1OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in" type="IN" range="[RTS_RANGE_OF_RTS_IEC_REAL]">Input</parampseudo>
<parampseudo name="bInfinity" type="OUT">The return value is infinity</parampseudo>
<parampseudo name="out" type="OUT">The exponential function of the input as 32-bit real value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(real_1op_struct* p)">real32__sqrt</functionname>
<description>
<p>This function calculates the square root of a 32-bit real value.</p>
<p>The behaviour for input values &lt; 0.0 might be platform dependent.</p>
</description>
<param name="p" type="IN" range="[VALID_REAL_1OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in" type="IN" range="[(RTS_IEC_REAL)-0.01,(RTS_IEC_REAL)0.0..RTS_IEC_REAL_MAX]">Input</parampseudo>
<parampseudo name="out" type="OUT">The square root of the input as 32-bit real value or NaN.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(real_1op_struct* p)">real32__abs</functionname>
<description>This function calculates the absolute value of a 32-bit real value.</description>
<param name="p" type="IN" range="[VALID_REAL_1OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in" type="IN" range="[RTS_RANGE_OF_RTS_IEC_REAL]">Input</parampseudo>
<parampseudo name="out" type="OUT">The absolute value of the input as 32-bit real value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(real_2op_struct* p)">real32__expt</functionname>
<description>
<p>This function calculates the exponation of a variable with another variable.</p>
<p>The behaviour for input values in1 = 0.0 and in2 &lt; 0.0 might be platform dependent.</p>
<p>The inputs are 32-bit real values.</p>
</description>
<param name="p" type="IN" range="[VALID_REAL_2OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_REAL]">Base</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_REAL]">Exponent</parampseudo>
<parampseudo name="bInfinity" type="OUT">The return value is infinity</parampseudo>
<parampseudo name="out" type="OUT">The exponation of in1 with in2 as 32-bit real value or NaN.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(lreal_cmp_struct* p)">real64__eq</functionname>
<description>This function determines if two operands equal. The inputs are 64-bit real values.</description>
<param name="p" type="IN" range="[VALID_LREAL_CMP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LREAL]">Input 1</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LREAL]">Input 2</parampseudo>
<parampseudo name="out" type="OUT">1 if the input values are equal, 0 if they are not equal. The result is a 8-bit short integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(lreal_cmp_struct* p)">real64__ne</functionname>
<description>This function determines if two operands are not equal. The inputs are 64-bit real values.</description>
<param name="p" type="IN" range="[VALID_LREAL_CMP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LREAL]">Input 1</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LREAL]">Input 2</parampseudo>
<parampseudo name="out" type="OUT">1 if the input values are not equal, 0 if they are equal. The result is a 8-bit short integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(lreal_cmp_struct* p)">real64__lt</functionname>
<description>This function determines if an operand is lower than another. The inputs are 64-bit real values.</description>
<param name="p" type="IN" range="[VALID_LREAL_CMP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LREAL]">Input 1</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LREAL]">Input 2</parampseudo>
<parampseudo name="out" type="OUT">1 if in1 is lower than in2, 0 if in1 is not lower than in2. The result is a 8-bit short integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(lreal_cmp_struct* p)">real64__le</functionname>
<description>This function determines if an operand is lower or equal than another. The inputs are 64-bit real values.</description>
<param name="p" type="IN" range="[VALID_LREAL_CMP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LREAL]">Input 1</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LREAL]">Input 2</parampseudo>
<parampseudo name="out" type="OUT">1 if in1 is lower or equal than in2, 0 if in1 is not lower or equal than in2. The result is a 8-bit short integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(lreal_cmp_struct* p)">real64__gt</functionname>
<description>This function determines if an operand is greater than another. The inputs are 64-bit real values.</description>
<param name="p" type="IN" range="[VALID_LREAL_CMP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LREAL]">Input 1</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LREAL]">Input 2</parampseudo>
<parampseudo name="out" type="OUT">1 if in1 is greater than in2, 0 if in1 is not greater than in2. The result is a 8-bit short integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(lreal_cmp_struct* p)">real64__ge</functionname>
<description>This function determines if an operand is greater or equal than another. The inputs are 64-bit real values.</description>
<param name="p" type="IN" range="[VALID_LREAL_CMP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LREAL]">Input 1</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LREAL]">Input 2</parampseudo>
<parampseudo name="out" type="OUT">1 if in1 is greater or equal than in2, 0 if in1 is not greater or equal than in2. The result is a 8-bit short integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(lreal_2op_struct* p)">real64__add</functionname>
<description>This function makes an addition of two 64-bit real values.</description>
<param name="p" type="IN" range="[VALID_LREAL_2OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LREAL]">First summand</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LREAL]">Second summand</parampseudo>
<parampseudo name="bNegInfinity" type="OUT">The return value is -infinity</parampseudo>
<parampseudo name="bInfinity" type="OUT">The return value is infinity</parampseudo>
<parampseudo name="out" type="OUT">Sum of the two input values as 64-bit real value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(lreal_2op_struct* p)">real64__sub</functionname>
<description>This function makes a subtraction of one variable from another one. The inputs are 64-bit real values.</description>
<param name="p" type="IN" range="[VALID_LREAL_2OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LREAL]">Minuend</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LREAL]">Subtrahend</parampseudo>
<parampseudo name="bNegInfinity" type="OUT">The return value is -infinity</parampseudo>
<parampseudo name="bInfinity" type="OUT">The return value is infinity</parampseudo>
<parampseudo name="out" type="OUT">Difference of the two input values as 64-bit real value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(lreal_2op_struct* p)">real64__mul</functionname>
<description>This function makes a multiplication of two variables. The inputs are 64-bit real values.</description>
<param name="p" type="IN" range="[VALID_LREAL_2OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LREAL]">First factor</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LREAL]">Second factor</parampseudo>
<parampseudo name="bNegInfinity" type="OUT">The return value is -infinity</parampseudo>
<parampseudo name="bInfinity" type="OUT">The return value is infinity</parampseudo>
<parampseudo name="out" type="OUT">Product of the two input values as 64-bit real value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(lreal_2op_struct* p)">real64__div</functionname>
<description>
<p>This function makes a division of two variables. The inputs are 64-bit real values.</p>
<p>The behaviour for divisor = 0.0 might be platform dependent.</p>
</description>
<param name="p" type="IN" range="[VALID_LREAL_2OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LREAL]">Dividend</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LREAL]">Divisor</parampseudo>
<parampseudo name="bException" type="OUT">Exception thrown</parampseudo>
<parampseudo name="out" type="OUT">Quotient of the two input values as 64-bit real value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(lreal_2op_struct* p)">real64__min</functionname>
<description>This function builds the minimum of two variables. The inputs are 64-bit real values.</description>
<param name="p" type="IN" range="[VALID_LREAL_2OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LREAL]">Input 1</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LREAL]">Input 2</parampseudo>
<parampseudo name="out" type="OUT">The lesser of the two values as 64-bit real value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(lreal_2op_struct* p)">real64__max</functionname>
<description>This function builds the maximum of two variables. The inputs are 64-bit real values.</description>
<param name="p" type="IN" range="[VALID_LREAL_2OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LREAL]">Input 1</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LREAL]">Input 2</parampseudo>
<parampseudo name="out" type="OUT">The greater of the two values as 64-bit real value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(lreal_3op_struct* p)">real64__limit</functionname>
<description>This function limits an input value to a lower and an upper bound. The inputs are 64-bit real values.</description>
<param name="p" type="IN" range="[VALID_LREAL_3OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LREAL]">Lower bound</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LREAL]">Input value</parampseudo>
<parampseudo name="in3" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LREAL]">Upper bound</parampseudo>
<parampseudo name="out" type="OUT">in2 if in2 is in the range between in1 and in3, in1 if in2 is lower than in1, in3 if in2 is greater than in3. The result is a 64-bit real value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(lreal_trunc_struct* p)">real64__trunc</functionname>
<description>This function converts a 64-bit real value to a 64-bit integer value.</description>
<param name="p" type="IN" range="[VALID_LREAL_TRUNC_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LREAL]">Input</parampseudo>
<parampseudo name="out" type="OUT">The whole number portion of the input as 64-bit integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(lreal_1op_struct* p)">real64__tan</functionname>
<description>
<p>This function calculates the tangent of a 64-bit real value.</p>
<p>The behaviour for input values that are multiples of PI_HALF might be platform dependent.</p>
</description>
<param name="p" type="IN" range="[VALID_LREAL_1OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in" type="IN" range="[(RTS_IEC_LREAL)-PI_HALF,(RTS_IEC_LREAL)-PI_HALF+MIN_DELTA..(RTS_IEC_LREAL)0,(RTS_IEC_LREAL)0..(RTS_IEC_LREAL)PI_HALF-MIN_DELTA,(RTS_IEC_LREAL)PI_HALF]">Input</parampseudo>
<parampseudo name="out" type="OUT">The tangent of the input as 64-bit real value or NaN.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(lreal_1op_struct* p)">real64__sin</functionname>
<description>This function calculates the sine of a 64-bit real value.</description>
<param name="p" type="IN" range="[VALID_LREAL_1OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in" type="IN" range="[(RTS_IEC_LREAL)-PI,(RTS_IEC_LREAL)-PI_HALF,0,(RTS_IEC_LREAL)PI_HALF,(RTS_IEC_LREAL)PI]">Input</parampseudo>
<parampseudo name="out" type="OUT">The sine of the input as 64-bit real value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(lreal_1op_struct* p)">real64__cos</functionname>
<description>This function calculates the cosine of a 64-bit real value.</description>
<param name="p" type="IN" range="[VALID_LREAL_1OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in" type="IN" range="[(RTS_IEC_LREAL)-PI,(RTS_IEC_LREAL)-PI_HALF,0,(RTS_IEC_LREAL)PI_HALF,(RTS_IEC_LREAL)PI]">Input</parampseudo>
<parampseudo name="out" type="OUT">The cosine of the input as 64-bit real value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(lreal_1op_struct* p)">real64__atan</functionname>
<description>This function calculates the arc tangent (inverse function of tangent) of a 64-bit real value.</description>
<param name="p" type="IN" range="[VALID_LREAL_1OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LREAL]">Input</parampseudo>
<parampseudo name="out" type="OUT">The arc tangent of the input as 64-bit real value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(lreal_1op_struct* p)">real64__asin</functionname>
<description>
<p>This function calculates the arc sine (inverse function of sine) of a 64-bit real value.</p>
<p>The behaviour for input values &lt; -1.0 and &gt; 1.0 might be platform dependent.</p>
</description>
<param name="p" type="IN" range="[VALID_LREAL_1OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in" type="IN" range="[(RTS_IEC_LREAL)-1.01,(RTS_IEC_LREAL)-1.0..(RTS_IEC_LREAL)1.0,(RTS_IEC_LREAL)1.01]">Input</parampseudo>
<parampseudo name="out" type="OUT">The arc sine of the input as 64-bit real value or NaN.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(lreal_1op_struct* p)">real64__acos</functionname>
<description>
<p>This function calculates the arc cosine (inverse function of cosine) of a 64-bit real value.</p>
<p>The behaviour for input values &lt; -1.0 and &gt; 1.0 might be platform dependent.</p>
</description>
<param name="p" type="IN" range="[VALID_LREAL_1OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in" type="IN" range="[(RTS_IEC_LREAL)-1.01,(RTS_IEC_LREAL)-1.0..(RTS_IEC_LREAL)1.0,(RTS_IEC_LREAL)1.01]">Input</parampseudo>
<parampseudo name="out" type="OUT">The arc cosine of the input as 64-bit real value or NaN.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(lreal_1op_struct* p)">real64__ln</functionname>
<description>
<p>This function calculates the natural logarithm of a 64-bit real value.</p>
<p>The behaviour for input values &lt;= 0.0 might be platform dependent.</p>
</description>
<param name="p" type="IN" range="[VALID_LREAL_1OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in" type="IN" range="[0.0,0.01..RTS_IEC_LREAL_MAX]">Input</parampseudo>
<parampseudo name="bNegInfinity" type="OUT">The return value is -infinity</parampseudo>
<parampseudo name="out" type="OUT">The natural logarithm of the input as 64-bit real value or NaN.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(lreal_1op_struct* p)">real64__log</functionname>
<description>
<p>This function calculates the logarithm in Base 10 of a 64-bit real value.</p>
<p>The behaviour for input values &lt;= 0.0 might be platform dependent.</p>
</description>
<param name="p" type="IN" range="[VALID_LREAL_1OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in" type="IN" range="[(RTS_IEC_LREAL)0.0,(RTS_IEC_LREAL)0.01..RTS_IEC_LREAL_MAX]">Input</parampseudo>
<parampseudo name="bNegInfinity" type="OUT">The return value is -infinity</parampseudo>
<parampseudo name="out" type="OUT">The logarithm in Base 10 of the input as 64-bit real value or NaN.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(lreal_1op_struct* p)">real64__exp</functionname>
<description>This function calculates the exponential function of a 64-bit real value.</description>
<param name="p" type="IN" range="[VALID_LREAL_1OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LREAL]">Input</parampseudo>
<parampseudo name="bInfinity" type="OUT">The return value is infinity</parampseudo>
<parampseudo name="out" type="OUT">The exponential function of the input as 64-bit real value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(lreal_1op_struct* p)">real64__sqrt</functionname>
<description>
<p>This function calculates the square root of a 64-bit real value.</p>
<p>The behaviour for input values &lt; 0.0 might be platform dependent.</p>
</description>
<param name="p" type="IN" range="[VALID_LREAL_1OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in" type="IN" range="[(RTS_IEC_LREAL)-0.01,(RTS_IEC_LREAL)0.0..RTS_IEC_LREAL_MAX]">Input</parampseudo>
<parampseudo name="out" type="OUT">The square root of the input as 64-bit real value or NaN.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(lreal_1op_struct* p)">real64__abs</functionname>
<description>This function calculates the absolute value of a 64-bit real value.</description>
<param name="p" type="IN" range="[VALID_LREAL_1OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LREAL]">Input</parampseudo>
<parampseudo name="out" type="OUT">The absolute value of the input as 64-bit real value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(lreal_2op_struct* p)">real64__expt</functionname>
<description>
<p>This function calculates the exponation of a variable with another variable.</p>
<p>The behaviour for input values in1 = 0.0 and in2 &lt; 0.0 might be platform dependent.</p>
<p>The inputs are 64-bit real values.</p>
</description>
<param name="p" type="IN" range="[VALID_LREAL_2OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LREAL]">Base</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LREAL]">Exponent</parampseudo>
<parampseudo name="bInfinity" type="OUT">The return value is infinity</parampseudo>
<parampseudo name="out" type="OUT">The exponation of in1 with in2 as 64-bit real value or NaN.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(lint_2op_struct* p)">int64__add</functionname>
<description>This function makes an addition of two 64-bit integer values.</description>
<param name="p" type="IN" range="[VALID_LINT_2OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LINT]">First summand</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LINT]">Second summand</parampseudo>
<parampseudo name="out" type="OUT">Sum of the two input values as 64-bit integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(lint_2op_struct* p)">int64__sub</functionname>
<description>This function makes a subtraction of one variable from another one. The inputs are 64-bit integer values.</description>
<param name="p" type="IN" range="[VALID_LINT_2OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LINT]">Minuend</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LINT]">Subtrahend</parampseudo>
<parampseudo name="out" type="OUT">Difference of the two input values as 64-bit integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(lint_2op_struct* p)">int64__mul</functionname>
<description>This function makes a multiplication of two variables. The inputs are 64-bit integer values.</description>
<param name="p" type="IN" range="[VALID_LINT_2OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LINT]">First factor</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LINT]">Second factor</parampseudo>
<parampseudo name="out" type="OUT">Product of the two input values as 64-bit integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(lint_2op_struct* p)">int64__div</functionname>
<description>
<p>This function makes a division of two variables. The inputs are 64-bit integer values.</p>
<p>The behaviour for divisor = 0 might be platform dependent.</p>
</description>
<param name="p" type="IN" range="[VALID_LINT_2OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LINT]">Dividend</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LINT]">Divisor</parampseudo>
<parampseudo name="bException" type="OUT">Exception thrown</parampseudo>
<parampseudo name="out" type="OUT">Quotient of the two input values as 64-bit integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(lint_2op_struct* p)">int64__mod</functionname>
<description>This function calculates the remainder of division of one variable by another. The inputs are 64-bit integer values.</description>
<param name="p" type="IN" range="[VALID_LINT_2OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LINT]">Dividend</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LINT]">Divisor</parampseudo>
<parampseudo name="out" type="OUT">Remainder of division of the two input values as 64-bit integer value, or 0 if the divisor is 0.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(lint_1op_struct* p)">int64__abs</functionname>
<description>This function calculates the absolute value of a 64-bit integer value.</description>
<param name="p" type="IN" range="[VALID_LINT_1OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in" type="IN" range="[RTS_IEC_LINT_MIN,RTS_IEC_LINT_MIN+1,0,RTS_IEC_LINT_MAX/2,RTS_IEC_LINT_MAX]">Input</parampseudo>
<parampseudo name="out" type="OUT">The absolute value of the input as 64-bit integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(lint_2op_struct* p)">int64__min</functionname>
<description>This function builds the minimum of two variables. The inputs are 64-bit integer values.</description>
<param name="p" type="IN" range="[VALID_LINT_2OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LINT]">Input 1</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LINT]">Input 2</parampseudo>
<parampseudo name="out" type="OUT">The lesser of the two values as 64-bit integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(lint_2op_struct* p)">int64__max</functionname>
<description>This function builds the maximum of two variables. The inputs are 64-bit integer values.</description>
<param name="p" type="IN" range="[VALID_LINT_2OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LINT]">Input 1</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LINT]">Input 2</parampseudo>
<parampseudo name="out" type="OUT">The greater of the two values as 64-bit integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(lint_3op_struct* p)">int64__limit</functionname>
<description>This function limits an input value to a lower and an upper bound. The inputs are 64-bit integer values.</description>
<param name="p" type="IN" range="[VALID_LINT_3OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LINT]">Lower bound</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LINT]">Input value</parampseudo>
<parampseudo name="in3" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LINT]">Upper bound</parampseudo>
<parampseudo name="out" type="OUT">in2 if in2 is in the range between in1 and in3, in1 if in2 is lower than in1, in3 if in2 is greater than in3. The result is a 64-bit integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(lint_cmp_struct* p)">int64__eq</functionname>
<description>This function determines if two operands equal. The inputs are 64-bit integer values.</description>
<param name="p" type="IN" range="[VALID_LINT_CMP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LINT]">Input 1</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LINT]">Input 2</parampseudo>
<parampseudo name="out" type="OUT">1 if the input values are equal, 0 if they are not equal. The result is a 8-bit short integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(lint_cmp_struct* p)">int64__ne</functionname>
<description>This function determines if two operands are not equal. The inputs are 64-bit integer values.</description>
<param name="p" type="IN" range="[VALID_LINT_CMP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LINT]">Input 1</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LINT]">Input 2</parampseudo>
<parampseudo name="out" type="OUT">1 if the input values are not equal, 0 if they are equal. The result is a 8-bit short integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(lint_cmp_struct* p)">int64__lt</functionname>
<description>This function determines if an operand is lower than another. The inputs are 64-bit integer values.</description>
<param name="p" type="IN" range="[VALID_LINT_CMP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LINT]">Input 1</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LINT]">Input 2</parampseudo>
<parampseudo name="out" type="OUT">1 if in1 is lower than in2, 0 if in1 is not lower than in2. The result is a 8-bit short integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(lint_cmp_struct* p)">int64__le</functionname>
<description>This function determines if an operand is lower or equal than another. The inputs are 64-bit integer values.</description>
<param name="p" type="IN" range="[VALID_LINT_CMP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LINT]">Input 1</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LINT]">Input 2</parampseudo>
<parampseudo name="out" type="OUT">1 if in1 is lower or equal than in2, 0 if in1 is not lower or equal than in2. The result is a 8-bit short integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(lint_cmp_struct* p)">int64__gt</functionname>
<description>This function determines if an operand is greater than another. The inputs are 64-bit integer values.</description>
<param name="p" type="IN" range="[VALID_LINT_CMP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LINT]">Input 1</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LINT]">Input 2</parampseudo>
<parampseudo name="out" type="OUT">1 if in1 is greater than in2, 0 if in1 is not greater than in2. The result is a 8-bit short integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(lint_cmp_struct* p)">int64__ge</functionname>
<description>This function determines if an operand is greater or equal than another. The inputs are 64-bit integer values.</description>
<param name="p" type="IN" range="[VALID_LINT_CMP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LINT]">Input 1</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LINT]">Input 2</parampseudo>
<parampseudo name="out" type="OUT">1 if in1 is greater or equal than in2, 0 if in1 is not greater or equal than in2. The result is a 8-bit short integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(lint_shift_struct* p)">int64__shr</functionname>
<description>
<p>This function makes a bitwise right-shift on a 64-bit integer value.</p>
<p>The the newly exposed bits will be filled with the value of the topmost bit, that is 1 for negative and 0 for positive input values.</p>
</description>
<param name="p" type="IN" range="[VALID_LINT_SHIFT_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LINT]">Operand to be shifted to the right</parampseudo>
<parampseudo name="in2" type="IN" range="[0..63,64]">Number of bits, by which the operand gets shifted to the right</parampseudo>
<parampseudo name="out" type="OUT">Bitwise right-shifted 64-bit integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(ulint_2op_struct* p)">uint64__add</functionname>
<description>This function makes an addition of two 64-bit unsigned integer values.</description>
<param name="p" type="IN" range="[VALID_ULINT_2OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_ULINT]">First summand</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_ULINT]">Second summand</parampseudo>
<parampseudo name="out" type="OUT">Sum of the two input values as 64-bit unsigned integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(ulint_2op_struct* p)">uint64__sub</functionname>
<description>This function makes a subtraction of one variable from another one. The inputs are 64-bit unsigned integer values.</description>
<param name="p" type="IN" range="[VALID_ULINT_2OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_ULINT]">Minuend</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_ULINT]">Subtrahend</parampseudo>
<parampseudo name="out" type="OUT">Difference of the two input values as 64-bit unsigned integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(ulint_2op_struct* p)">uint64__mul</functionname>
<description>This function makes a multiplication of two variables. The inputs are 64-bit unsigned integer values.</description>
<param name="p" type="IN" range="[VALID_ULINT_2OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_ULINT]">First factor</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_ULINT]">Second factor</parampseudo>
<parampseudo name="out" type="OUT">Product of the two input values as 64-bit unsigned integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(ulint_2op_struct* p)">uint64__div</functionname>
<description>
<p>This function makes a division of two variables. The inputs are 64-bit unsigned integer values.</p>
<p>The behaviour for divisor = 0 might be platform dependent.</p>
</description>
<param name="p" type="IN" range="[VALID_ULINT_2OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_ULINT]">Dividend</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_ULINT]">Divisor</parampseudo>
<parampseudo name="bException" type="OUT">Exception thrown</parampseudo>
<parampseudo name="out" type="OUT">Quotient of the two input values as 64-bit unsigned integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(ulint_2op_struct* p)">uint64__mod</functionname>
<description>This function calculates the remainder of division of one variable by another. The inputs are 64-bit unsigned integer values.</description>
<param name="p" type="IN" range="[VALID_ULINT_2OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_ULINT]">Dividend</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_ULINT]">Divisor</parampseudo>
<parampseudo name="out" type="OUT">Remainder of division of the two input values as 64-bit unsigned integer value, or 0 if the divisor is 0.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(ulint_2op_struct* p)">uint64__min</functionname>
<description>This function builds the minimum of two variables. The inputs are 64-bit unsigned integer values.</description>
<param name="p" type="IN" range="[VALID_ULINT_2OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_ULINT]">Input 1</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_ULINT]">Input 2</parampseudo>
<parampseudo name="out" type="OUT">The lesser of the two values as 64-bit unsigned integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(ulint_2op_struct* p)">uint64__max</functionname>
<description>This function builds the maximum of two variables. The inputs are 64-bit unsigned integer values.</description>
<param name="p" type="IN" range="[VALID_ULINT_2OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_ULINT]">Input 1</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_ULINT]">Input 2</parampseudo>
<parampseudo name="out" type="OUT">The greater of the two values as 64-bit unsigned integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(ulint_3op_struct* p)">uint64__limit</functionname>
<description>This function limits an input value to a lower and an upper bound. The inputs are 64-bit unsigned integer values.</description>
<param name="p" type="IN" range="[VALID_ULINT_3OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_ULINT]">Lower bound</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_ULINT]">Input value</parampseudo>
<parampseudo name="in3" type="IN" range="[RTS_RANGE_OF_RTS_IEC_ULINT]">Upper bound</parampseudo>
<parampseudo name="out" type="OUT">in2 if in2 is in the range between in1 and in3, in1 if in2 is lower than in1, in3 if in2 is greater than in3. The result is a 64-bit unsigned integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(ulint_shift_struct* p)">uint64__ror</functionname>
<description>
<p>This function makes a bitwise rotation to the right of a 64-bit unsigned integer value.</p>
<p>The input operand will be shifted one bit position to the right n times while the bit that is furthest to the left will be reinserted from the left.</p>
</description>
<param name="p" type="IN" range="[VALID_ULINT_SHIFT_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_ULINT]">Operand to be rotated to the right</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_UINT]">Number n of bits, by which the operand gets rotated to the right</parampseudo>
<parampseudo name="out" type="OUT">Bitwise right rotated 64-bit unsigned integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(ulint_shift_struct* p)">uint64__rol</functionname>
<description>
<p>This function makes a bitwise rotation to the left of a 64-bit unsigned integer value.</p>
<p>The input operand will be shifted one bit position to the left n times while the bit that is furthest to the right will be reinserted from the right.</p>
</description>
<param name="p" type="IN" range="[VALID_ULINT_SHIFT_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_ULINT]">Operand to be rotated to the left</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_UINT]">Number n of bits, by which the operand gets rotated to the left</parampseudo>
<parampseudo name="out" type="OUT">Bitwise left rotated 64-bit unsigned integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(ulint_shift_struct* p)">uint64__shl</functionname>
<description>
<p>This function makes a bitwise left-shift on a 64-bit unsigned integer value.</p>
<p>The the newly exposed bits will be filled with 0.</p>
</description>
<param name="p" type="IN" range="[VALID_ULINT_SHIFT_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_ULINT]">Operand to be shifted to the left</parampseudo>
<parampseudo name="in2" type="IN" range="[0..63,64]">Number of bits, by which the operand gets shifted to the left</parampseudo>
<parampseudo name="out" type="OUT">Bitwise left-shifted 64-bit unsigned integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(ulint_shift_struct* p)">uint64__shr</functionname>
<description>
<p>This function makes a bitwise right-shift on a 64-bit unsigned integer value.</p>
<p>The the newly exposed bits will be filled with 0.</p>
</description>
<param name="p" type="IN" range="[VALID_ULINT_SHIFT_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_ULINT]">Operand to be shifted to the right</parampseudo>
<parampseudo name="in2" type="IN" range="[0..63,64]">Number of bits, by which the operand gets shifted to the right</parampseudo>
<parampseudo name="out" type="OUT">Bitwise right-shifted 64-bit unsigned integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(ulint_2op_struct* p)">uint64__and</functionname>
<description>
<p>This function makes a bitwise AND of two 64-bit unsigned integer values.</p>
<p>If the input bits each are 1, then the resulting bit will be 1, otherwise 0.</p>
</description>
<param name="p" type="IN" range="[VALID_ULINT_2OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_ULINT]">Input 1</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_ULINT]">Input 2</parampseudo>
<parampseudo name="out" type="OUT">Bitwise AND of the two input values as 64-bit unsigned integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(ulint_2op_struct* p)">uint64__or</functionname>
<description>
<p>This function makes a bitwise OR of two 64-bit unsigned integer values.</p>
<p>If at least one of the input bits is 1, the resulting bit will be 1, otherwise 0.</p>
</description>
<param name="p" type="IN" range="[VALID_ULINT_2OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_ULINT]">Input 1</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_ULINT]">Input 2</parampseudo>
<parampseudo name="out" type="OUT">Bitwise OR of the two input values as 64-bit unsigned integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(ulint_2op_struct* p)">uint64__xor</functionname>
<description>
<p>This function makes a bitwise XOR of two 64-bit unsigned integer values.</p>
<p>If only one of the input bits is 1, then the resulting bit will be 1; if both or none are 1, the resulting bit will be 0.</p>
</description>
<param name="p" type="IN" range="[VALID_ULINT_2OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_ULINT]">Input 1</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_ULINT]">Input 2</parampseudo>
<parampseudo name="out" type="OUT">Bitwise XOR of the two input values as 64-bit unsigned integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(ulint_1op_struct* p)">uint64__not</functionname>
<description>
<p>This function makes a bitwise NOT of a 64-bit unsigned integer value.</p>
<p>The resulting bit will be 1, if the corresponding input bit is 0 and vice versa.</p>
</description>
<param name="p" type="IN" range="[VALID_ULINT_1OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in" type="IN" range="[RTS_RANGE_OF_RTS_IEC_ULINT]">Input</parampseudo>
<parampseudo name="out" type="OUT">Bitwise NOT of the input value as 64-bit unsigned integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(ulint_cmp_struct* p)">uint64__eq</functionname>
<description>This function determines if two operands equal. The inputs are 64-bit unsigned integer values.</description>
<param name="p" type="IN" range="[VALID_ULINT_CMP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_ULINT]">Input 1</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_ULINT]">Input 2</parampseudo>
<parampseudo name="out" type="OUT">1 if the input values are equal, 0 if they are not equal. The result is a 8-bit short integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(ulint_cmp_struct* p)">uint64__ne</functionname>
<description>This function determines if two operands are not equal. The inputs are 64-bit unsigned integer values.</description>
<param name="p" type="IN" range="[VALID_ULINT_CMP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_ULINT]">Input 1</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_ULINT]">Input 2</parampseudo>
<parampseudo name="out" type="OUT">1 if the input values are not equal, 0 if they are equal. The result is a 8-bit short integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(ulint_cmp_struct* p)">uint64__lt</functionname>
<description>This function determines if an operand is lower than another. The inputs are 64-bit unsigned integer values.</description>
<param name="p" type="IN" range="[VALID_ULINT_CMP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_ULINT]">Input 1</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_ULINT]">Input 2</parampseudo>
<parampseudo name="out" type="OUT">1 if in1 is lower than in2, 0 if in1 is not lower than in2. The result is a 8-bit short integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(ulint_cmp_struct* p)">uint64__le</functionname>
<description>This function determines if an operand is lower or equal than another. The inputs are 64-bit unsigned integer values.</description>
<param name="p" type="IN" range="[VALID_ULINT_CMP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_ULINT]">Input 1</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_ULINT]">Input 2</parampseudo>
<parampseudo name="out" type="OUT">1 if in1 is lower or equal than in2, 0 if in1 is not lower or equal than in2. The result is a 8-bit short integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(ulint_cmp_struct* p)">uint64__gt</functionname>
<description>This function determines if an operand is greater than another. The inputs are 64-bit unsigned integer values.</description>
<param name="p" type="IN" range="[VALID_ULINT_CMP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_ULINT]">Input 1</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_ULINT]">Input 2</parampseudo>
<parampseudo name="out" type="OUT">1 if in1 is greater than in2, 0 if in1 is not greater than in2. The result is a 8-bit short integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(ulint_cmp_struct* p)">uint64__ge</functionname>
<description>This function determines if an operand is greater or equal than another. The inputs are 64-bit unsigned integer values.</description>
<param name="p" type="IN" range="[VALID_ULINT_CMP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_ULINT]">Input 1</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_ULINT]">Input 2</parampseudo>
<parampseudo name="out" type="OUT">1 if in1 is greater or equal than in2, 0 if in1 is not greater or equal than in2. The result is a 8-bit short integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(dint_2op_struct* p)">int32__mul</functionname>
<description>This function makes a multiplication of two variables. The inputs are 32-bit integer values.</description>
<param name="p" type="IN" range="[VALID_DINT_2OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_DINT]">First factor</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_DINT]">Second factor</parampseudo>
<parampseudo name="out" type="OUT">Product of the two input values as 32-bit integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(udint_2op_struct* p)">uint32__mul</functionname>
<description>This function makes a multiplication of two variables. The inputs are 32-bit unsigned integer values.</description>
<param name="p" type="IN" range="[VALID_UDINT_2OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_UDINT]">First factor</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_UDINT]">Second factor</parampseudo>
<parampseudo name="out" type="OUT">Product of the two input values as 32-bit unsigned integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(dint_2op_struct* p)">int32__div</functionname>
<description>
<p>This function makes a division of two variables. The inputs are 32-bit integer values.</p>
<p>The behaviour for divisor = 0 might be platform dependent.</p>
</description>
<param name="p" type="IN" range="[VALID_DINT_2OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_DINT]">Dividend</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_DINT]">Divisor</parampseudo>
<parampseudo name="bException" type="OUT">Exception thrown</parampseudo>
<parampseudo name="out" type="OUT">Quotient of the two input values as 32-bit integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(dint_2op_struct* p)">int32__mod</functionname>
<description>This function calculates the remainder of division of one variable by another. The inputs are 32-bit integer values.</description>
<param name="p" type="IN" range="[VALID_DINT_2OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_DINT]">Dividend</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_DINT]">Divisor</parampseudo>
<parampseudo name="out" type="OUT">Remainder of division of the two input values as 32-bit integer value, or 0 if the divisor is 0.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(udint_2op_struct* p)">uint32__div</functionname>
<description>
<p>This function makes a division of two variables. The inputs are 32-bit unsigned integer values.</p>
<p>The behaviour for divisor =0 might be platform dependent.</p>
</description>
<param name="p" type="IN" range="[VALID_UDINT_2OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_UDINT]">Dividend</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_UDINT]">Divisor</parampseudo>
<parampseudo name="bException" type="OUT">Exception thrown</parampseudo>
<parampseudo name="out" type="OUT">Quotient of the two input values as 32-bit unsigned integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(udint_2op_struct* p)">uint32__mod</functionname>
<description>This function calculates the remainder of division of one variable by another. The inputs are 32-bit unsigned integer values.</description>
<param name="p" type="IN" range="[VALID_UDINT_2OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_UDINT]">Dividend</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_UDINT]">Divisor</parampseudo>
<parampseudo name="out" type="OUT">Remainder of division of the two input values as 32-bit unsigned integer value, or 0 if the divisor is 0.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(dint_1op_struct* p)">int32__abs</functionname>
<description>This function calculates the absolute value of a 32-bit integer value.</description>
<param name="p" type="IN" range="[VALID_DINT_1OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in" type="IN" range="[RTS_IEC_DINT_MIN,RTS_IEC_DINT_MIN+1,0,RTS_IEC_DINT_MAX/2,RTS_IEC_DINT_MAX]">Input</parampseudo>
<parampseudo name="out" type="OUT">The absolute value of the input as 32-bit integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(udint_3op_struct* p)">uint32__limit</functionname>
<description>This function limits an input value to a lower and an upper bound. The inputs are 32-bit unsigned integer values.</description>
<param name="p" type="IN" range="[VALID_UDINT_3OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_UDINT]">Lower bound</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_UDINT]">Input value</parampseudo>
<parampseudo name="in3" type="IN" range="[RTS_RANGE_OF_RTS_IEC_UDINT]">Upper bound</parampseudo>
<parampseudo name="out" type="OUT">in2 if in2 is in the range between in1 and in3, in1 if in2 is lower than in1, in3 if in2 is greater than in3. The result is a 32-bit unsigned integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(dint_3op_struct* p)">int32__limit</functionname>
<description>This function limits an input value to a lower and an upper bound. The inputs are 32-bit integer values.</description>
<param name="p" type="IN" range="[VALID_DINT_3OP_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_DINT]">Lower bound</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_DINT]">Input value</parampseudo>
<parampseudo name="in3" type="IN" range="[RTS_RANGE_OF_RTS_IEC_DINT]">Upper bound</parampseudo>
<parampseudo name="out" type="OUT">in2 if in2 is in the range between in1 and in3, in1 if in2 is lower than in1, in3 if in2 is greater than in3. The result is a 32-bit integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(udint_shift_struct* p)">uint32__rol</functionname>
<description>
<p>This function makes a bitwise rotation to the left of a 32-bit unsigned integer value.</p>
<p>The input operand will be shifted one bit position to the left n times while the bit that is furthest to the right will be reinserted from the right.</p>
</description>
<param name="p" type="IN" range="[VALID_UDINT_SHIFT_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_UDINT]">Operand to be rotated to the left</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_UINT]">Number n of bits, by which the operand gets rotated to the left</parampseudo>
<parampseudo name="out" type="OUT">Bitwise left rotated 32-bit unsigned integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(udint_shift_struct* p)">uint32__ror</functionname>
<description>
<p>This function makes a bitwise rotation to the right of a 32-bit unsigned integer value.</p>
<p>The input operand will be shifted one bit position to the right n times while the bit that is furthest to the left will be reinserted from the left.</p>
</description>
<param name="p" type="IN" range="[VALID_UDINT_SHIFT_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_UDINT]">Operand to be rotated to the right</parampseudo>
<parampseudo name="in2" type="IN" range="[RTS_RANGE_OF_RTS_IEC_UINT]">Number n of bits, by which the operand gets rotated to the right</parampseudo>
<parampseudo name="out" type="OUT">Bitwise right rotated 32-bit unsigned integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(udint_shift_struct* p)">uint32__shl</functionname>
<description>
<p>This function makes a bitwise left-shift on a 32-bit unsigned integer value.</p>
<p>The the newly exposed bits will be filled with 0.</p>
</description>
<param name="p" type="IN" range="[VALID_UDINT_SHIFT_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_UDINT]">Operand to be shifted to the left</parampseudo>
<parampseudo name="in2" type="IN" range="[0..31,32]">Number of bits, by which the operand gets shifted to the left</parampseudo>
<parampseudo name="out" type="OUT">Bitwise left-shifted 32-bit unsigned integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(udint_shift_struct* p)">uint32__shr</functionname>
<description>
<p>This function makes a bitwise right-shift on a 32-bit unsigned integer value.</p>
<p>The the newly exposed bits will be filled with 0.</p>
</description>
<param name="p" type="IN" range="[VALID_UDINT_SHIFT_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_UDINT]">Operand to be shifted to the right</parampseudo>
<parampseudo name="in2" type="IN" range="[0..31,32]">Number of bits, by which the operand gets shifted to the right</parampseudo>
<parampseudo name="out" type="OUT">Bitwise right-shifted 32-bit unsigned integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(dint_shift_struct* p)">int32__shr</functionname>
<description>
<p>This function makes a bitwise right-shift on a 32-bit integer value.</p>
<p>The the newly exposed bits will be filled with the value of the topmost bit, that is 1 for negative and 0 for positive input values.</p>
</description>
<param name="p" type="IN" range="[VALID_DINT_SHIFT_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in1" type="IN" range="[RTS_RANGE_OF_RTS_IEC_DINT]">Operand to be shifted to the right</parampseudo>
<parampseudo name="in2" type="IN" range="[0..31,32]">Number of bits, by which the operand gets shifted to the right</parampseudo>
<parampseudo name="out" type="OUT">Bitwise right-shifted 32-bit integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(any32_to_int64_struct* p)">any32__to__int64</functionname>
<description>
<p>This function Converts any 32-bit numeric data type to a 64-bit integer value.</p>
<p>Data types with less than 32 bits are allowed but the input value has to be casted to 32 bits before.</p>
<p>Only integer datatypes are allowed.</p>
</description>
<param name="p" type="IN" range="[VALID_ANY32_TO_INT64_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in" type="IN" range="[RTS_RANGE_OF_RTS_IEC_UDINT]">Input data</parampseudo>
<parampseudo name="uiType" type="IN" range="[TYPE3_DINT,TYPE3_UDINT,TYPE3_INVALID]">Type of the input data (see TypeClass3 enumeration)</parampseudo>
<parampseudo name="bException" type="OUT">Exception thrown</parampseudo>
<parampseudo name="out" type="OUT">Input data as 64-bit integer value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(int64_to_any32_struct* p)">int64__to__any32</functionname>
<description>
<p>This function Converts a 64-bit integer value to any 32-bit numeric data type.</p>
<p>Data types with less than 32 bits are allowed but the output value is casted to 32 bits.</p>
<p>Only integer datatypes are allowed.</p>
</description>
<param name="p" type="IN" range="[VALID_INT64_TO_ANY32_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in" type="IN" range="[RTS_RANGE_OF_RTS_IEC_ULINT]">Input value</parampseudo>
<parampseudo name="uiType" type="IN" range="[TYPE3_BOOL,TYPE3_DINT,TYPE3_UDINT,TYPE3_TIMEOFDAY,TYPE3_INVALID]">Type of the output data (see TypeClass3 enumeration)</parampseudo>
<parampseudo name="bException" type="OUT">Exception thrown</parampseudo>
<parampseudo name="out" type="OUT">Input value as 32-bit data type.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(real32_to_any32_struct* p)">real32__to__any32</functionname>
<description>
<p>This function Converts a 32-bit real value to any 32-bit numeric data type.</p>
<p>Data types with less than 32 bits are allowed but the output value is casted to 32 bits.</p>
<p>Only integer datatypes are allowed.</p>
</description>
<param name="p" type="IN" range="[VALID_REAL32_TO_ANY32_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in" type="IN" range="[RTS_RANGE_OF_RTS_IEC_REAL]">Input value</parampseudo>
<parampseudo name="uiType" type="IN" range="[TYPE3_BOOL,TYPE3_DINT,TYPE3_UDINT,TYPE3_TIMEOFDAY,TYPE3_INVALID]">Type of the output data (see TypeClass3 enumeration)</parampseudo>
<parampseudo name="bException" type="OUT">Exception thrown</parampseudo>
<parampseudo name="out" type="OUT">Input value as 32-bit data type.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(any32_to_real32_struct* p)">any32__to__real32</functionname>
<description>
<p>This function Converts any 32-bit numeric data type to a 32-bit real value.</p>
<p>Data types with less than 32 bits are allowed but the input value has to be casted to 32 bits before.</p>
<p>Only integer datatypes are allowed.</p>
</description>
<param name="p" type="IN" range="[VALID_ANY32_TO_REAL32_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in" type="IN" range="[RTS_RANGE_OF_RTS_IEC_UDINT]">Input data</parampseudo>
<parampseudo name="uiType" type="IN" range="[TYPE3_DINT,TYPE3_UDINT,TYPE3_INVALID]">Type of the input data (see TypeClass3 enumeration)</parampseudo>
<parampseudo name="bException" type="OUT">Exception thrown</parampseudo>
<parampseudo name="out" type="OUT">Input data as 32-bit real value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(real32_to_any64_struct* p)">real32__to__any64</functionname>
<description>
<p>This function Converts a 32-bit real value to any 64-bit numeric data type.</p>
<p>Data types with less than 64 bits are allowed but the output value is casted to 64 bits.</p>
</description>
<param name="p" type="IN" range="[VALID_REAL32_TO_ANY64_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in" type="IN" range="[RTS_RANGE_OF_RTS_IEC_REAL]">Input value</parampseudo>
<parampseudo name="uiType" type="IN" range="[TYPE3_LINT,TYPE3_ULINT]">Type of the output data (see TypeClass3 enumeration)</parampseudo>
<parampseudo name="out" type="OUT">Input value as 64-bit data type.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(any64_to_real32_struct* p)">any64__to__real32</functionname>
<description>
<p>This function Converts any 64-bit numeric data type to a 32-bit real value.</p>
<p>Data types with less than 64 bits are allowed but the input value has to be casted to 64 bits before.</p>
<p>Only integer datatypes are allowed.</p>
</description>
<param name="p" type="IN" range="[VALID_ANY64_TO_REAL32_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in" type="IN" range="[RTS_RANGE_OF_RTS_IEC_ULINT]">Input data</parampseudo>
<parampseudo name="uiType" type="IN" range="[TYPE3_LINT,TYPE3_ULINT,TYPE3_INVALID]">Type of the input data (see TypeClass3 enumeration)</parampseudo>
<parampseudo name="bException" type="OUT">Exception thrown</parampseudo>
<parampseudo name="out" type="OUT">Input data as 32-bit real value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(real64_to_any32_struct* p)">real64__to__any32</functionname>
<description>
<p>This function Converts a 64-bit real value to any 32-bit numeric data type.</p>
<p>Data types with less than 32 bits are allowed but the output value is casted to 32 bits.</p>
<p>Only integer datatypes are allowed.</p>
</description>
<param name="p" type="IN" range="[VALID_REAL64_TO_ANY32_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LREAL]">Input value</parampseudo>
<parampseudo name="uiType" type="IN" range="[TYPE3_BOOL,TYPE3_DINT,TYPE3_UDINT,TYPE3_TIMEOFDAY,TYPE3_INVALID]">Type of the output data (see TypeClass3 enumeration)</parampseudo>
<parampseudo name="bException" type="OUT">Exception thrown</parampseudo>
<parampseudo name="out" type="OUT">Input value as 32-bit data type.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(any32_to_real64_struct* p)">any32__to__real64</functionname>
<description>
<p>This function Converts any 32-bit numeric data type to a 64-bit real value.</p>
<p>Data types with less than 32 bits are allowed but the input value has to be casted to 32 bits before.</p>
<p>Only integer datatypes are allowed.</p>
</description>
<param name="p" type="IN" range="[VALID_ANY32_TO_REAL64_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in" type="IN" range="[RTS_RANGE_OF_RTS_IEC_UDINT]">Input data</parampseudo>
<parampseudo name="uiType" type="IN" range="[TYPE3_DINT,TYPE3_UDINT,TYPE3_INVALID]">Type of the input data (see TypeClass3 enumeration)</parampseudo>
<parampseudo name="bException" type="OUT">Exception thrown</parampseudo>
<parampseudo name="out" type="OUT">Input data as 64-bit real value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(real64_to_any64_struct* p)">real64__to__any64</functionname>
<description>
<p>This function Converts a 64-bit real value to any 64-bit numeric data type.</p>
<p>Data types with less than 64 bits are allowed but the output value is casted to 64 bits.</p>
</description>
<param name="p" type="IN" range="[VALID_REAL64_TO_ANY64_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LREAL]">Input value</parampseudo>
<parampseudo name="uiType" type="IN" range="[TYPE3_LINT]">Type of the output data (see TypeClass3 enumeration)</parampseudo>
<parampseudo name="out" type="OUT">Input value as 64-bit data type.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(any64_to_real64_struct* p)">any64__to__real64</functionname>
<description>
<p>This function Converts any 64-bit numeric data type to a 64-bit real value.</p>
<p>Data types with less than 64 bits are allowed but the input value has to be casted to 64 bits before.</p>
<p>Only integer datatypes are allowed.</p>
</description>
<param name="p" type="IN" range="[VALID_ANY64_TO_REAL64_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in" type="IN" range="[RTS_RANGE_OF_RTS_IEC_ULINT]">Input data</parampseudo>
<parampseudo name="uiType" type="IN" range="[TYPE3_LINT,TYPE3_ULINT,TYPE3_INVALID]">Type of the input data (see TypeClass3 enumeration)</parampseudo>
<parampseudo name="bException" type="OUT">Exception thrown</parampseudo>
<parampseudo name="out" type="OUT">Input data as 64-bit real value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(real64_to_real32_struct* p)">real64__to__real32</functionname>
<description>This function Converts a 64-bit real value to a 32-bit real value.</description>
<param name="p" type="IN" range="[VALID_REAL64_TO_REAL32_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in" type="IN" range="[RTS_RANGE_OF_RTS_IEC_LREAL]">Input value</parampseudo>
<parampseudo name="bNegInfinity" type="OUT">The return value is -infinity</parampseudo>
<parampseudo name="bInfinity" type="OUT">The return value is infinity</parampseudo>
<parampseudo name="out" type="OUT">Input value as 32-bit real value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(real32_to_real64_struct* p)">real32__to__real64</functionname>
<description>This function Converts a 32-bit real value to a 64-bit real value.</description>
<param name="p" type="IN" range="[VALID_REAL32_TO_REAL64_STRUCT]">Pointer to the input structure</param>
<parampseudo name="in" type="IN" range="[RTS_RANGE_OF_RTS_IEC_REAL]">Input value</parampseudo>
<parampseudo name="out" type="OUT">Input value as 64-bit real value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(get_time_struct* p)">get__time</functionname>
<description>This function returns a monotonic rising millisecond tick. This tick can be used for timeout and relative time measurements.</description>
<param name="p" type="IN" range="[VALID_GET_TIME_STRUCT]">Pointer to the input structure</param>
<parampseudo name="out" type="OUT">millisecond tick as 32-Bit value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(get_ltime_struct* p)">get__ltime</functionname>
<description>This function returns a monotonic rising nanosecond tick. This tick can be used for very high resolution time measurements.</description>
<param name="p" type="IN" range="[VALID_GET_LTIME_STRUCT]">Pointer to the input structure</param>
<parampseudo name="out" type="OUT">microsecond tick as 64-Bit value.</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(__memset_struct *p)">__memset</functionname>
<description>Fill the buffer with a specified value. Routine is used as external library function for the plc program.</description>
<param name="p" type="IN">Pointer to the input structure</param>
<parampseudo name="out" type="OUT">Value of pDest or 0 if failed</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(systimeunlock_struct *p)">systimeunlock</functionname>
<description>systimeunlock: Use SysTimeLock.libaray</description>
<param name="p" type="IN" range="[VALID_SYSTIMEUNLOCK_STRUCT]">Pointer to the input structure</param>
<parampseudo name="SysTimeUnlock" type="OUT">Always 0</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(systimelock_struct *p)">systimelock</functionname>
<description>systimelock: Use SysTimeLock.libaray</description>
<param name="p" type="IN" range="[VALID_SYSTIMELOCK_STRUCT]">Pointer to the input structure</param>
<parampseudo name="ulTick" type="IN" range="[RTS_RANGE_OF_RTS_IEC_TIME]">Tick</parampseudo>
<parampseudo name="tTimeout" type="IN" range="[RTS_RANGE_OF_RTS_IEC_TIME]">Timeout</parampseudo>
<parampseudo name="SysTimeLock" type="OUT">Always 0</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(systimeunset_struct *p)">systimeunset</functionname>
<description>Function to un-set the actual timestamp for all IEC timers.</description>
<param name="p" type="IN" range="[VALID_SYSTIMEUNSET_STRUCT]">Pointer to the input structure</param>
<parampseudo name="SysTimeUnlock" type="OUT">Always 0</parampseudo>
</element>
<element function="1">
<functionname returntype="void" parameters="(systimeset_struct *p)">systimeset</functionname>
<description>Function to set the actual timestamp for all IEC timers. Differnt to SysTimeLock, the timer continues</description>
<param name="p" type="IN" range="[VALID_SYSTIMESET_STRUCT]">Pointer to the input structure</param>
<parampseudo name="ulTick" type="IN" range="[RTS_RANGE_OF_RTS_IEC_TIME]">Tick</parampseudo>
<parampseudo name="tTimeout" type="IN" range="[RTS_RANGE_OF_RTS_IEC_TIME]">Timeout</parampseudo>
<parampseudo name="SysTimeSet" type="OUT">Always 0</parampseudo>
</element>
<element function="1">
<functionname returntype="unsigned int" parameters="(TypeClass3 tc)">SysGetTypeSize</functionname>
<description>Returns the size in bytes, of the specified IEC data type.</description>
<param name="tc" type="IN" range="[0..TYPE3_MAX_TYPE]">Pointer to the input structure</param>
<result>Size in Bytes of Datatype, or 0 if unspecified</result>
</element>
</element>
</component>
<component>
<name>SysMem</name>
<description>
System component that allows access to memory functions.
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element interface="1" name="SysMemItf">
<interfacename>SysMem</interfacename>
<description>
<p>The SysMem interface is projected to get access to heap memory or special
memory areas for the plc program.</p>
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element define="1">
<name>DA_NONE</name>
<key>0x0000</key>
<category>Area Types</category>
<description>Application Area Type: None</description>
</element>
<element define="1">
<name>DA_DATA</name>
<key>0x0001</key>
<category>Area Types</category>
<description>Application Area Type: Data</description>
</element>
<element define="1">
<name>DA_CONSTANT</name>
<key>0x0002</key>
<category>Area Types</category>
<description>Application Area Type: Constant</description>
</element>
<element define="1">
<name>DA_INPUT</name>
<key>0x0004</key>
<category>Area Types</category>
<description>Application Area Type: Input</description>
</element>
<element define="1">
<name>DA_OUTPUT</name>
<key>0x0008</key>
<category>Area Types</category>
<description>Application Area Type: Output</description>
</element>
<element define="1">
<name>DA_MEMORY</name>
<key>0x0010</key>
<category>Area Types</category>
<description>Application Area Type: Memory</description>
</element>
<element define="1">
<name>DA_RETAIN</name>
<key>0x0020</key>
<category>Area Types</category>
<description>Application Area Type: Retain</description>
</element>
<element define="1">
<name>DA_CODE</name>
<key>0x0040</key>
<category>Area Types</category>
<description>Application Area Type: Code</description>
</element>
<element define="1">
<name>DA_PERSISTENT</name>
<key>0x0100</key>
<category>Area Types</category>
<description>Application Area Type: Persistent</description>
</element>
<element define="1">
<name>DA_NONSAFETY</name>
<key>0x0800</key>
<category>Area Types</category>
<description>Application Area Type: Non Safety data within Safity SIL2 systems</description>
</element>
<element define="1">
<name>DA_ALL</name>
<key>0xFFFF</key>
<category>Area Types</category>
<description>Application Area Type: All</description>
</element>
<element define="1">
<name>IsArea</name>
<key>type</key>
<condition>DA</condition>
<category>Area Types</category>
<description>Define for checking Area Types</description>
</element>
<element typedefinition="1">
<name>sysmemallocarea_struct</name>
<structname>sysmemallocarea_struct</structname>
Reserved function for the runtime system! Should not be used by an IEC application!
<rawdata>
typedef struct tagsysmemallocarea_struct
{
	RTS_IEC_STRING *szComponent;		VAR_INPUT    
	RTS_IEC_WORD usType;				VAR_INPUT    
	RTS_IEC_XWORD udiSize;				VAR_INPUT    
	RTS_IEC_RESULT *pResult;			VAR_INPUT    
	RTS_IEC_BYTE *SysMemAllocArea;		VAR_OUTPUT    
} sysmemallocarea_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>sysmemalloccode_struct</name>
<structname>sysmemalloccode_struct</structname>
Reserved function for the runtime system! Should not be used by an IEC application!
<rawdata>
typedef struct tagsysmemalloccode_struct
{
	RTS_IEC_STRING *szComponent;		VAR_INPUT    
	RTS_IEC_XWORD udiSize;				VAR_INPUT    
	RTS_IEC_RESULT *pResult;			VAR_INPUT    
	RTS_IEC_BYTE *SysMemAllocCode;		VAR_OUTPUT    
} sysmemalloccode_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>sysmemallocdata_struct</name>
<structname>sysmemallocdata_struct</structname>
Allocates data memory of the specified size
RETURN: Pointer to the memory block. 0 if no memory is not available
<rawdata>
typedef struct tagsysmemallocdata_struct
{
	RTS_IEC_STRING *szComponent;		VAR_INPUT    Can be the library- or POU-name from IEC
	RTS_IEC_XWORD udiSize;				VAR_INPUT    Requested size of the memory block
	RTS_IEC_RESULT *pResult;			VAR_INPUT    Pointer to runtime system error code (see CmpErrors_Itfs.library)
	RTS_IEC_BYTE *SysMemAllocData;		VAR_OUTPUT    
} sysmemallocdata_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>sysmemcmp_struct</name>
<structname>sysmemcmp_struct</structname>
Compares the content of two buffers
RETURN: Returns 0 if the buffer contents are equal, else !=0
<rawdata>
typedef struct tagsysmemcmp_struct
{
	RTS_IEC_BYTE *pBuffer1;				VAR_INPUT    Address of first memory area (buffer 1)
	RTS_IEC_BYTE *pBuffer2;				VAR_INPUT    Address of second memory area (buffer 2)
	RTS_IEC_XWORD udiCount;				VAR_INPUT    Number of bytes to be compared
	RTS_IEC_DINT SysMemCmp;				VAR_OUTPUT    
} sysmemcmp_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>sysmemcpy_struct</name>
<structname>sysmemcpy_struct</structname>
Copy the content from source (pSrc) to destination buffer (pDest)
RETURN: Pointer to the destination buffer, where the copy was done
<rawdata>
typedef struct tagsysmemcpy_struct
{
	RTS_IEC_BYTE *pDest;				VAR_INPUT    Pointer to memory address to be copied to (target)
	RTS_IEC_BYTE *pSrc;					VAR_INPUT    Pointer to memory address to be copied from (source)
	RTS_IEC_XWORD udiCount;				VAR_INPUT    Number of bytes to be copied
	RTS_IEC_BYTE *SysMemCpy;			VAR_OUTPUT    
} sysmemcpy_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>sysmemforceswap_struct</name>
<structname>sysmemforceswap_struct</structname>
Routine to force swapping memory independant of the byteorder of the system!
RETURN: Number of bytes swapped:
+ -1 = failed (size too large)
+ >0 = Number of bytes swapped
<rawdata>
typedef struct tagsysmemforceswap_struct
{
	RTS_IEC_BYTE *pbyBuffer;			VAR_INPUT    POINTER TO data TO swap. You can check, which order is selected by calling the routine with pbyBuffer=0
	RTS_IEC_UDINT udiSize;				VAR_INPUT    Size of one element to swap
	RTS_IEC_UDINT udiCount;				VAR_INPUT    Number of elements to swap
	RTS_IEC_DINT SysMemForceSwap;		VAR_OUTPUT    
} sysmemforceswap_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>sysmemfreearea_struct</name>
<structname>sysmemfreearea_struct</structname>
Reserved function for the runtime system! Should not be used by an IEC application!
RETURN: Error code
<rawdata>
typedef struct tagsysmemfreearea_struct
{
	RTS_IEC_STRING *szComponent;		VAR_INPUT    
	RTS_IEC_BYTE *pMemory;				VAR_INPUT    
	RTS_IEC_RESULT SysMemFreeArea;		VAR_OUTPUT    
} sysmemfreearea_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>sysmemfreecode_struct</name>
<structname>sysmemfreecode_struct</structname>
Reserved function for the runtime system! Should not be used by an IEC application!
RETURN: Error code
<rawdata>
typedef struct tagsysmemfreecode_struct
{
	RTS_IEC_STRING *szComponent;		VAR_INPUT    Component name
	RTS_IEC_BYTE *pMemory;				VAR_INPUT    POINTER TO code memory
	RTS_IEC_RESULT SysMemFreeCode;		VAR_OUTPUT    
} sysmemfreecode_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>sysmemfreedata_struct</name>
<structname>sysmemfreedata_struct</structname>
Release data memory
RETURN: Returns the runtime system error code (see CmpErrors_Itfs.library)
<rawdata>
typedef struct tagsysmemfreedata_struct
{
	RTS_IEC_STRING *szComponent;		VAR_INPUT    Name of the component. Can be the library- or POU-name from IEC.
	RTS_IEC_BYTE *pMemory;				VAR_INPUT    Pointer to memory to be released
	RTS_IEC_RESULT SysMemFreeData;		VAR_OUTPUT    
} sysmemfreedata_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>sysmemisvalidpointer_struct</name>
<structname>sysmemisvalidpointer_struct</structname>
Check if a pointer points to a valid address
RETURN: Returns the runtime system error code (see CmpErrors_Itfs.library):
+ ERR_OK: Memory is valid
+ ERR_FAILED: Memory is invalid. Cannot be accessed with the requested access mode bWrite
<rawdata>
typedef struct tagsysmemisvalidpointer_struct
{
	RTS_IEC_BYTE *ptr;					VAR_INPUT    Pointer to the memory to be checked
	RTS_IEC_XWORD udiSize;				VAR_INPUT    Size of the memory to be checked
	RTS_IEC_BOOL bWrite;				VAR_INPUT    TRUE=Check, if memory can be written, FALSE=Check only for read access
	RTS_IEC_RESULT SysMemIsValidPointer;	VAR_OUTPUT    
} sysmemisvalidpointer_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>sysmemmove_struct</name>
<structname>sysmemmove_struct</structname>
Copy the content from source (pSrc) to destination buffer (pDest). This routine works for overlapping buffers too in opposite to SysMemCpy!
RETURN: Pointer to the destination buffer, where the move was done
<rawdata>
typedef struct tagsysmemmove_struct
{
	RTS_IEC_BYTE *pDest;				VAR_INPUT    Pointer to memory address to be moved to (target)
	RTS_IEC_BYTE *pSrc;					VAR_INPUT    Pointer to memory address to be moved from (source)
	RTS_IEC_XWORD udiCount;				VAR_INPUT    Number of bytes to be moveed
	RTS_IEC_BYTE *SysMemMove;			VAR_OUTPUT    
} sysmemmove_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>sysmemreallocdata_struct</name>
<structname>sysmemreallocdata_struct</structname>
Reallocate data memory with the specified size.
By use of this function the size of a memory block can be modified (reallocation). Therefor a pointer on the memory block to be
reallocated is passed to the function. The content of the memory block will not be modified.
If the requested memory size cannot made available at the same place (address) , the function will allocate new memory space,
RETURN: Pointer to the memory block. 0 if no memory is not available
<rawdata>
typedef struct tagsysmemreallocdata_struct
{
	RTS_IEC_STRING *szComponent;		VAR_INPUT    Name of the component. Can be the library- or POU-name from IEC.
	RTS_IEC_BYTE *pMemory;				VAR_INPUT    Pointer to memory to resize
	RTS_IEC_XWORD udiSize;				VAR_INPUT    Requested size of the memory
	RTS_IEC_RESULT *pResult;			VAR_INPUT    Pointer to runtime system error code (see CmpErrors_Itfs.library)
	RTS_IEC_BYTE *SysMemReallocData;	VAR_OUTPUT    
} sysmemreallocdata_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>sysmemset_struct</name>
<structname>sysmemset_struct</structname>
By use of this function a memory space is initialized with a specified value
RETURN: Pointer to the memory block which was initialized. 0 if the operation failed
<rawdata>
typedef struct tagsysmemset_struct
{
	RTS_IEC_BYTE *pDest;				VAR_INPUT    Pointer to memory block to initialize
	RTS_IEC_UDINT udiValue;				VAR_INPUT    Value with which the memory is to be initialized
	RTS_IEC_XWORD udiCount;				VAR_INPUT    Number of bytes to be initialized in the memory block
	RTS_IEC_BYTE *SysMemSet;			VAR_OUTPUT    
} sysmemset_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>sysmemswap_struct</name>
<structname>sysmemswap_struct</structname>
Routine to swap memory into littel endian. If little endian (intel) byteorder is received and platform has
big endian (motorola) byteorder. On little endian byteorder platforms, routine does nothing
RETURN: Number of bytes swapped:
+ -1 = failed (iSize too large)
+ 0 = no swapping necessary (little endian byteorder)
+ >0 = Number of bytes swapped (big endian byteorder)
<rawdata>
typedef struct tagsysmemswap_struct
{
	RTS_IEC_BYTE *pbyBuffer;			VAR_INPUT    Pointer to data to swap. You can check, which order is selected by calling the routine with pbyBuffer=0
	RTS_IEC_UDINT udiSize;				VAR_INPUT    Size of one element to swap
	RTS_IEC_UDINT udiCount;				VAR_INPUT    Number of elements to swap
	RTS_IEC_DINT SysMemSwap;			VAR_OUTPUT    
} sysmemswap_struct;
</rawdata>
</element>
<element function="1">
<functionname returntype="void*" parameters="(char *pszComponentName, RTS_SIZE ulSize, RTS_RESULT *pResult)">SysMemAllocData</functionname>
<description>Allocates data memory of the specified size.
IMPLEMENTATION NOTE:
New allocated memory must be initialized with 0!
</description>
<param name="pszComponentName" type="IN">Name of the component</param>
<param name="ulSize" type="IN">Requested size of the memory</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Pointer to the memory block. NULL if no memory is available.</result>
</element>
<element function="1">
<functionname returntype="void*" parameters="(char *pszComponentName, void* pData, RTS_SIZE ulSize, RTS_RESULT *pResult)">SysMemReallocData</functionname>
<description>Reallocate data memory with the specified size</description>
<param name="pszComponentName" type="IN">Name of the component</param>
<param name="pData" type="IN">Pointer to memory to resize</param>
<param name="ulSize" type="IN">Requested size of the memory</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Pointer to the memory block. NULL if no memory is available.</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char *pszComponentName, void* pData)">SysMemFreeData</functionname>
<description>Release data memory</description>
<param name="pszComponentName" type="IN">Name of the component</param>
<param name="pData" type="IN">Pointer to memory to be released</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="void*" parameters="(char *pszComponentName, unsigned short usType, RTS_SIZE ulSize, RTS_RESULT *pResult)">SysMemAllocArea</functionname>
<description>
Allocates data area of an application.
Can be used to set an application area to a specific memory.
IMPLEMENTATION NOTE:
New allocated memory must be initialized with 0, but _not_ the retain memory!
</description>
<param name="pszComponentName" type="IN" range="[NULL,VALID_COMPONENT_NAME]">Name of the component</param>
<param name="usType" type="IN" range="[DA_NONE,DA_CODE,DA_CONSTANT,DA_DATA,DA_RETAIN,INVALID_DA_AREA]">Type of the area (see category Area Types)</param>
<param name="ulSize" type="IN" range="[0,VALID_SIZE,RTS_SIZE_MAX]">Requested size of the memory</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<errorcode name="pResult" type="ERR_OK">Memory Area could be allocated</errorcode>
<errorcode name="pResult" type="ERR_FAILED">The requested Area could not be allocated - invalid combination of DA-Flags, or all areas of this type are already in use</errorcode>
<errorcode name="pResult" type="ERR_NOT_SUPPORTED">Allocation is not supported, it might be allocated dynamically</errorcode>
<errorcode name="pResult" type="ERR_OUT_OF_LIMITS">The requested area size was too large or too small</errorcode>
<result>Pointer to the memory block. NULL if no memory is available (allocate area on heap).</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char *pszComponentName, void* pData)">SysMemFreeArea</functionname>
<description>
<p>Release data area of an application.</p>
<p>Note: On SIL2 Runtimes, this function may generate an exception, when called in SAFE-Mode.</p>
</description>
<param name="pszComponentName" type="IN" range="[NULL,VALID_COMPONENT_NAME]">Name of the component</param>
<param name="pData" type="IN" range="[NULL,VALID_AREA_POINTER,INVALID_AREA_POINTER]">Pointer to area to free</param>
<parampseudo name="OperationMode" type="IN" range="[RTS_SIL2_OPMODE_SAFE,RTS_SIL2_OPMODE_DEBUG]">Specifies the current operation mode of the PLC</parampseudo>
<parampseudo name="bExceptionGenerated" type="OUT" range="[TRUE,FALSE]">Specifies, if an exception occured, or not</parampseudo>
<result>error code</result>
<errorcode name="RTS_RESULT" type="ERR_OK">Memory Area could be freed</errorcode>
<errorcode name="RTS_RESULT" type="ERR_FAILED">The memory area could not be freed (wrong area pointer, or area is not allocated)</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">Parameter pData was NULL</errorcode>
</element>
<element function="1">
<functionname returntype="void*" parameters="(char *pszComponentName, RTS_SIZE ulSize, RTS_RESULT *pResult)">SysMemAllocCode</functionname>
<description>
Allocate code memory with the specified size (in the memory, code can be executed).
NOTE: This routine can be used on architectures, where standard data memory is protected
against code execution!
IMPLEMENTATION NOTE:
New allocated memory must be initialized with 0!
</description>
<param name="pszComponentName" type="IN">Name of the component</param>
<param name="ulSize" type="IN">Requested size of the memory</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Pointer to the memory block. NULL if no memory is available.</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char *pszComponentName, void* pCode)">SysMemFreeCode</functionname>
<description>
Release code memory
</description>
<param name="pszComponentName" type="IN">Name of the component</param>
<param name="pData" type="IN">Pointer to memory to resize</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(void* ptr, RTS_SIZE ulSize, int bWrite)">SysMemIsValidPointer</functionname>
<description>
Check if a pointer points to a valid address.
</description>
<param name="ptr" type="IN">Pointer to the memory to be checked</param>
<param name="ulSize" type="IN">Size of the memory to be checked</param>
<param name="bWrite" type="IN">1=Check, if memory can be written, 0=Check only for read access</param>
<result>Error code:
<ul>
<li>ERR_OK: Memory is valid</li>
<li>ERR_FAILED: Memory is invalid. Cannot be accessed with the requested access mode bWrite</li>
</ul>
</result>
</element>
<element function="1">
<functionname returntype="int" parameters="(unsigned char *pbyBuffer, int iSize, int iCount)">SysMemSwap</functionname>
<description>
Routine to swap memory. If little endian (intel) byteorder is received and platform has
big endian (motorola) byteorder. On little endian byteorder platforms, routine does nothing.
</description>
<param name="pbyBuffer" type="IN">Pointer to data to swap. You can check, which order is selected by
calling the routine with pbyBuffer=NULL</param>
<param name="iSize" type="IN">Size of one element to swap</param>
<param name="iCount" type="IN">Number of elements to swap</param>
<result>	-1 = failed (iSize too large)
0 = no swapping necessary (little endian byteorder)
>0 = Number of bytes swapped (big endian byteorder)
1 = big endian byteorder, if pbyBuffer=NULL
</result>
</element>
<element function="1">
<functionname returntype="int" parameters="(unsigned char *pbyBuffer, int iSize, int iCount)">SysMemForceSwap</functionname>
<description>
Routine to force swapping memory independant of the byteorder of the system!
</description>
<param name="pbyBuffer" type="IN">Pointer to data to swap. You can check, which order is selected by
calling the routine with pbyBuffer=NULL</param>
<param name="iSize" type="IN">Size of one element to swap</param>
<param name="iCount" type="IN">Number of elements to swap</param>
<result>	-1 = failed (iSize too large)
>0 = Number of bytes swapped
</result>
</element>
</element>
</component>
<component>
<name>SysOut</name>
<description>
System component that allows access to time functions.
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element interface="1" name="SysOutItf">
<interfacename>SysOut</interfacename>
<description>
<p>The SysOut interface is projected to get access to the console output routines. This
can be used for debugging or logging needs.</p>
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element define="1">
<name>SysOutPrintfArg</name>
<key>SysOutVPrintf</key>
<description>Function to print out an argument list on the standard console output</description>
<param name="szFormat" type="IN">Format string</param>
<param name="pargList" type="IN">Pointer to argument list for the format string</param>
<result>error code</result>
</element>
<element define="1">
<name>CPT</name>
<key>SysOutDebug</key>
<condition>CPT</condition>
<description>Checkpoints for debugging needs. Prints the actual file and line number</description>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char *szFormat, ...)">SysOutPrintf</functionname>
<description>Function to print out a formatted string on the standard console output</description>
<param name="szFormat" type="IN">Format string with optional arguments</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char *szFormat, ...)">SysOutDebug</functionname>
<description>
Debug output fo a formatted string on the standard console output.
NOTE: Actual time should be added in front of each debug output string
</description>
<param name="szFormat" type="IN">Format string with optional arguments</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char *szFormat, va_list *pargList)">SysOutDebugArg</functionname>
<description>
Debug output of an argument list on the standard console output.
NOTE: Actual time should be added in front of each debug output string
</description>
<param name="szFormat" type="IN">Format string</param>
<param name="pargList" type="IN">Pointer to argument list for the format string</param>
<result>error code</result>
</element>
</element>
<element interface="1" name="CmpLogBackendItf">
<interfacename>CmpLogBackend</interfacename>
<description>
Interface of a logger backend, to store and dump log entries.
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(RTS_HANDLE hICmpLogBackend, CLASSID ClassId, struct tagLogOptions *pOptions)">LogBackendCreate</functionname>
<description> Create a logger </description>
<param name="pOptions" type="IN">Options for logger</param>
<param name="pResult" type="OUT">Pointer to get the result</param>
<result>Handle to the logger, or RTS_INVALID_HANDLE if failed</result>
</element>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(RTS_HANDLE hICmpLogBackend, struct tagLogOptions *pOptions, struct tagLogEntry *pLog, RTS_RESULT *pResult)">LogBackendAdd</functionname>
<description> Add a new log entry </description>
<param name="hLog" type="IN">Handle to logger</param>
<param name="pOptions" type="IN">Log options</param>
<param name="pLog" type="IN">Log entry</param>
<param name="pResult" type="OUT">Result</param>
<result>Handle to logger (logger could be split into a new logger)</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hICmpLogBackend)">LogBackendDelete</functionname>
<description> Delete a logger </description>
<param name="hLog" type="IN">Handle to logger</param>
<result>ERR_OK</result>
</element>
</element>
</component>
<component>
<name>SysSocket</name>
<description>
System specific implementation of the sockets interface.
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element interface="1" name="SysSocketItf">
<interfacename>SysSocket</interfacename>
<description>
<p>The SysSocket interface is projected to handle access to ethernet socket layer.
TCP, UDP and RAW sockets can be used.</p>
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element define="1">
<name>SOCKET_AF_UNSPEC</name>
<key>0</key>
<category>AddressFamily</category>
<description>Socket family definitions</description>
</element>
<element define="1">
<name>SOCKET_IPPROTO_IP</name>
<key>0</key>
<category>Socket protocols</category>
<description>Socket protocols for SysSockGetOption()/SysSockSetOption()</description>
</element>
<element define="1">
<name>SOCKET_SOL</name>
<key>0xffff</key>
<category>Socket level</category>
<description>Level number for SysSockGetOption()/SysSockSetOption() to apply to socket itself</description>
</element>
<element define="1">
<name>SOCKET_SO_DEBUG</name>
<key>0x0001</key>
<category>Socket options</category>
<description>Socket options for SysSockGetOption()/SysSockSetOption()</description>
</element>
<element define="1">
<name>SOCKET_TCP_NODELAY</name>
<key>0x0001</key>
<category>Socket TCP options</category>
<description>Socket options for SysSockGetOption()/SysSockSetOption(). Only to be used for SOCKET_IPPROTO_TCP.</description>
</element>
<element define="1">
<name>SOCKET_IP_MULTICAST_IF</name>
<key>0x0009</key>
<category>IP multicast options</category>
<description>Socket options for SysSockGetOption()/SysSockSetOption(). Only to be used for SOCKET_IPPROTO_IP.</description>
</element>
<element define="1">
<name>SOCKET_STREAM</name>
<key>1</key>
<category>Socket types</category>
<description>Different socket types</description>
</element>
<element define="1">
<name>SOCKET_IN_CLASSA</name>
<key>i</key>
<category>Socket class handling</category>
<description>Definitions of bits in internet address integers.
On subnets, the decomposition of addresses to host and net parts
is done according to subnet mask, not the masks here.</description>
</element>
<element define="1">
<name>SOCKET_FIONREAD</name>
<key>1</key>
<category>Ioctl commands</category>
<description>Control commands to set sockets to blocking or non-blocking</description>
</element>
<element define="1">
<name>SOCKET_MSG_NONE</name>
<key>0x00</key>
<category>TCP flags</category>
<description></description>
</element>
<element define="1">
<name>SOCKET_SD_RECEIVE</name>
<key>0x00</key>
<category>Shutdown flags</category>
<description>Flags to specify, which operations are no longer be allowed</description>
</element>
<element define="1">
<name>SOCKET_MTU_SIZE</name>
<key>1500</key>
<condition>SOCKET_MTU_SIZE</condition>
<category>Static defines</category>
<description>Only for SysSocketEmbedded: Set Transmit MTU size.</description>
</element>
<element define="1">
<name>SOCKET_BUFFER_SIZE</name>
<key>SOCKET_MTU_SIZE*3</key>
<condition>SOCKET_BUFFER_SIZE</condition>
<category>Static defines</category>
<description>Only for SysSocketEmbedded: Set Receive Buffer Size.</description>
</element>
<element define="1">
<name>SYSSOCKET_NUM_OF_STATIC_SOCKETS</name>
<key>1</key>
<condition>SYSSOCKET_NUM_OF_STATIC_SOCKETS</condition>
<category>Static defines</category>
<description>Only for SysSocketEmbedded: Number of supported sockets (one is enough for communication).</description>
</element>
<element define="1">
<name>SYSSOCKET_NUM_OF_STATIC_ARP_ENTRIES</name>
<key>5</key>
<condition>SYSSOCKET_NUM_OF_STATIC_ARP_ENTRIES</condition>
<category>Static defines</category>
<description>Only for SysSocketEmbedded: Number of ARP entries in our cache.</description>
</element>
<element define="1">
<name>SYSSOCKET_DEFAULT_IP</name>
<key>UINT32_C</key>
<condition>SYSSOCKET_DEFAULT_IP</condition>
<category>Static defines</category>
<description>Only for SysSocketEmbedded: Default IP Address (can be overwritten by setting).</description>
</element>
<element define="1">
<name>SYSSOCKET_DEFAULT_SUBNET</name>
<key>UINT32_C</key>
<condition>SYSSOCKET_DEFAULT_SUBNET</condition>
<category>Static defines</category>
<description>Only for SysSocketEmbedded: Default Subnet Mask (can be overwritten by setting).</description>
</element>
<element typedefinition="1">
<name>INADDR</name>
<structname>INADDR</structname>
<category>INADDR</category>
<description>Numeric IP-Address union to access different parts of the IP-address:</description>
<element name="s_b1" type="IN">1 byte of IP-address</element>
<element name="s_b2" type="IN">2 byte of IP-address</element>
<element name="s_b3" type="IN">3 byte of IP-address</element>
<element name="s_b4" type="IN">4 byte of IP-address</element>
<element name="s_w1" type="IN">Loword of IP-address</element>
<element name="s_w2" type="IN">Hiword of IP-address</element>
<element name="S_addr" type="IN">Dword of IP-address</element>
<rawdata>
typedef struct
{
	union
	{
        struct
		{
			RTS_IEC_BYTE s_b1	;
			RTS_IEC_BYTE s_b2	;
			RTS_IEC_BYTE s_b3	;
			RTS_IEC_BYTE s_b4	; 
		} S_un_b;
        struct
		{
			RTS_IEC_WORD s_w1	;
			RTS_IEC_WORD s_w2	;
		} S_un_w;
        RTS_IEC_UDINT S_addr	;
    } S_un;
} INADDR;
</rawdata>
</element>
<element typedefinition="1">
<name>SOCKADDRESS</name>
<structname>SOCKADDRESS</structname>
<category>INADDR</category>
<description>Numeric IP-Address union to access different parts of the IP-address:</description>
<element name="s_b1" type="IN">1 byte of IP-address</element>
<element name="s_b2" type="IN">2 byte of IP-address</element>
<element name="s_b3" type="IN">3 byte of IP-address</element>
<element name="s_b4" type="IN">4 byte of IP-address</element>
<element name="s_w1" type="IN">Loword of IP-address</element>
<element name="s_w2" type="IN">Hiword of IP-address</element>
<element name="S_addr" type="IN">Dword of IP-address</element>
<rawdata>
typedef struct
{
  RTS_IEC_INT		sin_family		;
	RTS_IEC_UINT	sin_port		;
	INADDR			sin_addr		;	
	RTS_IEC_BYTE	sin_zero[8]		;
} SOCKADDRESS;
</rawdata>
</element>
<element typedefinition="1">
<name>RTS_SOCKET_SO_VALUE_TCP_KEEPALIVE</name>
<structname>RTS_SOCKET_SO_VALUE_TCP_KEEPALIVE</structname>
<category>TCP keepalive options</category>
<description>
Parameters for the socket option SOCKET_SO_KEEPALIVE.
NOTE:
If one of the parameters is not supported, the result of SysSockSetOption() is ERR_NOT_SUPPORTED. In this case, the corresponding result of the option contains the error result.
</description>
<element name="bOn" type="IN">1=Enable keepalive, 0=Disable</element>
<element name="probes" type="IN">the number of unacknowledged probes to send before considering the connection dead and notifying the application layer.
NOTE: Is not supported by every platform!</element>
<element name="probesResult" type="OUT">Error code for the probes parameter. Returns ERR_NOT_SUPPORTED, if option is not available on the target</element>
<element name="timeout" type="IN">specifies the timeout in milliseconds with no activity until the first keep-alive packet is sent</element>
<element name="timeoutResult" type="OUT">Error code for the timeout parameter. Returns ERR_NOT_SUPPORTED, if option is not available on the target</element>
<element name="interval" type="IN">specifies the interval in milliseconds between when successive keep-alive packets are sent if no acknowledgement is received</element>
<element name="intervalResult" type="OUT">Error code for the interval parameter. Returns ERR_NOT_SUPPORTED, if option is not available on the target</element>
<rawdata>
typedef struct RTS_SOCKET_SO_VALUE_TCP_KEEPALIVE_T
{
	RTS_I32 bOn;
	RTS_UI32 probes;
	RTS_RESULT probesResult;
	RTS_UI32 timeout;
	RTS_RESULT timeoutResult;
	RTS_UI32 interval;
	RTS_RESULT intervalResult;
} RTS_SOCKET_SO_VALUE_TCP_KEEPALIVE;
</rawdata>
</element>
<element typedefinition="1">
<name>SOCKOPT_LINGER</name>
<structname>SOCKOPT_LINGER</structname>
<category>Linger on close options</category>
<description>
Parameters for the socket option SOCKET_SO_LINGER.
</description>
<element name="l_onoff" type="IN">Specifies whether a socket should remain open for a specified amount of time
after a closesocket function call to enable queued data to be sent. 0=Socket will not remain open.</element>
<element name="l_linger" type="IN">The linger time in seconds. This member specifies how long to remain open after a closesocket function call to enable queued data to be sent.</element>
<rawdata>
typedef struct
{
    RTS_IEC_WORD l_onoff;
    RTS_IEC_WORD l_linger;
} SOCKOPT_LINGER;
</rawdata>
</element>
<element typedefinition="1">
<name>RTS_SOCKET_SO_VALUE_IP_MREQ</name>
<structname>RTS_SOCKET_SO_VALUE_IP_MREQ</structname>
<category>IP multicast options</category>
<description>
Parameters for the socket options SOCKET_IP_ADD_MEMBERSHIP and SOCKET_IP_DROP_MEMBERSHIP to join/leave
the socket to/from the supplied multicast group on the specified interface.
</description>
<element name="imr_multiaddr" type="IN">The address of the IPv4 multicast group.</element>
<element name="imr_interface" type="IN">The local address of the interface on which the multicast group should be joined or dropped.</element>
<rawdata>
typedef struct RTS_SOCKET_SO_VALUE_IP_MREQ_T
{
	INADDR imr_multiaddr;
	INADDR imr_interface;
} RTS_SOCKET_SO_VALUE_IP_MREQ;
</rawdata>
</element>
<element typedefinition="1">
<name>UDP_REPLY</name>
<structname>UDP_REPLY</structname>
<category>Udp reply</category>
<description>Udp reply information</description>
<element name="ulSourceAddress" type="IN">Sender IP-Address</element>
<element name="szSourceAddress" type="IN">Sender IP-Address as string</element>
<element name="iRecv" type="IN">Number of reveived bytes</element>
<element name="usRecvPort" type="IN">Received port, in host byteorder!</element>
<rawdata>
typedef struct UDP_REPLYtag
{
	RTS_IEC_DWORD ulSourceAddress;
	RTS_IEC_STRING szSourceAddress[32];
	RTS_IEC_DINT iRecv;
	RTS_IEC_WORD usRecvPort;
} UDP_REPLY;
</rawdata>
</element>
<element typedefinition="1">
<name>syssockhtons_struct</name>
<structname>syssockhtons_struct</structname>
<description>syssockhtons</description>
<rawdata>
typedef struct tagsyssockhtons_struct
{
	RTS_IEC_WORD usHost;				VAR_INPUT
	RTS_IEC_WORD SysSockHtons;			VAR_OUTPUT
} syssockhtons_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>syssockntohl_struct</name>
<structname>syssockntohl_struct</structname>
<description>syssockntohl</description>
<rawdata>
typedef struct tagsyssockntohl_struct
{
	RTS_IEC_UDINT ulNet;				VAR_INPUT
	RTS_IEC_UDINT SysSockNtohl;			VAR_OUTPUT
} syssockntohl_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>syssockntohs_struct</name>
<structname>syssockntohs_struct</structname>
<description>syssockntohs</description>
<rawdata>
typedef struct tagsyssockntohs_struct
{
	RTS_IEC_WORD usNet;					VAR_INPUT
	RTS_IEC_WORD SysSockNtohs;			VAR_OUTPUT
} syssockntohs_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>syssockhtonl_struct</name>
<structname>syssockhtonl_struct</structname>
<description>syssockhtonl</description>
<rawdata>
typedef struct tagsyssockhtonl_struct
{
	RTS_IEC_UDINT ulHost;				VAR_INPUT
	RTS_IEC_UDINT SysSockHtonl;			VAR_OUTPUT
} syssockhtonl_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>syssockbind_struct</name>
<structname>syssockbind_struct</structname>
<description>syssockbind</description>
<rawdata>
typedef struct tagsyssockbind_struct
{
	RTS_IEC_BYTE *hSocket;				VAR_INPUT
	SOCKADDRESS *pSockAddr;				VAR_INPUT
	RTS_IEC_DINT diSockAddrSize;		VAR_INPUT
	RTS_IEC_UDINT SysSockBind;			VAR_OUTPUT
} syssockbind_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>syssockaccept_struct</name>
<structname>syssockaccept_struct</structname>
<description>syssockaccept</description>
<rawdata>
typedef struct tagsyssockaccept_struct
{
	RTS_IEC_BYTE *hSocket;				VAR_INPUT
	SOCKADDRESS *pSockAddr;				VAR_INPUT
	RTS_IEC_DINT *pdiSockAddrSize;		VAR_INPUT
	RTS_IEC_UDINT *pResult;				VAR_INPUT
	RTS_IEC_BYTE *SysSockAccept;		VAR_OUTPUT
} syssockaccept_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>syssockclose_struct</name>
<structname>syssockclose_struct</structname>
<description>syssockclose</description>
<rawdata>
typedef struct tagsyssockclose_struct
{
	RTS_IEC_BYTE *hSocket;				VAR_INPUT
	RTS_IEC_UDINT SysSockClose;			VAR_OUTPUT
} syssockclose_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>syssockcloseudp_struct</name>
<structname>syssockcloseudp_struct</structname>
<description>syssockcloseudp</description>
<rawdata>
typedef struct tagsyssockcloseudp_struct
{
	RTS_IEC_BYTE *hSocketUdp;			VAR_INPUT
	RTS_IEC_UDINT SysSockCloseUdp;		VAR_OUTPUT
} syssockcloseudp_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>syssockconnect_struct</name>
<structname>syssockconnect_struct</structname>
<description>syssockconnect</description>
<rawdata>
typedef struct tagsyssockconnect_struct
{
	RTS_IEC_BYTE *hSocket;				VAR_INPUT
	SOCKADDRESS *pSockAddr;				VAR_INPUT
	RTS_IEC_DINT diSockAddrSize;		VAR_INPUT
	RTS_IEC_UDINT SysSockConnect;		VAR_OUTPUT
} syssockconnect_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>syssockcreate_struct</name>
<structname>syssockcreate_struct</structname>
<description>syssockcreate</description>
<rawdata>
typedef struct tagsyssockcreate_struct
{
	RTS_IEC_INT iAddressFamily;			VAR_INPUT
	RTS_IEC_DINT diType;				VAR_INPUT
	RTS_IEC_DINT diProtocol;			VAR_INPUT
	RTS_IEC_UDINT *pResult;				VAR_INPUT
	RTS_IEC_BYTE *SysSockCreate;		VAR_OUTPUT
} syssockcreate_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>syssockcreateudp_struct</name>
<structname>syssockcreateudp_struct</structname>
<description>syssockcreateudp</description>
<rawdata>
typedef struct tagsyssockcreateudp_struct
{
	RTS_IEC_DINT diSendPort;			VAR_INPUT
	RTS_IEC_DINT diRecvPort;			VAR_INPUT
	RTS_IEC_UDINT *pResult;				VAR_INPUT
	RTS_IEC_BYTE *SysSockCreateUdp;		VAR_OUTPUT
} syssockcreateudp_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>syssockgethostbyname_struct</name>
<structname>syssockgethostbyname_struct</structname>
<description>syssockgethostbyname</description>
<rawdata>
typedef struct tagsyssockgethostbyname_struct
{
	RTS_IEC_STRING *szHostName;			VAR_INPUT
	SOCK_HOSTENT *pHost;				VAR_INPUT
	RTS_IEC_UDINT SysSockGetHostByName;	VAR_OUTPUT
} syssockgethostbyname_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>syssockgethostname_struct</name>
<structname>syssockgethostname_struct</structname>
<description>syssockgethostname</description>
<rawdata>
typedef struct tagsyssockgethostname_struct
{
	RTS_IEC_STRING *szHostName;			VAR_INPUT
	RTS_IEC_DINT diNameLen;				VAR_INPUT
	RTS_IEC_UDINT SysSockGetHostName;	VAR_OUTPUT
} syssockgethostname_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>syssockgetoption_struct</name>
<structname>syssockgetoption_struct</structname>
<description>syssockgetoption</description>
<rawdata>
typedef struct tagsyssockgetoption_struct
{
	RTS_IEC_BYTE *hSocket;				VAR_INPUT
	RTS_IEC_DINT diLevel;				VAR_INPUT
	RTS_IEC_DINT diOption;				VAR_INPUT
	RTS_IEC_DINT *pdiOptionValue;		VAR_INPUT
	RTS_IEC_DINT *pdiOptionLen;			VAR_INPUT
	RTS_IEC_UDINT SysSockGetOption;		VAR_OUTPUT
} syssockgetoption_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>syssockgetoshandle_struct</name>
<structname>syssockgetoshandle_struct</structname>
<description>syssockgetoshandle</description>
<rawdata>
typedef struct tagsyssockgetoshandle_struct
{
	RTS_IEC_BYTE *hSocketUdp;			VAR_INPUT
	RTS_IEC_HANDLE SysSockGetOSHandle;	VAR_OUTPUT
} syssockgetoshandle_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>syssockgetrecvsizeudp_struct</name>
<structname>syssockgetrecvsizeudp_struct</structname>
<description>syssockgetrecvsizeudp</description>
<rawdata>
typedef struct tagsyssockgetrecvsizeudp_struct
{
	RTS_IEC_BYTE *hSocketUdp;			VAR_INPUT
	RTS_IEC_DINT diTimeout;				VAR_INPUT
	RTS_IEC_UDINT *pResult;				VAR_INPUT
	RTS_IEC_DINT SysSockGetRecvSizeUdp;	VAR_OUTPUT
} syssockgetrecvsizeudp_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>syssockgetsubnetmask_struct</name>
<structname>syssockgetsubnetmask_struct</structname>
<description>syssockgetsubnetmask</description>
<rawdata>
typedef struct tagsyssockgetsubnetmask_struct
{
	RTS_IEC_STRING *szIPAddress;		VAR_INPUT
	RTS_IEC_STRING *szSubnetMask;		VAR_INPUT
	RTS_IEC_DINT diMaxSugnetMask;		VAR_INPUT
	RTS_IEC_UDINT SysSockGetSubnetMask;	VAR_OUTPUT
} syssockgetsubnetmask_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>syssockinetaddr_struct</name>
<structname>syssockinetaddr_struct</structname>
<description>syssockinetaddr</description>
<rawdata>
typedef struct tagsyssockinetaddr_struct
{
	RTS_IEC_STRING *szIPAddress;		VAR_INPUT
	RTS_IEC_UDINT *pInAddr;				VAR_INPUT
	RTS_IEC_UDINT SysSockInetAddr;		VAR_OUTPUT
} syssockinetaddr_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>syssockinetntoa_struct</name>
<structname>syssockinetntoa_struct</structname>
<description>syssockinetntoa</description>
<rawdata>
typedef struct tagsyssockinetntoa_struct
{
	INADDR *pInAddr;					VAR_INPUT
	RTS_IEC_STRING *szIPADDR;			VAR_INPUT
	RTS_IEC_DINT diIPAddrSize;			VAR_INPUT
	RTS_IEC_UDINT SysSockInetNtoa;		VAR_OUTPUT
} syssockinetntoa_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>syssockioctl_struct</name>
<structname>syssockioctl_struct</structname>
<description>syssockioctl</description>
<rawdata>
typedef struct tagsyssockioctl_struct
{
	RTS_IEC_BYTE *hSocket;				VAR_INPUT
	RTS_IEC_DINT diCommand;				VAR_INPUT
	RTS_IEC_DINT *pdiParameter;			VAR_INPUT
	RTS_IEC_UDINT SysSockIoctl;			VAR_OUTPUT
} syssockioctl_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>syssocklisten_struct</name>
<structname>syssocklisten_struct</structname>
<description>syssocklisten</description>
<rawdata>
typedef struct tagsyssocklisten_struct
{
	RTS_IEC_BYTE *hSocket;				VAR_INPUT
	RTS_IEC_DINT diMaxConnections;		VAR_INPUT
	RTS_IEC_UDINT SysSockListen;		VAR_OUTPUT
} syssocklisten_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>syssockping_struct</name>
<structname>syssockping_struct</structname>
<description>syssockping</description>
<rawdata>
typedef struct tagsyssockping_struct
{
	RTS_IEC_STRING *szIPAddress;		VAR_INPUT
	RTS_IEC_UDINT ulTimeout;			VAR_INPUT
	RTS_IEC_UDINT *pulReplyTime;		VAR_INPUT
	RTS_IEC_UDINT SysSockPing;			VAR_OUTPUT
} syssockping_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>syssockrecv_struct</name>
<structname>syssockrecv_struct</structname>
<description>syssockrecv</description>
<rawdata>
typedef struct tagsyssockrecv_struct
{
	RTS_IEC_BYTE *hSocket;				VAR_INPUT
	RTS_IEC_BYTE *pbyBuffer;			VAR_INPUT
	RTS_IEC_DINT diBufferSize;			VAR_INPUT
	RTS_IEC_DINT diFlags;				VAR_INPUT
	RTS_IEC_UDINT *pResult;				VAR_INPUT
	RTS_IEC_DINT SysSockRecv;			VAR_OUTPUT
} syssockrecv_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>syssockrecvfrom_struct</name>
<structname>syssockrecvfrom_struct</structname>
<description>syssockrecvfrom</description>
<rawdata>
typedef struct tagsyssockrecvfrom_struct
{
	RTS_IEC_BYTE *hSocket;				VAR_INPUT
	RTS_IEC_BYTE *pbyBuffer;			VAR_INPUT
	RTS_IEC_DINT diBufferSize;			VAR_INPUT
	RTS_IEC_DINT diFlags;				VAR_INPUT
	SOCKADDRESS *pSockAddr;				VAR_INPUT
	RTS_IEC_DINT diSockAddrSize;		VAR_INPUT
	RTS_IEC_UDINT *pResult;				VAR_INPUT
	RTS_IEC_DINT SysSockRecvFrom;		VAR_OUTPUT
} syssockrecvfrom_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>syssockrecvfromudp_struct</name>
<structname>syssockrecvfromudp_struct</structname>
<description>syssockrecvfromudp</description>
<rawdata>
typedef struct tagsyssockrecvfromudp_struct
{
	RTS_IEC_BYTE *hSocketUdp;			VAR_INPUT
	RTS_IEC_BYTE *pbyData;				VAR_INPUT
	RTS_IEC_DINT diDataSize;			VAR_INPUT
	UDP_REPLY_OLD *pReply;					VAR_INPUT
	RTS_IEC_UDINT *pResult;				VAR_INPUT
	RTS_IEC_DINT SysSockRecvFromUdp;	VAR_OUTPUT
} syssockrecvfromudp_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>syssockrecvfromudp2_struct</name>
<structname>syssockrecvfromudp2_struct</structname>
<description>syssockrecvfromudp2</description>
<rawdata>
typedef struct tagsyssockrecvfromudp2_struct
{
	RTS_IEC_BYTE *hSocketUdp;			VAR_INPUT
	RTS_IEC_BYTE *pbyData;				VAR_INPUT
	RTS_IEC_DINT diDataSize;			VAR_INPUT
	UDP_REPLY *pReply;					VAR_INPUT
	RTS_IEC_UDINT *pResult;				VAR_INPUT
	RTS_IEC_DINT SysSockRecvFromUdp2;	VAR_OUTPUT
} syssockrecvfromudp2_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>syssockselect_struct</name>
<structname>syssockselect_struct</structname>
<description>syssockselect</description>
<rawdata>
typedef struct tagsyssockselect_struct
{
	RTS_IEC_DINT diWidth;				VAR_INPUT
	SOCKET_FD_SET *pfdRead;				VAR_INPUT
	SOCKET_FD_SET *pfdWrite;			VAR_INPUT
	SOCKET_FD_SET *pfdExcept;			VAR_INPUT
	SOCKET_TIMEVAL *ptvTimeout;			VAR_INPUT
	RTS_IEC_DINT *pdiReady;				VAR_INPUT
	RTS_IEC_UDINT SysSockSelect;		VAR_OUTPUT
} syssockselect_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>syssocksend_struct</name>
<structname>syssocksend_struct</structname>
<description>syssocksend</description>
<rawdata>
typedef struct tagsyssocksend_struct
{
	RTS_IEC_BYTE *hSocket;				VAR_INPUT
	RTS_IEC_BYTE *pbyBuffer;			VAR_INPUT
	RTS_IEC_DINT diBufferSize;			VAR_INPUT
	RTS_IEC_DINT diFlags;				VAR_INPUT
	RTS_IEC_UDINT *pResult;				VAR_INPUT
	RTS_IEC_DINT SysSockSend;			VAR_OUTPUT
} syssocksend_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>syssocksendto_struct</name>
<structname>syssocksendto_struct</structname>
<description>syssocksendto</description>
<rawdata>
typedef struct tagsyssocksendto_struct
{
	RTS_IEC_BYTE *hSocket;				VAR_INPUT
	RTS_IEC_BYTE *pbyBuffer;			VAR_INPUT
	RTS_IEC_DINT diBufferSize;			VAR_INPUT
	RTS_IEC_DINT diFlags;				VAR_INPUT
	SOCKADDRESS *pSockAddr;				VAR_INPUT
	RTS_IEC_DINT diSockAddrSize;		VAR_INPUT
	RTS_IEC_UDINT *pResult;				VAR_INPUT
	RTS_IEC_DINT SysSockSendTo;			VAR_OUTPUT
} syssocksendto_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>syssocksendtoudp_struct</name>
<structname>syssocksendtoudp_struct</structname>
<description>syssocksendtoudp</description>
<rawdata>
typedef struct tagsyssocksendtoudp_struct
{
	RTS_IEC_BYTE *hSocketUdp;			VAR_INPUT
	RTS_IEC_DINT diPort;				VAR_INPUT
	RTS_IEC_STRING *szDestAddress;		VAR_INPUT
	RTS_IEC_BYTE *pbyData;				VAR_INPUT
	RTS_IEC_DINT diDataSize;			VAR_INPUT
	RTS_IEC_UDINT *pResult;				VAR_INPUT
	RTS_IEC_DINT SysSockSendToUdp;		VAR_OUTPUT
} syssocksendtoudp_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>syssocksetipaddress_struct</name>
<structname>syssocksetipaddress_struct</structname>
<description>syssocksetipaddress</description>
<rawdata>
typedef struct tagsyssocksetipaddress_struct
{
	RTS_IEC_STRING *szCard;				VAR_INPUT
	RTS_IEC_STRING *szIPAddress;		VAR_INPUT
	RTS_IEC_UDINT SysSockSetIPAddress;	VAR_OUTPUT
} syssocksetipaddress_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>syssocksetoption_struct</name>
<structname>syssocksetoption_struct</structname>
<description>syssocksetoption</description>
<rawdata>
typedef struct tagsyssocksetoption_struct
{
	RTS_IEC_BYTE *hSocket;				VAR_INPUT
	RTS_IEC_DINT diLevel;				VAR_INPUT
	RTS_IEC_DINT diOption;				VAR_INPUT
	RTS_IEC_DINT *pdiOptionValue;		VAR_INPUT
	RTS_IEC_DINT diOptionLen;			VAR_INPUT
	RTS_IEC_UDINT SysSockSetOption;		VAR_OUTPUT
} syssocksetoption_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>syssocksetsubnetmask_struct</name>
<structname>syssocksetsubnetmask_struct</structname>
<description>syssocksetsubnetmask</description>
<rawdata>
typedef struct tagsyssocksetsubnetmask_struct
{
	RTS_IEC_STRING *szIPAddress;		VAR_INPUT
	RTS_IEC_STRING *szSubnetMask;		VAR_INPUT
	RTS_IEC_UDINT SysSockSetSubnetMask;	VAR_OUTPUT
} syssocksetsubnetmask_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>syssockshutdown_struct</name>
<structname>syssockshutdown_struct</structname>
<description>syssockshutdown</description>
<rawdata>
typedef struct tagsyssockshutdown_struct
{
	RTS_IEC_BYTE *hSocket;				VAR_INPUT
	RTS_IEC_DINT diHow;					VAR_INPUT
	RTS_IEC_UDINT SysSockShutdown;		VAR_OUTPUT
} syssockshutdown_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>syssockfdisset_struct</name>
<structname>syssockfdisset_struct</structname>
<description>syssockfdisset</description>
<rawdata>
typedef struct tagsyssockfdisset_struct
{
	RTS_IEC_BYTE *hSocket;				VAR_INPUT
	SOCKET_FD_SET *pfs;					VAR_INPUT
	RTS_IEC_BOOL SysSockFdIsset;		VAR_OUTPUT
} syssockfdisset_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>syssockfdinit_struct</name>
<structname>syssockfdinit_struct</structname>
<description>syssockfdinit</description>
<rawdata>
typedef struct tagsyssockfdinit_struct
{
	RTS_IEC_BYTE *hSocket;				VAR_INPUT
	SOCKET_FD_SET *pfs;					VAR_INPUT
	RTS_IEC_UDINT SysSockFdInit;		VAR_OUTPUT
} syssockfdinit_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>syssockfdzero_struct</name>
<structname>syssockfdzero_struct</structname>
<description>syssockfdzero</description>
<rawdata>
typedef struct tagsyssockfdzero_struct
{
	SOCKET_FD_SET *pfs;					VAR_INPUT
	RTS_IEC_UDINT SysSockFdZero;		VAR_OUTPUT
} syssockfdzero_struct;
</rawdata>
</element>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(int iAddressFamily, int iType, int iProtocol, RTS_RESULT *pResult)">SysSockCreate</functionname>
<description>
Create a new socket and return the socket handle. In case of an error, RTS_INVALID_HANDLE is returned.
</description>
<param name="iAddressFamily" type="IN">Socket address family</param>
<param name="iType" type="IN">Socket type</param>
<param name="iProtocol" type="IN">Socket protocol</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Handle to the socket</result>
</element>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(int iSendPort, int iRecvPort, RTS_RESULT *pResult)">SysSockCreateUdp</functionname>
<description>
Higher level function, to create a complete UDP socket
</description>
<param name="iSendPort" type="IN">Port number to send (host byte order)</param>
<param name="iRecvPort" type="IN">Port number to receive (host byte order)</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Handle to the UDP socket</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hSocket, int iLevel, int iOption, char *pcOptionValue, int iOptionLen)">SysSockSetOption</functionname>
<description>
Set options of a specified socket
</description>
<param name="hSocket" type="IN">Handle to the socket</param>
<param name="iLevel" type="IN">Level of the socket</param>
<param name="iOption" type="IN">Socket option command</param>
<param name="pcOptionValue" type="IN">Pointer to the option value</param>
<param name="iOptionLen" type="IN">Lenght of option value</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hSocket, int iLevel, int iOption, char *pcOptionValue, int *piOptionLen)">SysSockGetOption</functionname>
<description>
Get options of a specified socket
</description>
<param name="hSocket" type="IN">Handle to the socket</param>
<param name="iLevel" type="IN">Level of the socket</param>
<param name="iOption" type="IN">Socket option command</param>
<param name="pcOptionValue" type="OUT">Pointer to get the option value</param>
<param name="piOptionLen" type="OUT">Pointer to the option length. Real length is returned</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hSocket, SOCKADDRESS *pSockAddr, int iSockAddrSize)">SysSockBind</functionname>
<description>
Bind a socket to a socket address and port number
</description>
<param name="hSocket" type="IN">Handle to the socket</param>
<param name="pSockAddr" type="IN">Spcket address</param>
<param name="iSockAddrSize" type="IN">Size of the socket address structure</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hSocket, int iMaxConnections)">SysSockListen</functionname>
<description>
Listen on a TCP server socket for new connection
</description>
<param name="hSocket" type="IN">Handle to the socket</param>
<param name="iMaxConnections" type="IN">Maximum number of connections allowed</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(RTS_HANDLE hSocket, SOCKADDRESS *pSockAddr, int *piSockAddrSize, RTS_RESULT *pResult)">SysSockAccept</functionname>
<description>
Accept the next incoming TCP connection. Returns the socket for the newly created
connection or RTS_INVALID_HANDLE if failed.
</description>
<param name="hSocket" type="IN">Handle to the socket</param>
<param name="pSockAddr" type="OUT">Socket address of the client, who is connected</param>
<param name="piSockAddrSize" type="INOUT">Pointer to socket address structure</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Handle to the new accepted socket</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hSocket, SOCKADDRESS *pSockAddr, int iSockAddrSize)">SysSockConnect</functionname>
<description>
Connect as a client to a TCP server
</description>
<param name="hSocket" type="IN">Handle to the socket</param>
<param name="pSockAddr" type="IN">Socket address of the client, who is connected</param>
<param name="iSockAddrSize" type="IN">Size of socket address structure</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hSocket, int iHow)">SysSockShutdown</functionname>
<description>
Shutdown a socket
</description>
<param name="hSocket" type="IN">Handle to the socket</param>
<param name="iHow" type="IN">Specified, which operations are no longer be allowed. See category shutdown flags</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hSocket, int iCommand, int *piParameter)">SysSockIoctl</functionname>
<description>
Io-control of a socket
</description>
<param name="hSocket" type="IN">Handle to the socket</param>
<param name="iCommand" type="IN">Io-control command</param>
<param name="piParameter" type="INOUT">Parameter value of the command</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="int" parameters="(RTS_HANDLE hSocket, char *pbyBuffer, int iBufferSize, int iFlags, RTS_RESULT *pResult)">SysSockRecv</functionname>
<description>
Receive data from a TCP socket
</description>
<param name="hSocket" type="IN">Handle to the socket</param>
<param name="pbyBuffer" type="OUT">Buffer to read data from the socket</param>
<param name="iBufferSize" type="IN">Maximum length of the buffer</param>
<param name="iFlags" type="IN">The flags parameter can be used to influence the behavior of the
function beyond the options specified for the associated socket. The semantics of this function
are determined by the socket options and the flags parameter. The latter is constructed by using the
bitwise OR operator with any of the SOCKET_MSG values. See category TCP flags.</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Returns number of bytes received. 0 if failed.</result>
</element>
<element function="1">
<functionname returntype="int" parameters="(RTS_HANDLE hSocket, char *pbyBuffer, int iBufferSize, int iFlags, RTS_RESULT *pResult)">SysSockSend</functionname>
<description>
Sent data to a TCP socket
</description>
<param name="hSocket" type="IN">Handle to the socket</param>
<param name="pbyBuffer" type="IN">Buffer with data to sent</param>
<param name="iBufferSize" type="IN">Maximum length of the buffer</param>
<param name="iFlags" type="IN">The flags parameter can be used to influence the behavior of the
function beyond the options specified for the associated socket. The semantics of this function
are determined by the socket options and the flags parameter. The latter is constructed by using the
bitwise OR operator with any of the SOCKET_MSG values.</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Returns number of sent bytes. 0 if failed.</result>
</element>
<element function="1">
<functionname returntype="int" parameters="(RTS_HANDLE hSocket, char *pbyBuffer, int iBufferSize, int iFlags, SOCKADDRESS *pSockAddr, int iSockAddrSize, RTS_RESULT *pResult)">SysSockRecvFrom</functionname>
<description>
Receive a message from a connectionless socket (UDP)
</description>
<param name="hSocket" type="IN">Handle to the socket</param>
<param name="pbyBuffer" type="OUT">Buffer to read data from the socket</param>
<param name="iBufferSize" type="IN">Maximum length of the buffer</param>
<param name="iFlags" type="IN">The flags parameter can be used to influence the behavior of the
function beyond the options specified for the associated socket. The semantics of this function
are determined by the socket options and the flags parameter. The latter is constructed by using the
bitwise OR operator with any of the SOCKET_MSG values.</param>
<param name="pSockAddr" type="IN">Socket address and port to receive data from</param>
<param name="iSockAddrSize" type="IN">Size of socket address structure</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Returns number of bytes received</result>
</element>
<element function="1">
<functionname returntype="int" parameters="(RTS_HANDLE hSocket, char *pbyBuffer, int iBufferSize, int iFlags, SOCKADDRESS *pSockAddr, int iSockAddrSize, RTS_RESULT *pResult)">SysSockSendTo</functionname>
<description>
Send a message over a connectionless socket (UDP)
</description>
<param name="hSocket" type="IN">Handle to the socket</param>
<param name="pbyBuffer" type="IN">Buffer with send data</param>
<param name="iBufferSize" type="IN">Length of data to send</param>
<param name="iFlags" type="IN">The flags parameter can be used to influence the behavior of the
function beyond the options specified for the associated socket. The semantics of this function
are determined by the socket options and the flags parameter. The latter is constructed by using the
bitwise OR operator with any of the SOCKET_MSG values.</param>
<param name="pSockAddr" type="IN">Socket address and port to sent data to</param>
<param name="iSockAddrSize" type="IN">Size of socket address structure</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Returns number of bytes received</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hSocket)">SysSockCloseUdp</functionname>
<description>
Close a UDP socket
</description>
<param name="hSocket" type="IN">Handle to the UDP socket. Must be opened with SysSockCreateUdp!</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="int" parameters="(RTS_HANDLE hSocket, int iPort, char *pszDestAddress, unsigned char *pbyData, int iDataSize, RTS_RESULT *pResult)">SysSockSendToUdp</functionname>
<description>
Send a paket to a UDP socket
</description>
<param name="hSocket" type="IN">Handle to the UDP socket</param>
<param name="iPort" type="IN">Port number to send in host byteorder!</param>
<param name="pszDestAddress" type="IN">Destination IP address ot send data to</param>
<param name="pbyData" type="IN">Pointer to data to send</param>
<param name="iDataSize" type="IN">Size of data to send</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Number of bytes sent</result>
</element>
<element function="1">
<functionname returntype="int" parameters="(RTS_HANDLE hSocket, unsigned char *pbyData, int iDataSize, UDP_REPLY *pReply, RTS_RESULT *pResult)">SysSockRecvFromUdp</functionname>
<description>
Receive a paket from a UDP socket
</description>
<param name="hSocket" type="IN">Handle to the UDP socket</param>
<param name="pbyData" type="OUT">Pointer to data to receive</param>
<param name="iDataSize" type="IN">Size of data to receive</param>
<param name="pReply" type="OUT">Description of the client that has sent this packet. See category "Udp reply".</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Number of bytes received</result>
</element>
<element function="1">
<functionname returntype="int" parameters="(RTS_HANDLE hSocket, int iTimeout, RTS_RESULT *pResult)">SysSockGetRecvSizeUdp</functionname>
<description>
Check actual received data on the UDP socket
</description>
<param name="hSocket" type="IN">Handle to the UDP socket</param>
<param name="iTimeout" type="IN">Timeout to wait for received data. -1=Infinite wait, 0=no wait</param>
<param name="pResult" type="OUT">Pointer to error code</param>
<result>Number of bytes actual available in the socket</result>
</element>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(RTS_HANDLE hSocket)">SysSockGetOSHandle</functionname>
<description>
Get operating system handle of the UDP socket
</description>
<param name="hSocket" type="IN">Handle to the UDP socket</param>
<result>Operating system handle</result>
</element>
<element function="1">
<functionname returntype="RTS_BOOL" parameters="(RTS_HANDLE hSocket, SOCKET_FD_SET *pfs)">SysSockFdIsset</functionname>
<description>
Check if a socket is inside of a set.
</description>
<param name="hSocket" type="IN">Socket to check. Can be RTS_INVALID_HANDLE to check for an invalid filled set.</param>
<param name="pfs" type="IN">Socket Set</param>
<result>TRUE if the specified socket is inside the set, FALSE if not</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hSocket, SOCKET_FD_SET *pfs)">SysSockFdInit</functionname>
<description>
Add a socket to a socket set.
</description>
<param name="hSocket" type="IN">Socket to add.</param>
<param name="pfs" type="IN">Socket Set</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char *pszHostName, int iNameLength)">SysSockGetHostName</functionname>
<description>
Get host name of the target
</description>
<param name="pszHostName" type="OUT">Pointer to get host name</param>
<param name="iNameLength" type="IN">Maximum length of hostname</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char *pszHostName, SOCK_HOSTENT *pHost)">SysSockGetHostByName</functionname>
<description>
Get host description specified by host name
</description>
<param name="pszHostName" type="IN">Pointer to host name</param>
<param name="pHost" type="OUT">Pointer to host description</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(INADDR *pInAddr, char *pszIPAddr, int iIPAddrSize)">SysSockInetNtoa</functionname>
<description>
Convert IP address to a string
</description>
<param name="pInAddr" type="IN">Pointer to IP address description</param>
<param name="pszIPAddr" type="OUT">Pointer to get IP address string (must be at least 16 bytes long)</param>
<param name="iIPAddrSize" type="IN">Maximum length of pszIPAddr</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char *pszIPAddress, RTS_UI32 *pInAddr)">SysSockInetAddr</functionname>
<description>
Convert an IP address string into an IP address
</description>
<param name="pszIPAddr" type="IN">Pointer to get IP address string (must be at least 16 bytes long)</param>
<param name="pInAddr" type="OUT">Pointer to IP address description</param>
<result>Error code:
<ul>
<li>ERR_PARAMETER: if pszIPAddress=NULL or pInAddr=NULL</li>
<li>ERR_OK: IP-address could be converted
IMPLEMENTATION NOTE:
If pszIPAddress="255.255.255.255", the error code must be ERR_OK with *pInAddr=0xFFFFFFFF (SOCKET_INADDR_BROADCAST).</li>
<li>ERR_FAILED: IP-address invalid or empty
IMPLEMENTATION NOTE:
If pszIPAddress="", the error code must be ERR_FAILED with *pInAddr=0xFFFFFFFF (SOCKET_INADDR_NONE).</li>
</ul>
</result>
</element>
<element function="1">
<functionname returntype="unsigned short" parameters="(unsigned short usHost)">SysSockHtons</functionname>
<description>
Convert a host unsigned short value into the ethernet byte order
</description>
<param name="usHost" type="IN">Host unsigned short value</param>
<result>Returns the converted unsigned short value</result>
</element>
<element function="1">
<functionname returntype="RTS_UI32" parameters="(RTS_UI32 ulHost)">SysSockHtonl</functionname>
<description>
Convert a host unsigned long value into the ethernet byte order
</description>
<param name="usHost" type="IN">Host unsigned long value</param>
<result>Returns the converted unsigned long value</result>
</element>
<element function="1">
<functionname returntype="unsigned short" parameters="(unsigned short usNet)">SysSockNtohs</functionname>
<description>
Convert a unsigned short value from ethernet byte order into host format
</description>
<param name="usNet" type="IN">Ethernet unsigned short value</param>
<result>Returns the converted unsigned short value</result>
</element>
<element function="1">
<functionname returntype="RTS_UI32" parameters="(RTS_UI32 ulNet)">SysSockNtohl</functionname>
<description>
Convert a unsigned long value from ethernet byte order into host format
</description>
<param name="usNet" type="IN">Ethernet unsigned long value</param>
<result>Returns the converted unsigned long value</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char *pszCard, char *pszIPAddress)">SysSockSetIPAddress</functionname>
<description>
Set IP address of the specified ethernet device. Is not available on all platforms!
</description>
<param name="pszCard" type="IN">Name of the ethernet card</param>
<param name="pszIPAddress" type="IN">IP address to set as string</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(int iWidth, SOCKET_FD_SET *fdRead, SOCKET_FD_SET *fdWrite, SOCKET_FD_SET *fdExcept, SOCKET_TIMEVAL *ptvTimeout, int *pnReady)">SysSockSelect</functionname>
<description>
Check a number of sockets for activity
</description>
<param name="iWidth" type="IN">Number of sockets in the SOCKET_FD_SET structure, so SOCKET_FD_SETSIZE must be used here.</param>
<param name="fdRead" type="IN">Read socket</param>
<param name="fdWrite" type="IN">Write socket</param>
<param name="fdExcept" type="IN">Exception socket</param>
<param name="ptvTimeout" type="IN">Pointer to specify the timeout of the operation.
ptvTimeout=NULL:	Infinite wait
ptvTimeout->tv_sec=-1, ptvTimeout->tv_usec=-1:	Infinite wait
ptvTimeout->tv_sec=0, ptvTimeout->tv_usec=0:	No wait</param>
<param name="pnReady" type="OUT">Number of sockets that are ready for IO</param>
<result>ERR_OK or ERR_SOCK_TIMEDOUT, if timeout expired</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char *pszIPAddress, RTS_UI32 ulTimeout, RTS_UI32 *pulReplyTime)">SysSockPing</functionname>
<description>
Check the availability of the communication partner with a ping request
</description>
<param name="pszIPAddress" type="IN">IP address of the communication partner as string</param>
<param name="ulTimeout" type="IN">Timeout in milliseconds to wait until reply</param>
<param name="pulReplyTime" type="OUT">Pointer to get the reply time of the ping request in milliseconds or NULL</param>
<result>
ERR_OK: Partner available, ERR_TIMEOUT: Partner could not be reached during the specified timeout.
All other results: Ping could not be sent because of other errors, so we don't know, if the partner is available.
</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char *pszIPAddress, char *pszSubnetMask)">SysSockSetSubnetMask</functionname>
<description>
Set subnetmask of a specified IP address adapter
</description>
<param name="pszIPAddress" type="IN">IP address of the communication partner as string</param>
<param name="pszSubnetMask" type="IN">Subnet mask as string</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char *pszIPAddress, char *pszSubnetMask, int iMaxSubnetMask)">SysSockGetSubnetMask</functionname>
<description>
Get subnetmask of a specified IP address adapter
</description>
<param name="pszIPAddress" type="IN">IP address of the communication partner as string</param>
<param name="pszSubnetMask" type="OUT">Subnet mask as string</param>
<param name="iMaxSubnetMask" type="IN">Maximum length of the subnet mask string</param>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="void" parameters="(SOCKET_FD_SET *pfs)">SysSockFdZero</functionname>
<description>
Clear a Socket set.
</description>
<param name="pfs" type="IN">Socket Set</param>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hSocket)">SysSockClose</functionname>
<description>
Close a socket.
</description>
<param name="hSocket" type="IN">Handle to the socket</param>
<result>error code</result>
</element>
</element>
</component>
<component>
<name>SysTarget</name>
<description>
Target specific functions
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<p><h1>Compiler Switch</h1></p>
<ul>
<li>
<csdef>#define TRG_16BIT</csdef>
<csdesc>16 Bit platform</csdesc>
<p></p>
</li>
<li>
<csdef>#define TRG_32BIT</csdef>
<csdesc>32 Bit platform</csdesc>
<p></p>
</li>
<li>
<csdef>#define TRG_64BIT</csdef>
<csdesc>64 Bit platform</csdesc>
<p></p>
</li>
</ul>
<element interface="1" name="SysTargetItf">
<interfacename>SysTarget</interfacename>
<description>
<p>The SysTarget interface is projected to get access to target specific informations. With this informations
a target can be recognized unique in the complete network.</p>
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element define="1">
<name>SYSTARGET_DEVICE_MASK</name>
<key>0x0000</key>
<condition>SYSTARGET_DEVICE_MASK</condition>
<category>DeviceID mask</category>
<description>Specifices, which parts of the DeviceID are checked in the signature. So a range of devices can use the same signature.</description>
</element>
<element define="1">
<name>SYSTARGET_SN_CPUID</name>
<key>CPUID</key>
<category>Serial number elements</category>
<description>Specifies the elements of the device serial number.
Each element is a single hardware charachterisic of a device and is optional.</description>
<element name="SYSTARGET_SN_CPUID" type="IN">ID of the CPU. This contains the exact processor type and architecture sepcific identifications</element>
<element name="SYSTARGET_SN_CPU" type="IN">Serial number of the processor</element>
<element name="SYSTARGET_SN_HDD" type="IN">Serial number of the harddisk. ATTENTION: Serial number is copied by cloning images or can be edited!</element>
<element name="SYSTARGET_SN_BOARD" type="IN">Serial number of the board</element>
<element name="SYSTARGET_SN_MACADDR" type="IN">Mac address of the ethernet controller. ATTENTION: Mac addresses can be edited on e.g. on virtual systems!</element>
</element>
<element define="1">
<name>SYSTARGET_TYPE_SPECIAL_UNREGISTERED_SLOT</name>
<key>0x0000</key>
<category>Device Types</category>
<description>Special device with unregistered slots</description>
</element>
<element define="1">
<name>SYSTARGET_TYPE_PROGRAMMABLE</name>
<key>0x1000</key>
<category>Device Types</category>
<description>Programmable device</description>
</element>
<element define="1">
<name>SYSTARGET_TYPE_3S_SPECIAL_DEVICE</name>
<key>0x1001</key>
<category>Device Types</category>
<description>3S special device (e.g. OfflineVisuClient)</description>
</element>
<element define="1">
<name>SYSTARGET_TYPE_SAFETY_DEVICE</name>
<key>0x1002</key>
<category>Device Types</category>
<description>Safety device</description>
</element>
<element define="1">
<name>SYSTARGET_TYPE_DRIVE</name>
<key>0x1003</key>
<category>Device Types</category>
<description>Drive device</description>
</element>
<element define="1">
<name>SYSTARGET_TYPE_PARAMETRIZABLE</name>
<key>0x1004</key>
<category>Device Types</category>
<description>Parametrizable device</description>
</element>
<element define="1">
<name>SYSTARGET_TYPE_HMI</name>
<key>0x1005</key>
<category>Device Types</category>
<description>Pure HMI device</description>
</element>
<element define="1">
<name>SYSTARGET_TYPE_3S_SOFTMOTION</name>
<key>0x1006</key>
<category>Device Types</category>
<description>3S SoftMotion device</description>
</element>
<element define="1">
<name>SYSTARGET_TYPE_COMMUNICATION</name>
<key>0x1007</key>
<category>Device Types</category>
<description>Communication device (e.g. CoDeSys Gateway")</description>
</element>
<element typedefinition="1">
<name>systargetgettype2_struct</name>
<structname>systargetgettype2_struct</structname>
<description>Returns the target class</description>
<param name="pszRouterName" type="IN">Name of the corresponding router. This feature is used to set different identifications,
if several routers are used on the same target.</param>
<param name="pulType" type="OUT">Pointer to target type. See corresponding category "Device Types"</param>
<result>error code</result>
<rawdata>
typedef struct tagsystargetgettype2_struct
{
	RTS_IEC_STRING *pszRouterName;		VAR_INPUT
	RTS_IEC_DWORD *pulType;				VAR_INPUT
	RTS_IEC_UDINT SysTargetGetType2;	VAR_OUTPUT
} systargetgettype2_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>systargetgetnodename2_struct</name>
<structname>systargetgetnodename2_struct</structname>
<description>
Get a human readable name that identifies this node in the network.
IMPLEMENTATION NOTE: This could be the registered host name of the target in the network.
</description>
<param name="pszRouterName" type="IN">Name of the corresponding router. This feature is used to set different identifications,
if several routers are used on the same target.</param>
<param name="pwszName" type="IN">Buffer that is filled with the name of the node. Type is 2 byte unicode!</param>
<param name="nMaxLength" type="IN">Maximum length of the node name including the trailing zero</param>
<result>error code</result>
<rawdata>
typedef struct tagsystargetgetnodename2_struct
{
	RTS_IEC_STRING *pszRouterName;		VAR_INPUT
	RTS_IEC_WSTRING *pwszName;			VAR_INPUT
	RTS_IEC_UDINT *pnMaxLength;			VAR_INPUT
	RTS_IEC_UDINT SysTargetGetNodeName2;	VAR_OUTPUT
} systargetgetnodename2_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>systargetgetserialnumber_struct</name>
<structname>systargetgetserialnumber_struct</structname>
<description>Returns the serial number of the target. This can be a list of hardware specific signs (processor number, board number, mac-address, etc.).</description>
<param name="ppszSerialNumber" type="INOUT">Pointer to pointer to serial number.
If ppszSerialNumber==NULL, the length of the serial number can be retrieved in *pnMaxLen.
If *ppszSerialNumber==NULL, the pointer will be set to the serial nubmer. *pnMaxLen contains the real length of the serial number.
If *ppszSerialNumber!=NULL, the serial number will be written into the buffer. *pnMaxLen must specify the max length of the buffer!</param>
<result>error code</result>
<rawdata>
typedef struct tagsystargetgetserialnumber_struct
{
	RTS_IEC_STRING **ppsSerialNumber;	VAR_INPUT
	RTS_IEC_DINT *pnMaxLen;				VAR_INPUT
	RTS_IEC_UDINT SysTargetGetSerialNumber;	VAR_OUTPUT
} systargetgetserialnumber_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>systargetgetid_struct</name>
<structname>systargetgetid_struct</structname>
<description>Returns the TargetId.
IMPLEMENTATION NOTE: Highword of the TargetId must be the VendorId! The VendorId is managed by 3S.
</description>
<param name="pulTargetId" type="OUT">Pointer to the TargetId</param>
<result>error code</result>
<rawdata>
typedef struct tagsystargetgetid_struct
{
	RTS_IEC_DWORD *pulTargetId;			VAR_INPUT
	RTS_IEC_UDINT SysTargetGetId;		VAR_OUTPUT
} systargetgetid_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>systargetgetoperatingsystemid_struct</name>
<structname>systargetgetoperatingsystemid_struct</structname>
<description>Returns the ID of the operating system.</description>
<param name="pudiOperatingSystemID" type="OUT">Pointer to operating system Id. See category "OperatingSystemID"</param>
<result>error code</result>
<rawdata>
typedef struct tagsystargetgetoperatingsystemid_struct
{
	RTS_IEC_UDINT *pudiOperatingSystemId;	VAR_INPUT
	RTS_IEC_UDINT SysTargetGetOperatingSystemId;	VAR_OUTPUT
} systargetgetoperatingsystemid_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>systargetgetprocessorid_struct</name>
<structname>systargetgetprocessorid_struct</structname>
<description>Returns the ID of the processor</description>
<param name="pulProcessorID" type="OUT">Pointer processor ID. See category "ProcessorID" above</param>
<result>error code</result>
<rawdata>
typedef struct tagsystargetgetprocessorid_struct
{
	RTS_IEC_UDINT *pudiProcessorId;		VAR_INPUT
	RTS_IEC_UDINT SysTargetGetProcessorId;	VAR_OUTPUT
} systargetgetprocessorid_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>systargetgetvendorname2_struct</name>
<structname>systargetgetvendorname2_struct</structname>
<description>Returns the vendor name</description>
<param name="pszRouterName" type="IN">Name of the corresponding router. This feature is used to set different identifications,
if several routers are used on the same target.</param>
<param name="pwszName" type="OUT">Pointer to the device name</param>
<param name="nMaxLength" type="IN">Max length of the name</param>
<result>error code</result>
<rawdata>
typedef struct tagsystargetgetvendorname2_struct
{
	RTS_IEC_STRING *pszRouterName;		VAR_INPUT
	RTS_IEC_WSTRING *pwszName;			VAR_INPUT
	RTS_IEC_UDINT *pnMaxLength;			VAR_INPUT
	RTS_IEC_UDINT SysTargetGetVendorName2;	VAR_OUTPUT
} systargetgetvendorname2_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>systargetgetdevicename2_struct</name>
<structname>systargetgetdevicename2_struct</structname>
<description>Returns the device name</description>
<param name="pszRouterName" type="IN">Name of the corresponding router. This feature is used to set different identifications,
if several routers are used on the same target.</param>
<param name="pwszName" type="OUT">Pointer to the device name</param>
<param name="nMaxLength" type="IN">Max length of the name</param>
<result>error code</result>
<rawdata>
typedef struct tagsystargetgetdevicename2_struct
{
	RTS_IEC_STRING *pszRouterName;		VAR_INPUT
	RTS_IEC_WSTRING *pwszName;			VAR_INPUT
	RTS_IEC_UDINT *pnMaxLength;			VAR_INPUT
	RTS_IEC_UDINT SysTargetGetDeviceName2;	VAR_OUTPUT
} systargetgetdevicename2_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>systargetgetnodename_struct</name>
<structname>systargetgetnodename_struct</structname>
<description>
Get a human readable name that identifies this node in the network.
IMPLEMENTATION NOTE: This could be the registered host name of the target in the network.
</description>
<param name="pwszName" type="IN">Buffer that is filled with the name of the node. Type is 2 byte unicode!</param>
<param name="nMaxLength" type="IN">Maximum length of the node name including the trailing zero</param>
<result>error code</result>
<rawdata>
typedef struct tagsystargetgetnodename_struct
{
	RTS_IEC_WSTRING *pwszName;			VAR_INPUT
	RTS_IEC_UDINT *pnMaxLength;			VAR_INPUT
	RTS_IEC_UDINT SysTargetGetNodeName;	VAR_OUTPUT
} systargetgetnodename_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>systargetgettype_struct</name>
<structname>systargetgettype_struct</structname>
<description>Returns the target class</description>
<param name="pulType" type="OUT">Pointer to target type. See corresponding category "Device Types"</param>
<result>error code</result>
<rawdata>
typedef struct tagsystargetgettype_struct
{
	RTS_IEC_DWORD *pulType;				VAR_INPUT
	RTS_IEC_UDINT SysTargetGetType;		VAR_OUTPUT
} systargetgettype_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>systargetgetversion_struct</name>
<structname>systargetgetversion_struct</structname>
<description>Returns the target version</description>
<param name="pulVersion" type="OUT">Pointer to version of the target</param>
<result>error code</result>
<rawdata>
typedef struct tagsystargetgetversion_struct
{
	RTS_IEC_DWORD *pulVersion;			VAR_INPUT
	RTS_IEC_UDINT SysTargetGetVersion;	VAR_OUTPUT
} systargetgetversion_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>systargetgetversion2_struct</name>
<structname>systargetgetversion2_struct</structname>
<description>Returns the target version</description>
<param name="pszRouterName" type="IN">Name of the corresponding router. This feature is used to set different identifications,
if several routers are used on the same target.</param>
<param name="pulVersion" type="OUT">Pointer to version of the target</param>
<result>error code</result>
<rawdata>
typedef struct tagsystargetgetversion2_struct
{
	RTS_IEC_STRING *pszRouterName;		VAR_INPUT
	RTS_IEC_DWORD *pulVersion;			VAR_INPUT
	RTS_IEC_UDINT SysTargetGetVersion2;	VAR_OUTPUT
} systargetgetversion2_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>systargetgetdevicename_struct</name>
<structname>systargetgetdevicename_struct</structname>
<description>Returns the device name</description>
<param name="pwszName" type="OUT">Pointer to the device name</param>
<param name="nMaxLength" type="IN">Max length of the name</param>
<result>error code</result>
<rawdata>
typedef struct tagsystargetgetdevicename_struct
{
	RTS_IEC_WSTRING *pwszName;			VAR_INPUT
	RTS_IEC_UDINT *pnMaxLength;			VAR_INPUT
	RTS_IEC_UDINT SysTargetGetDeviceName;	VAR_OUTPUT
} systargetgetdevicename_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>systargetgetid2_struct</name>
<structname>systargetgetid2_struct</structname>
<description>Returns the TargetId.
IMPLEMENTATION NOTE: Highword of the TargetId must be the VendorId! The VendorId is managed by 3S.
</description>
<param name="pszRouterName" type="IN">Name of the corresponding router. This feature is used to set different identifications,
if several routers are used on the same target.</param>
<param name="pulTargetId" type="OUT">Pointer to the TargetId</param>
<result>error code</result>
<rawdata>
typedef struct tagsystargetgetid2_struct
{
	RTS_IEC_STRING *pszRouterName;		VAR_INPUT
	RTS_IEC_DWORD *pulTargetId;			VAR_INPUT
	RTS_IEC_UDINT SysTargetGetId2;		VAR_OUTPUT
} systargetgetid2_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>systargetgetvendorname_struct</name>
<structname>systargetgetvendorname_struct</structname>
<description>Returns the vendor name</description>
<param name="pwszName" type="OUT">Pointer to the device name</param>
<param name="nMaxLength" type="IN">Max length of the name</param>
<result>error code</result>
<rawdata>
typedef struct tagsystargetgetvendorname_struct
{
	RTS_IEC_WSTRING *pwszName;			VAR_INPUT
	RTS_IEC_UDINT *pnMaxLength;			VAR_INPUT
	RTS_IEC_UDINT SysTargetGetVendorName;	VAR_OUTPUT
} systargetgetvendorname_struct;
</rawdata>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_WCHAR *pwszName, RTS_SIZE *pnMaxLength)">SysTargetGetNodeName</functionname>
<description>
Get a human readable name that identifies this node in the network.
IMPLEMENTATION NOTE: This could be the registered host name of the target in the network.
</description>
<param name="pwszName" type="IN" range="[0,VALID_NAME,INVALID_NAME]">Buffer that is filled with the name of the node. Type is 2 byte unicode!</param>
<param name="pnMaxLength" type="INOUT" range="[0,VALID_LENGTH,INVALID_LENGTH]">Pointer to maximum length in unicode characters (not bytes!).
Returns the number of bytes copied into the buffer including the trailing zero.</param>
<errorcode name="RTS_RESULT Result" type="ERR_OK">Name was retrieved sucessfull</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_PARAMETER">Pointer to MaxLength or Name may not be null</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_FAILED">Name could not be retrieved</errorcode>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_WCHAR *pwszName, RTS_SIZE *pnMaxLength)">SysTargetGetConfiguredNodeName</functionname>
<description>
Get a human readable name for the target. This can be configured by the name setting (see category above).
</description>
<param name="pwszName" type="IN" range="[0,VALID_NAME,INVALID_NAME]">Buffer that is filled with the name of the node. Can be NULL to get the necessary length.</param>
<param name="pnMaxLength" type="INOUT" range="[0,VALID_LENGTH,INVALID_LENGTH]">Pointer to maximum length  in unicode characters (not bytes!).
Returns the number of bytes copied into the buffer including the trailing zero.</param>
<errorcode name="RTS_RESULT Result" type="ERR_OK">Name was retrieved sucessfull</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_PARAMETER">Pointer to MaxLength or Name may not be null</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_FAILED">Name could not be retrieved</errorcode>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_UI32 *pulType)">SysTargetGetType</functionname>
<description>
<p>Returns the target type</p>
<p>The possible target types are specified in the section "Device Types" (e.g. SYSTARGET_TYPE_PROGRAMMABLE).</p>
<p>Note: On SIL2 runtimes, this should return the value of the define SYSTARGET_DEVICE_TYPE.</p>
</description>
<param name="pulType" type="INOUT" range="[0,VALID_TYPE_POINTER]">Pointer to target type. See corresponding category "Device Types"</param>
<errorcode name="RTS_RESULT Result" type="ERR_OK">TargetType was retrieved sucessfull</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_PARAMETER">Pointer to Type may not be null</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_FAILED">TargetType could not be retrieved</errorcode>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_UI32 *pulTargetId)">SysTargetGetId</functionname>
<description>
<p>Returns the TargetId of the PLC.</p>
<p>Note: Highword of the TargetId must be the VendorId! The VendorId is managed by 3S.</p>
<p>Note2: On SIL2 runtimes, this should return the combination of the defines SYSTARGET_VENDOR_ID and SYSTARGET_DEVICE_ID.</p>
</description>
<param name="pulTargetId" type="INOUT" range="[0,VALID_ID_POINTER]">Pointer to the TargetId</param>
<errorcode name="RTS_RESULT Result" type="ERR_OK">TargetId was retrieved sucessfull</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_PARAMETER">Pointer to TargetId may not be null</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_FAILED">TargetId could not be retrieved</errorcode>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_UI32 *pulVersion)">SysTargetGetVersion</functionname>
<description>
<p>Returns the target version</p>
<p>Note: On SIL2 runtimes, this should return the value of the define SYSTARGET_DEVICE_VERSION.</p>
</description>
<param name="pulVersion" type="INOUT" range="[0,VALID_VERSION_POINTER]">Pointer to version of the target</param>
<errorcode name="RTS_RESULT Result" type="ERR_OK">version was retrieved sucessfull</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_PARAMETER">Pointer to version may not be null</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_FAILED">version could not be retrieved</errorcode>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_WCHAR *pwszName, RTS_SIZE *pnMaxLength)">SysTargetGetDeviceName</functionname>
<description>Returns the device name</description>
<param name="pwszName" type="INOUT" range="[0,INVALID_NAME,VALID_NAME]">Pointer to the device name. Can be NULL to get the necessary length.</param>
<param name="pnMaxLength" type="INOUT" range="[0,INVALID_LENGTH,VALID_LENGTH]">Pointer to maximum length of the name in unicode characters (not bytes!).
Returns the number of bytes copied into the buffer including the trailing zero.</param>
<errorcode name="RTS_RESULT Result" type="ERR_OK">device name was retrieved sucessfull</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_PARAMETER">Pointer to length may not be null</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_FAILED">device name could not be retrieved</errorcode>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_WCHAR *pwszName, RTS_SIZE *pnMaxLength)">SysTargetGetVendorName</functionname>
<description>Returns the vendor name</description>
<param name="pwszName" type="INOUT" range="[0,INVALID_NAME,VALID_NAME]">Pointer to the device name. Can be NULL to get the necessary length.</param>
<param name="pnMaxLength" type="INOUT" range="[0,INVALID_LENGTH,VALID_LENGTH]">Pointer to maximum length of the name in unicode characters (not bytes!).
Returns the number of bytes copied into the buffer including the trailing zero.</param>
<errorcode name="RTS_RESULT Result" type="ERR_OK">vendor name was retrieved sucessfull</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_PARAMETER">Pointer to length may not be null</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_FAILED">vendor name could not be retrieved</errorcode>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_UI32 *pulOperatingSystemId)">SysTargetGetOperatingSystemId</functionname>
<description>Returns the ID of the operating system.</description>
<param name="pulOperatingSystemID" type="INOUT" range="[0,VALID_OS_ID_POINTER]">Pointer to operating system Id. See category "Operating System" above</param>
<errorcode name="RTS_RESULT Result" type="ERR_OK">OS ID was retrieved sucessfull</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_PARAMETER">Pointer to OS ID may not be null</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_FAILED">OS ID could not be retrieved</errorcode>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_UI32 *pulProcessorId)">SysTargetGetProcessorId</functionname>
<description>Returns the ID of the processor</description>
<param name="pulProcessorID" type="INOUT" range="[0,VALID_CPU_ID_POINTER]">Pointer to processor ID. See category "Processor ID" above</param>
<errorcode name="RTS_RESULT Result" type="ERR_OK">CPU ID was retrieved sucessfull</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_PARAMETER">Pointer to CPU ID may not be null</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_FAILED">CPU ID could not be retrieved</errorcode>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(char **ppszSerialNumber, int *pnMaxLen)">SysTargetGetSerialNumber</functionname>
<description><p>Returns the serial number of the target. This can be a list of hardware specific signs (processor number, board number, mac-address, etc.).</p>
<p>The serial number must contain device unique identifiers! It can contain a comma separated list of different identifiers like:
"CPUID=0x000006FB | 0x00020800 | 0x0000E3BD | 0xBFEBFBFF, HDDSN=0x12345678"
Some keywords are predefined in the macros SYSTARGET_SN_XXX. See category "Serial number elements".
<ul>
<li>If ppszSerialNumber==NULL, the length of the serial number can be retrieved in *pnMaxLen.</li>
<li>If *ppszSerialNumber==NULL, the pointer will be set to the static serial nubmer. *pnMaxLen contains the real length of the serial number.</li>
<li>If *ppszSerialNumber!=NULL, the serial number will be written into the buffer. *pnMaxLen must specify the max length of the buffer!</li>
</ul>
IMPLEMENTATION NOTE: The length of the serial number string must be limited to 512 bytes!</p></description>
<param name="ppszSerialNumber" type="INOUT" range="[0,VALID_SN_P_NULL,VALID_SN_P_VALID]">Pointer to pointer to serial number.</param>
<param name="pnMaxLen" type="INOUT" range="[0,VALID_MAX_LEN]">Pointer to the max length of the string (if *ppszSerialNumber!=NULL) or the length that is returned by the function.</param>
<errorcode name="RTS_RESULT Result" type="ERR_OK">SN was retrieved sucessfull</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_PARAMETER">Pointer to MaxLen may not be null</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_FAILED">SN could not be retrieved</errorcode>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_UI32 ulChallenge, RTS_UI32 *pulSignature)">SysTargetGetSignature</functionname>
<description>Returns the signature of SysTarget</description>
<param name="ulChallenge" type="IN" range="[0,VALID_CHALLENGE]">Challenge to get the signature</param>
<param name="pulSignature" type="INOUT" range="[0,VALID_SIGNATURE,INVALID_SIGNATURE]">Signature of the SysTarget entries Type, Id, OperatingSystem, ProcessorType</param>
<errorcode name="RTS_RESULT Result" type="ERR_OK">Signature was retrieved sucessfull</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_PARAMETER">Pointer to Signature and ulChallenge may not be null</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_FAILED">Signature could not be retrieved</errorcode>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_UI16 *pusDeviceMask)">SysTargetGetDeviceMask</functionname>
<description>Returns the device mask. It is used to use the same signature for a range of devices.
Example:
*pusDeviceMask = 0x0000: All parts of the DeviceID is used to generate the signature
*pusDeviceMask = 0x00FF: Only the high BYTE of the DeviceID is used to generate the signature. So a range of 255 devices can be used with the same signature.
</description>
<param name="pusDeviceMask" type="INOUT" range="[0,P_VALID_DEVICE_MASK]">Pointer to return the device mask</param>
<errorcode name="RTS_RESULT Result" type="ERR_OK">device mask was retrieved sucessfull</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_PARAMETER">Pointer to device mask may not be null</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_FAILED">device mask could not be retrieved</errorcode>
<result>error code</result>
</element>
</element>
</component>
<component>
<name>SysTime</name>
<description>
System component that allows access to time functions.
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element interface="1" name="SysTimeItf">
<interfacename>SysTime</interfacename>
<description>
<p>The SysTime interface is projected to get access to time tick values with
different resolutions (millisecond, microsecond, nanosecond).</p>
<p>All different ticks are wrapping around their natural data type limits
(RTS_UI32 or RTS_SYSTIME). Therefore, they can be used to measure
difference timings. They can't either be used to measure absolute timings
nor can they be calculated from one to each other.</p>
<p>Implementation Notes:</p>
<ul>
<li>All three different timers need their own handling of wrap arounds,
because they have a wrap around at different points in time at different
boundaries. In practice, this implies the need for an own, static offset
counter for every timer.</li>
<li>If the timer is based on a periodic interrupt (e.g. millisecond tick),
it works only as long as no interrupt lock is held. This might be the
case in some flash drivers for example.</li>
<li>Some timers are called very regularly. So if the wrap around of the
timer source itself is very late (low frequency + large timer register),
it might be enough for the system to detect timer overruns only at every
call.</li>
</ul>
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element function="1">
<functionname returntype="RTS_UI32" parameters="(void)">SysTimeGetMs</functionname>
<description>
<p>Return a monotonic, rising millisecond tick.</p>
</description>
<result>Returns the millisecond tick</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_SYSTIME* pTime)">SysTimeGetUs</functionname>
<description>
<p>Return a monotonic, rising microsecond tick.</p>
</description>
<param name="pTime" type="INOUT" range="[NULL,VALID_PTIME]">Pointer to the time tick result</param>
<result>error code</result>
<errorcode name="RTS_RESULT" type="ERR_OK">Time was returned successfully</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">pTime was NULL</errorcode>
<errorcode name="RTS_RESULT" type="ERR_FAILED">Internal Error</errorcode>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_SYSTIME* pTime)">SysTimeGetNs</functionname>
<description>
<p>Return a monotonic, rising nanosecond tick.</p>
</description>
<param name="pTime" type="INOUT" range="[NULL,VALID_PTIME]">Pointer to the time tick result</param>
<result>error code</result>
<errorcode name="RTS_RESULT" type="ERR_OK">Time was returned successfully</errorcode>
<errorcode name="RTS_RESULT" type="ERR_PARAMETER">pTime was NULL</errorcode>
<errorcode name="RTS_RESULT" type="ERR_FAILED">Internal Error</errorcode>
</element>
</element>
</component>
<component>
<name>SysTimer</name>
<description>
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element interface="1" name="SysTimerItf">
<interfacename>SysTimer</interfacename>
<description>
<p>The SysTimer interface is projected to access timer devices on target.</p>
</description>

<copyright>(c) 2003-2010 3S-Smart Software Solutions</copyright>
<element define="1">
<name>TIMER_NO_ERROR</name>
<key>0x0000</key>
<category>Timer error codes</category>
<description> Possible Error codes:
TIMER_NO_ERROR
TIMER_HANDLE_INVALID
TIMER_SYS_SPEC_ERROR
TIMER_MANUF_SPEC_ERROR
</description>
</element>
<element define="1">
<name>RTS_TIMER_NONE</name>
<key>0</key>
<category>Timer type</category>
<description>
Possible type of a Timer:
RTS_TIMER_NONE: Not Defined
RTS_TIMER_PERIODIC: Periodical timer
RTS_TIMER_ONESHOT: Oneshot timer
</description>
</element>
<element define="1">
<name>SYSTIMER_NUM_OF_STATIC_TIMER</name>
<key>2</key>
<condition>SYSTIMER_NUM_OF_STATIC_TIMER</condition>
<category>Static defines</category>
<description>Maximum number of timers</description>
</element>
<element define="1">
<name>SYSTIMER_NUM_OF_TIMER_PRIOS</name>
<key>256</key>
<condition>SYSTIMER_NUM_OF_TIMER_PRIOS</condition>
<category>Static defines</category>
<description>Maximum number of timer priorities</description>
</element>
<element typedefinition="1">
<name>SYS_TIMER_INFO</name>
<structname>SYS_TIMER_INFO</structname>
<category>Timer info structure</category>
<description>
Timer information structure that contains all information for the SysTimerOS implementation to handle one sepcific timer object.
</description>
<element name="pfTimerCallback" type="IN">Function pointer to the timer callback, that must be executed in the timer event</element>
<element name="pfExceptionHandler" type="IN">Function pointer to an exception handler, that must be called, if an exception occurred in the corresponding timer callback function</element>
<element name="hParam" type="IN">Handle to a parameter, that must be transmitted as a parameter for the callback routine!</element>
<element name="hSysTimer" type="IN">Handle to the system timer object in the OS implementation</element>
<element name="hTimerToReset" type="IN">SysTimer handle to the next timer that mast be activated at the return code of the actual timer callback</element>
<element name="tIntervalNs" type="IN">Interval of the timer in nanoseconds</element>
<element name="tStartTime" type="IN">Start time of the timer event, when the callback is called</element>
<element name="tLastExecuteNs" type="IN">Last execution time of the timer</element>
<element name="ulType" type="IN">Timer type. See corresponding category.</element>
<element name="ulPriority" type="IN">Piority of the timer object. Typically between [0..SYSTIMER_NUM_OF_TIMER_PRIOS - 1]: 0=highest prio, 255=lowest prio</element>
<element name="tCallContext" type="IN">Actual register context of the calling callback. Can be used to make a context switch.</element>
<element name="tBPContext" type="IN">Actual register context of the actual breakpoint position</element>
<element name="bIECFunction" type="IN">Flag to mark, if callback function is an IEC function</element>
<element name="iState" type="IN">Actual state of the timer object</element>
<element name="hParam" type="IN">Optional event to wake up the callback routine (task). This event is delivered in SysTimerCreateEvent.</element>
<element name="ulIRQ" type="IN">Interrupt number of the corresponding timer object</element>
<rawdata>
typedef struct
{
	PFTIMERCALLBACK				pTimerCallback;
	PFTIMEREXCEPTIONHANDLER		pExceptionHandler;
	RTS_HANDLE					hParam;
	RTS_HANDLE					hSysTimer;
	RTS_HANDLE					hTimerToReset;
	RTS_SYSTIME					tIntervalNs; 
	RTS_SYSTIME					tStartTime;
	RTS_SYSTIME					tLastExecuteNs;
	unsigned long				ulType;
	unsigned long				ulPriority;
	SYS_TIMER_CALL_CONTEXT		tCallContext;
	SYS_TIMER_BP_CONTEXT		tBPContext;
	int							bIECFunction;
	int							iState;
	RTS_HANDLE					hEvent;
	unsigned long				ulIRQ;
} SYS_TIMER_INFO;
</rawdata>
</element>
<element typedefinition="1">
<name>systimercreatecallback2_struct</name>
<structname>systimercreatecallback2_struct</structname>
<description>This function creates a timer and calls a callback function. The scheduler creates a new timer for the schedule tick.
If the creation fails, the scheduler sets up a task instead. If the scheduler should use a task on default, SysTimerCreateCallback must return the error code ERR_NOTIMPLEMENTED.</description>
<param name="pfTimerCallback" type="IN" range="[RTS_INVALID_HANDLE,NULL,VALID_PFTIMERCALLBACK]">Pointer to a callback function</param>
<param name="hParam" type="IN" range="[RTS_INVALID_HANDLE,VALID_HPARAM]">Parameter for callback routine</param>
<param name="bIECFunction" type="IN" range="[0,1]">Is IEC function</param>
<param name="tIntervalNs" type="IN" range="[0,MIN_INTERVAL,MAX_INTERVAL,1000000]">Interval of the timer (timebase = 1 ns)</param>
<param name="ulPriority" type="IN" range="[0..(SYSTIMER_NUM_OF_TIMER_PRIOS - 1),SYSTIMER_NUM_OF_TIMER_PRIOS]">Priority of the timer object</param>
<param name="ulType" type="IN" range="[RTS_TIMER_NONE,RTS_TIMER_PERIODIC]">Timer type. See corresponding category.</param>
<param name="pfExceptionHandler" type="IN" range="[NULL,VALID_PFEXCEPTIONHANDLER]">Pointer to an optional exception handler. Can be NULL.</param>
<param name="pResult" type="OUT">Result pointer containing the error code. Might be NULL. </param>
<result>Handle of the timer or RTS_INVALID_HANDLE</result>
<rawdata>
typedef struct tagsystimercreatecallback2_struct
{
	PFTIMEREXCEPTIONHANDLER pfTimerCallback;	VAR_INPUT
	RTS_IEC_BYTE *hParam;				VAR_INPUT
	RTS_IEC_ULINT tIntervalNs;			VAR_INPUT
	RTS_IEC_UDINT ulPriority;			VAR_INPUT
	RTS_IEC_UDINT ulType;				VAR_INPUT
	PFTIMEREXCEPTIONHANDLER pfExceptionHandler;	VAR_INPUT
	RTS_IEC_UDINT *pResult;				VAR_INPUT
	RTS_IEC_BYTE *SysTimerCreateCallback2;	VAR_OUTPUT
} systimercreatecallback2_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>systimerstop_struct</name>
<structname>systimerstop_struct</structname>
<description>This function stops a timer</description>
<param name="hTimer" type="IN" range="[RTS_INVALID_HANDLE,NULL,VALID_TIMERHANDLE]">Handle of the timer</param>
<result>Error Code</result>
<rawdata>
typedef struct tagsystimerstop_struct
{
	RTS_IEC_BYTE *hTimer;				VAR_INPUT
	RTS_IEC_UDINT SysTimerStop;			VAR_OUTPUT
} systimerstop_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>systimerdelete_struct</name>
<structname>systimerdelete_struct</structname>
<description>This function deletes a timer</description>
<param name="hTimer" type="IN" range="[RTS_INVALID_HANDLE,NULL,VALID_TIMERHANDLE]">Handle of the timer</param>
<result>Error code</result>
<rawdata>
typedef struct tagsystimerdelete_struct
{
	RTS_IEC_BYTE *hTimer;				VAR_INPUT
	RTS_IEC_UDINT SysTimerDelete;		VAR_OUTPUT
} systimerdelete_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>systimergettimestamp_struct</name>
<structname>systimergettimestamp_struct</structname>
<description>This function returns the timestamp in ticks since timer start</description>
<param name="hTimer" type="IN" range="[RTS_INVALID_HANDLE,NULL,VALID_TIMERHANDLE]">Handle of the timer</param>
<param name="ptTimestampNs" type="OUT">Timestamp in nanoseconds</param>
<result>Error code</result>
<rawdata>
typedef struct tagsystimergettimestamp_struct
{
	RTS_IEC_BYTE *hTimer;				VAR_INPUT
	RTS_IEC_ULINT *ptTimestampNs;		VAR_INPUT
	RTS_IEC_UDINT SysTimerGetTimeStamp;	VAR_OUTPUT
} systimergettimestamp_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>systimersetinterval_struct</name>
<structname>systimersetinterval_struct</structname>
<description>This function returns the interval of a timer</description>
<param name="hTimer" type="IN" range="[RTS_INVALID_HANDLE,NULL,VALID_TIMERHANDLE]">Handle of the timer</param>
<param name="ptIntervalNs" type="OUT">Pointer to Interval of the timer in nanoseconds</param>
<result>Error code</result>
<rawdata>
typedef struct tagsystimersetinterval_struct
{
	RTS_IEC_BYTE *hTimer;				VAR_INPUT
	RTS_IEC_ULINT tIntervalNs;			VAR_INPUT
	RTS_IEC_UDINT SysTimerSetInterval;	VAR_OUTPUT
} systimersetinterval_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>systimergetinterval_struct</name>
<structname>systimergetinterval_struct</structname>
<description>Returns the interval of a timer</description>
<param name="hTimer" type="IN" range="[RTS_INVALID_HANDLE,NULL,VALID_TIMERHANDLE]">Handle of the timer</param>
<param name="ptIntervalNs" type="OUT">Pointer to Interval of the timer in nanoseconds</param>
<result>Error code</result>
<rawdata>
typedef struct tagsystimergetinterval_struct
{
	RTS_IEC_BYTE *hTimer;				VAR_INPUT
	RTS_IEC_ULINT *ptIntervalNs;		VAR_INPUT
	RTS_IEC_UDINT SysTimerGetInterval;	VAR_OUTPUT
} systimergetinterval_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>systimercreateevent_struct</name>
<structname>systimercreateevent_struct</structname>
<description>This function creates a timer and sets an event</description>
<param name="hParam" type="IN" range="[RTS_INVALID_HANDLE,VALID_HPARAM]">Handle to the event that is sent after the interval expires</param>
<param name="tIntervalNs" type="IN" range="[0,MIN_INTERVAL,MAX_INTERVAL,1000000]">Period of the timer (timebase = 1 ns)</param>
<param name="ulPriority" type="IN" range="[0..(SYSTIMER_NUM_OF_TIMER_PRIOS - 1),SYSTIMER_NUM_OF_TIMER_PRIOS]">Priority of the timer object</param>
<param name="pfExceptionHandler" type="IN" range="[NULL,VALID_PFEXCEPTIONHANDLER]">Pointer to an optional exception handler. Can be NULL.</param>
<param name="pResult" type="OUT">Result pointer containing the error code. Might be NULL. </param>
<result>Handle of the timer or RTS_INVALID_HANDLE</result>
<rawdata>
typedef struct tagsystimercreateevent_struct
{
	RTS_IEC_BYTE *hEvent;				VAR_INPUT
	RTS_IEC_ULINT tIntervalNs;			VAR_INPUT
	RTS_IEC_UDINT ulPriority;			VAR_INPUT
	PFTIMEREXCEPTIONHANDLER pfExceptionHandler;	VAR_INPUT
	RTS_IEC_UDINT *pResult;				VAR_INPUT
	RTS_IEC_BYTE *SysTimerCreateEvent;	VAR_OUTPUT
} systimercreateevent_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>systimermaxtimer_struct</name>
<structname>systimermaxtimer_struct</structname>
<description>This function returns the maximal number of timers</description>
<param name="pulMaxTimer" type="OUT">Number of Timers</param>
<result>Error code</result>
<rawdata>
typedef struct tagsystimermaxtimer_struct
{
	RTS_IEC_UDINT *pulMaxTimer;			VAR_INPUT
	RTS_IEC_UDINT SysTimerMaxTimer;		VAR_OUTPUT
} systimermaxtimer_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>systimerstart_struct</name>
<structname>systimerstart_struct</structname>
<description>This function starts a timer</description>
<param name="hTimer" type="IN" range="[RTS_INVALID_HANDLE,NULL,VALID_TIMERHANDLE]">Handle of the timer</param>
<param name="ulType" type="IN" range="[RTS_TIMER_NONE,RTS_TIMER_PERIODIC]">Timer type. See corresponding category.</param>
<result>Error Code</result>
<rawdata>
typedef struct tagsystimerstart_struct
{
	RTS_IEC_BYTE *hTimer;				VAR_INPUT
	RTS_IEC_UDINT ulType;				VAR_INPUT
	RTS_IEC_UDINT SysTimerStart;		VAR_OUTPUT
} systimerstart_struct;
</rawdata>
</element>
<element typedefinition="1">
<name>systimercreatecallback_struct</name>
<structname>systimercreatecallback_struct</structname>
<description>This function creates a timer and calls a callback function</description>
<param name="pfTimerCallback" type="IN" range="[RTS_INVALID_HANDLE,NULL,VALID_PFTIMERCALLBACK]">Pointer to a callback function</param>
<param name="hParam" type="IN" range="[RTS_INVALID_HANDLE,VALID_HPARAM]">Parameter for callback routine</param>
<param name="tIntervalNs" type="IN" range="[0,MIN_INTERVAL,MAX_INTERVAL,1000000]">Interval of the timer (timebase = 1 ns)</param>
<param name="ulPriority" type="IN" range="[0..(SYSTIMER_NUM_OF_TIMER_PRIOS - 1),SYSTIMER_NUM_OF_TIMER_PRIOS]">Priority of the timer object</param>
<param name="pResult" type="OUT">Result pointer containing the error code. Might be NULL. </param>
<result>Handle of the timer or RTS_INVALID_HANDLE</result>
<rawdata>
typedef struct tagsystimercreatecallback_struct
{
	PFTIMERCALLBACK pfTimerCallback;	VAR_INPUT
	RTS_IEC_BYTE *hParam;				VAR_INPUT
	RTS_IEC_ULINT tIntervalNs;			VAR_INPUT
	RTS_IEC_UDINT ulPriority;			VAR_INPUT
	PFTIMEREXCEPTIONHANDLER pfExceptionHandler;	VAR_INPUT
	RTS_IEC_UDINT *pResult;				VAR_INPUT
	RTS_IEC_BYTE *SysTimerCreateCallback;	VAR_OUTPUT
} systimercreatecallback_struct;
</rawdata>
</element>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(RTS_HANDLE hEvent, RTS_SYSTIME tIntervalNs, unsigned long ulPriority, PFTIMEREXCEPTIONHANDLER pfExceptionHandler, RTS_RESULT *pResult)">SysTimerCreateEvent</functionname>
<description> This function creates a timer and sets an event </description>
<param name="hEvent" type="IN" range="[RTS_INVALID_HANDLE,NULL,VALID_EVENTHANDLE]">Handle to the event that is sent after the interval expires</param>
<param name="tIntervalNs" type="IN" range="[0,MIN_INTERVAL,MAX_INTERVAL,1000000]">Period of the timer (timebase = 1 ns)</param>
<param name="ulPriority" type="IN" range="[0..(SYSTIMER_NUM_OF_TIMER_PRIOS - 1),SYSTIMER_NUM_OF_TIMER_PRIOS]">Priority of the timer object</param>
<param name="pfExceptionHandler" type="IN" range="[NULL,VALID_PFEXCEPTIONHANDLER]">Pointer to an optional exception handler. Can be NULL.</param>
<param name="pResult" type="OUT">Result pointer containing the error code. Might be NULL. </param>
<errorcode name="RTS_RESULT pResult" type="ERR_NOTIMPLEMENTED">Functionality not implemented, RTS_INVALID_HANDLE is returned</errorcode>
<errorcode name="RTS_RESULT pResult" type="ERR_OK">Event was created, a valid Handle is returned</errorcode>
<result>Handle of the timer or RTS_INVALID_HANDLE</result>
</element>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(PFTIMERCALLBACK pfTimerCallback, RTS_HANDLE hParam, int bIECFunction, RTS_SYSTIME tIntervalNs, unsigned long ulPriority, PFTIMEREXCEPTIONHANDLER pfExceptionHandler, RTS_RESULT *pResult)">SysTimerCreateCallback</functionname>
<description>
<p>This function creates a system timer, which cyclically calls the callback
function that is passed with the parameter pfTimerCallback.</p>
<p>This callback has to be of type PFTIMERCALLBACK and gets a the handle
which is specified by hParam passed on every call.</p>
<p>The supported timer intervals may be limited by the hardware and/or
underlying operating systems.</p>
</description>

<param name="pfTimerCallback" type="IN" range="[RTS_INVALID_HANDLE,NULL,VALID_PFTIMERCALLBACK]">Pointer to a callback function</param>
<param name="hParam" type="IN" range="[RTS_INVALID_HANDLE,VALID_HPARAM]">Parameter for callback routine</param>
<param name="bIECFunction" type="IN" range="[0,1]">Is IEC function</param>
<param name="tIntervalNs" type="IN" range="[0,MIN_INTERVAL,MAX_INTERVAL,1000000]">Interval of the timer (timebase = 1 ns)</param>
<param name="ulPriority" type="IN" range="[0..(SYSTIMER_NUM_OF_TIMER_PRIOS - 1),SYSTIMER_NUM_OF_TIMER_PRIOS]">Priority of the timer object</param>
<param name="pfExceptionHandler" type="IN" range="[NULL,VALID_PFEXCEPTIONHANDLER]">Pointer to an optional exception handler. Can be NULL.</param>
<param name="pResult" type="OUT">Result pointer containing the error code. Might be NULL. </param>
<errorcode name="RTS_RESULT pResult" type="ERR_OK">Callback was created successfully</errorcode>
<errorcode name="RTS_RESULT pResult" type="ERR_FAILED">Timer could not be opened, SysTimerOpen returned not ERR_OK, RTS_INVALID_HANDLE is returned</errorcode>
<errorcode name="RTS_RESULT pResult" type="ERR_PARAMETER">pfTimerCallback was invalid, RTS_INVALID_HANDLE is returned</errorcode>
<errorcode name="RTS_RESULT pResult" type="ERR_OUT_OF_LIMITS">Number of static timers exceeds Limit: SYSTIMER_NUM_OF_STATIC_TIMER, RTS_INVALID_HANDLE is returned</errorcode>
<errorcode name="RTS_RESULT pResult" type="ERR_NO_MEMORY">Could not get Timerinfo from MemPool, RTS_INVALID_HANDLE is returned</errorcode>
<result>Handle of the timer or RTS_INVALID_HANDLE</result>
</element>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(PFTIMERCALLBACK pfTimerCallback, RTS_HANDLE hParam, int bIECFunction, RTS_SYSTIME tIntervalNs, unsigned long ulPriority, unsigned long ulType, PFTIMEREXCEPTIONHANDLER pfExceptionHandler, RTS_RESULT *pResult)">SysTimerCreateCallback2</functionname>
<SIL2>Certified Function</SIL2>
<description>
<p>This function creates a system timer, which calls the callback
function that is passed with the parameter pfTimerCallback.</p>
<p>This callback has to be of type PFTIMERCALLBACK and gets a the handle
which is specified by hParam passed on every call.</p>
<p>Supported are timers with a different behavior (e.g. cyclic timers and
one-shot timers). They are specified in the categorie "Timer type"</p>
<p>The supported timer intervals may be limited by the hardware and/or
underlying operating systems. For one-shot timers, the interval just
specifies the time for the next shot.</p>
<p>For the case, that the underlying operating system supports only exception
handling based on tasks, you can pass a task as an exception handler with
the parameter pfExceptionHandler.</p>
<p>Timers are priorized like IEC Tasks. There may be 256 Priorities, but
this number is in fact limited by the system adaptation.</p>
</description>

<param name="pfTimerCallback" type="IN" range="[NULL,VALID_PFTIMERCALLBACK]">
Pointer for the Timer callback. This callback is called when ever the timer
event occured.
</param>
<param name="hParam" type="IN" range="[NULL,VALID_HPARAM]">
Parameter that is passed to the timer callback.
</param>
<param name="bIECFunction" type="IN" range="[0,1]">
Specify if the Callback is an IEC Function or a C Function. This parameter
is only used internally and may be 0 in most cases.
</param>
<param name="tIntervalNs" type="IN" range="[0,MIN_INTERVAL,MAX_INTERVAL,1000000]">
Interval of the timer (timebase = 1 ns). The resolution may vary because
of limitations from the hardware or underlying operating system.
</param>
<param name="ulPriority" type="IN" range="[0..(SYSTIMER_NUM_OF_TIMER_PRIOS - 1),SYSTIMER_NUM_OF_TIMER_PRIOS]">Priority of the timer object</param>
<param name="ulType" type="IN" range="[RTS_TIMER_NONE,RTS_TIMER_PERIODIC]">
Not all timers from the category "Timer type" might be supported by the
system. The only relyable timer is the periodic timer.
</param>
<param name="pfExceptionHandler" type="IN" range="[NULL,VALID_PFEXCEPTIONHANDLER]">
Pointer to an optional exception handler. Can be NULL.
</param>
<param name="pResult" type="OUT">Result pointer containing the error code. Might be NULL. </param>
<parampseudo name="bFullMemPool" type="IN" range="[TRUE,FALSE]">Indicates whether the internal used MemPool is full.</parampseudo>
<parampseudo name="_bIECFunction" type="OUT">if bIECFunction Input is set, IEC Func is called with SysCpuCallIECFuncWithParams, else directly</parampseudo>
<parampseudo name="_hParam" type="OUT">hParam from pfTimerCallback must be same value as INPUT hParam</parampseudo>
<parampseudo name="_tIntervalNs" type="OUT">Interval in which pfTimerCallback is called must be equal to INPUT tIntervalNs</parampseudo>
<errorcode name="RTS_RESULT pResult" type="ERR_OK">Callback was created successfully</errorcode>
<errorcode name="RTS_RESULT pResult" type="ERR_FAILED">Timer could not be opened, SysTimerOpen returned not ERR_OK, RTS_INVALID_HANDLE is returned</errorcode>
<errorcode name="RTS_RESULT pResult" type="ERR_PARAMETER">pfTimerCallback was invalid, RTS_INVALID_HANDLE is returned</errorcode>
<errorcode name="RTS_RESULT pResult" type="ERR_OUT_OF_LIMITS">Number of static timers exceeds Limit: SYSTIMER_NUM_OF_STATIC_TIMER, RTS_INVALID_HANDLE is returned</errorcode>
<errorcode name="RTS_RESULT pResult" type="ERR_NO_MEMORY">Could not get Timerinfo from MemPool, RTS_INVALID_HANDLE is returned</errorcode>
<result>
Handle of the timer or RTS_INVALID_HANDLE if there was an error.
</result>
</element>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(SYS_TIMER_INFO *pTimerInfo, RTS_RESULT *pResult)">SysTimerOpen</functionname>
<description> This function creates a system specific timer.
IMPLEMENTATION NOTE: The timer must be disabled (in stop state) after returning this routine! The timer must be
started explicitly with SysTimerStart.</description>
<param name="pTimerInfo" type="IN" range="[RTS_INVALID_HANDLE,NULL,VALID_TIMERINFOHANDLE]">Parameter for timer</param>
<param name="pResult" type="OUT">Result pointer containing the error code. Might be NULL. </param>
<errorcode name="RTS_RESULT pResult" type="ERR_PARAMETER">pTimerInfo is invalid</errorcode>
<errorcode name="RTS_RESULT pResult" type="ERR_OK">Timer was opened</errorcode>
<result>Handle of the timerinfo or RTS_INVALID_HANDLE</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hTimer)">SysTimerClose</functionname>
<description> This function closes a timer </description>
<param name="hTimer" type="IN" range="[RTS_INVALID_HANDLE,NULL,VALID_TIMERHANDLE]">Handle of the timer</param>
<errorcode name="RTS_RESULT Result" type="ERR_PARAMETER">hTimer is invalid</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_OK">Timer was closed</errorcode>
<result>Error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hTimer, unsigned long ulType)">SysTimerStart</functionname>
<description> This function starts a timer </description>
<param name="hTimer" type="IN" range="[RTS_INVALID_HANDLE,VALID_TIMERHANDLE]">Handle of the timer</param>
<param name="ulType" type="IN" range="[RTS_TIMER_NONE,RTS_TIMER_PERIODIC]">Timer type. See corresponding category.</param>
<parampseudo name="bRunning" type="OUT">Timer is running successfully</parampseudo>
<errorcode name="RTS_RESULT Result" type="ERR_PARAMETER">hTimer is invalid or Type is not supported</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_OK">Timer was started</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_FAILED">Timer could not be started</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_NOTIMPLEMENTED">Feature is not implemented</errorcode>
<result>Error Code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hTimer)">SysTimerStop</functionname>
<description> This function stops a timer </description>
<param name="hTimer" type="IN" range="[RTS_INVALID_HANDLE,NULL,VALID_TIMERHANDLE]">Handle of the timer</param>
<errorcode name="RTS_RESULT Result" type="ERR_PARAMETER">hTimer is invalid</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_OK">Timer was stopped</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_FAILED">Timer could not be stopped</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_NOTIMPLEMENTED">Feature is not implemented</errorcode>
<result>Error Code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hTimer, RTS_SYSTIME *ptIntervalNs)">SysTimerGetInterval</functionname>
<description>Returns the interval of a timer</description>
<param name="hTimer" type="IN" range="[RTS_INVALID_HANDLE,NULL,VALID_TIMERHANDLE]">Handle of the timer</param>
<param name="ptIntervalNs" type="OUT">Pointer to Interval of the timer in nanoseconds</param>
<parampseudo name="*ptIntervalNs" type="OUT">Interval of the timer in nanoseconds</parampseudo>
<errorcode name="RTS_RESULT Result" type="ERR_PARAMETER">hTimer is invalid or ptIntervalNs is invalid</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_OK">Interval could be read successfully</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_FAILED">Interval could not be read</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_NOTIMPLEMENTED">Feature is not implemented</errorcode>
<result>Error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hTimer, RTS_SYSTIME tIntervalNs)">SysTimerSetInterval</functionname>
<description> This function set the interval of a timer </description>
<param name="hTimer" type="IN" range="[RTS_INVALID_HANDLE,NULL,VALID_TIMERHANDLE]">Handle of the timer</param>
<param name="tIntervalNs" type="IN" range="[0,MIN_INTERVAL,MAX_INTERVAL,1000000]">Interval of the timer in nanoseconds to set</param>
<errorcode name="RTS_RESULT Result" type="ERR_PARAMETER">hTimer is invalid</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_OK">Interval was set successfully</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_FAILED">Interval was not set successfully</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_NOTIMPLEMENTED">Feature is not implemented</errorcode>
<result>Error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hTimer, RTS_SYSTIME *ptTimestampNs)">SysTimerGetTimeStamp</functionname>
<description> This function returns the timestamp in ticks since timer start </description>
<param name="hTimer" type="IN" range="[RTS_INVALID_HANDLE,NULL,VALID_TIMERHANDLE]">Handle of the timer</param>
<param name="ptTimestampNs" type="OUT">Timestamp in nanoseconds</param>
<errorcode name="RTS_RESULT Result" type="ERR_PARAMETER">hTimer or ptTimestampNs is invalid</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_OK">Timestap returned successfully</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_FAILED">Timestamp could not be returned</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_OVERFLOW">Overflow detected since Timerstart</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_NOTIMPLEMENTED">Feature is not implemented</errorcode>
<result>Error code</result>
</element>
<element function="1">
<functionname returntype="unsigned int" parameters="(RTS_HANDLE hTimer, unsigned long ulPriority, RTS_SYSTIME tInterval, RTS_RESULT *pResult)">SysTimerFitTimer</functionname>
<description> This function checks a given timer  </description>
<param name="hTimer" type="IN" range="[RTS_INVALID_HANDLE,NULL,VALID_TIMERHANDLE]">Timer to check</param>
<param name="ulPriority" type="IN" range="[0..(SYSTIMER_NUM_OF_TIMER_PRIOS - 1),SYSTIMER_NUM_OF_TIMER_PRIOS]">Priority to check</param>
<param name="tInterval" type="IN" range="[RTS_RANGE_OF_UINT64]">Interval to check</param>
<param name="pResult" type="OUT">Result pointer containing the error code. Might be NULL. </param>
<errorcode name="RTS_RESULT Result" type="ERR_PARAMETER">hTimer is invalid</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_OK">Found fit Timer</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_NO_OBJECT">Found no Timer</errorcode>
<result>Returns if Timer fits</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hTimer, RTS_SYSTIME *ptMinResolutionNs)">SysTimerGetMinResolution</functionname>
<description> Get the minimum resolution of the timer </description>
<param name="hTimer" type="IN" range="[RTS_INVALID_HANDLE,NULL,VALID_TIMERHANDLE]">Handle of the timer</param>
<param name="ptMinResolutionNs" type="OUT">Minimum timer resolution in nanoseconds</param>
<errorcode name="RTS_RESULT Result" type="ERR_PARAMETER">hTimer or ptMinResolutionNs is invalid</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_OK">Could get min resolution</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_FAILED">Could not get min resolution</errorcode>
<result>Error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hTimer, RegContext *pContext)">SysTimerGetContext</functionname>
<description> This function returns the context of the current timer handling </description>
<param name="hTimer" type="IN" range="[RTS_INVALID_HANDLE,NULL,VALID_TIMERHANDLE]">Handle of the Timer</param>
<param name="pContext" type="OUT">Pointer to Timer Context</param>
<errorcode name="RTS_RESULT Result" type="ERR_PARAMETER">hTimer or pContext is invalid</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_OK">GetContext was successful</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_FAILED">Could not get Context</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_NOTIMPLEMENTED">Feature is not implemented</errorcode>
<result>error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hTimer, RTS_HANDLE hParam)">SysTimerSetCallbackParameter</functionname>
<description> Sets the Callback Parameter </description>
<param name="hTimer" type="IN" range="[RTS_INVALID_HANDLE,NULL,VALID_TIMERHANDLE]">Handle of the timer</param>
<param name="hParam" type="IN" range="[RTS_INVALID_HANDLE,VALID_HPARAM]">Parameter for callback routine</param>
<errorcode name="RTS_RESULT Result" type="ERR_OK">Callback Parameter was successfully handled</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_PARAMETER">hTimer invalid</errorcode>
<result>Error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hTimer)">SysTimerSetResetFollowing</functionname>
<description> With this function the specified function is reseted (Needed for CmpScheduleTimer) </description>
<param name="hTimer" type="IN" range="[RTS_INVALID_HANDLE,NULL,VALID_TIMERHANDLE]">Handle of the timer to reset</param>
<errorcode name="RTS_RESULT Result" type="ERR_OK">No error occured</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_FAILED">Setting Priority failed</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_PARAMETER">hTimer invalid</errorcode>
<result>Error code</result>
</element>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(unsigned long ulPriority, RTS_SYSTIME tInterval, RTS_RESULT* pResult)">SysTimerExistsTimer</functionname>
<description> This function looks for timers with the given properties </description>
<param name="ulPriority" type="IN" range="[0..(SYSTIMER_NUM_OF_TIMER_PRIOS - 1),SYSTIMER_NUM_OF_TIMER_PRIOS]">Priority of the timer</param>
<param name="tInterval" type="IN" range="[RTS_RANGE_OF_UINT64]">Interval of the timer</param>
<param name="pResult" type="OUT">Result pointer containing the error code. Might be NULL. </param>
<errorcode name="RTS_RESULT Result" type="ERR_OK">Found existing Timer</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_NO_OBJECT">Found no Timer</errorcode>
<result>Handle to the searched timer or RTS_INVALID_HANDLE</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hTimerHandle, RTS_UI32 ulException, RegContext Context)">SysTimerGenerateException</functionname>
<description> Calls the corresponding exception handler of the timer.</description>
<param name="hTimerHandle" type="IN" range="[RTS_INVALID_HANDLE,NULL,VALID_TIMERHANDLE]">Handle to timer</param>
<param name="ulException" type="IN" range="[RTS_RANGE_OF_ULONG]">Rts standard exception</param>
<param name="Context" type="IN" range="[RTS_INVALID_HANDLE,NULL,VALID_CONTEXT]">Context to detect the code location where the exception occurred</param>
<errorcode name="RTS_RESULT Result" type="ERR_OK">Exception was successfully handled</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_FAILED">No Timer found or Exception Handler returned ERR_FAILED</errorcode>
<result>ERR_OK</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_UI32 *pulMaxTimers)">SysTimerMaxTimer</functionname>
<description> This function returns the maximal number of timers </description>
<param name="pulMaxTimer" type="OUT">Number of Timers</param>
<errorcode name="RTS_RESULT Result" type="ERR_PARAMETER">pulMaxTimer is invalid</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_OK">pulMaxTimer returned successfully</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_FAILED">pulMaxTimer could not be returned</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_NOTIMPLEMENTED">Feature is not implemented</errorcode>
<result>Error code</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_UINTPTR ulBP)">SysTimerRegisterBasePointer</functionname>
<description> Register the base pointer of the main routine.</description>
<param name="pulBP" type="IN" range="[RTS_INVALID_HANDLE,NULL,VALID_BASEPOINTER]">base pointer of main</param>
<errorcode name="RTS_RESULT Result" type="ERR_PARAMETER">pulBP is invalid</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_OK">pulBP was successful registered</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_FAILED">pulBP could not be registered</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_NOTIMPLEMENTED">Feature is not implemented</errorcode>
<result>ERR_OK</result>
</element>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(RTS_RESULT *pResult)">SysTimerGetFirst</functionname>
<description>Get first registered timer object</description>
<param name="pResult" type="OUT">Result pointer containing the error code. Might be NULL. </param>
<errorcode name="RTS_RESULT pResult" type="ERR_OK">Successfully found first Timer</errorcode>
<errorcode name="RTS_RESULT pResult" type="ERR_NO_OBJECT">No Timer found</errorcode>
<result>Pointer to first timer object</result>
</element>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(SYS_TIMER_INFO *pTimerPrev, RTS_RESULT *pResult)">SysTimerGetNext</functionname>
<description>Get next registered timer object</description>
<param name="pTimerPrev" type="IN" range="[RTS_INVALID_HANDLE,NULL,VALID_TIMERINFOHANDLE]">Pointer to previous timer object</param>
<param name="pResult" type="OUT">Result pointer containing the error code. Might be NULL. </param>
<errorcode name="RTS_RESULT Result" type="ERR_OK">Successfully found next Timer</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_NO_OBJECT">No Timer found</errorcode>
<result>Pointer to next timer object</result>
</element>
<element function="1">
<functionname returntype="void" parameters="(SYS_TIMER_INFO *pTimer)">SysTimerCallCallback</functionname>
<description>Call the registered callback handler with the corresponding hParam. IEC- and C-handlers are supported.</description>
<param name="pTimer" type="IN" range="[RTS_INVALID_HANDLE,NULL,VALID_TIMERHANDLE]">Secified timer object</param>
<parampseudo name="pTimer->bIECFunction" type="IN" range="[RTS_RANGE_OF_INT]">Secified timer object</parampseudo>
<result></result>
</element>
<element function="1">
<functionname returntype="RTS_HANDLE" parameters="(RTS_RESULT *pResult)">SysTimerGetCurrent</functionname>
<description>
<p>Returns the handle of the currently active timer, or RTS_INVALID_HANDLE if
we are outside of a timer context.</p>
<p>For SIL2 systems, this function is not implemented and returns always RTS_INVALID_HANDLE.</p>
</description>
<param name="pResult" type="OUT">Result pointer containing the error code. Might be NULL. </param>
<parampseudo name="bSIL2Runtime" type="IN" range="[1]">Result pointer containing the error code. Might be NULL. </parampseudo>
<result>Handle of the currently active timer or RTS_INVALID_HANDLE</result>
</element>
<element function="1">
<functionname returntype="RTS_RESULT" parameters="(RTS_HANDLE hTimer)">SysTimerDelete</functionname>
<description>This function deletes a timer</description>
<param name="hTimer" type="IN" range="[RTS_INVALID_HANDLE,NULL,VALID_TIMERHANDLE]">Handle of the timer</param>
<errorcode name="RTS_RESULT Result" type="ERR_PARAMETER">hTimer is invalid</errorcode>
<errorcode name="RTS_RESULT Result" type="ERR_OK">hTimer could be deleted</errorcode>
<result>Error code</result>
</element>
</element>
</component>
</documentation>
