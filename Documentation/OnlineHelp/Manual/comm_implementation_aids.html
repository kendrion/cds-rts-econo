

<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>5.5.8. Implementation Aids &#8212; RuntimeSystemDocumentation V3.5.16.40</title>
    <link rel="stylesheet" href="../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/theme.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="5.5.9. Implementation of Own Communication Driver" href="comm_implement_own_driver.html" />
    <link rel="prev" title="5.5.7. Gateway and Client" href="comm_gateway_and_client.html" /> 
  </head><body>
	<div id="header">
		<a href="#" title="CODESYS" target="_top" id="logo"><img src="../_static/logo.png" width="134" height="130" alt=""></a>
		<a href="#" title="CODESYS Documentation" target="_top" id="logo-store"><img src="../_static/logo2.png" width="137" height="130" alt=""></a>
	</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="comm_implement_own_driver.html" title="5.5.9. Implementation of Own Communication Driver"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="comm_gateway_and_client.html" title="5.5.7. Gateway and Client"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">RuntimeSystemDocumentation V3.5.16.40</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >5. Architecture Manual</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="communication.html" accesskey="U">5.5. Communication</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
  <h4>Previous topic</h4>
  <p class="topless"><a href="comm_gateway_and_client.html"
                        title="previous chapter">5.5.7. Gateway and Client</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="comm_implement_own_driver.html"
                        title="next chapter">5.5.9. Implementation of Own Communication Driver</a></p>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="implementation-aids">
<span id="comm-implementation-aids"></span><h1>5.5.8. Implementation Aids<a class="headerlink" href="#implementation-aids" title="Permalink to this headline">¶</a></h1>
<div class="section" id="implementation-of-own-block-driver">
<h2>5.5.8.1. Implementation of own block driver<a class="headerlink" href="#implementation-of-own-block-driver" title="Permalink to this headline">¶</a></h2>
<p>Block drivers are structured symmetrically, i.e. usually there is no
distinction between a client or a server. If associated system
components for abstraction of operating system and hardware details are
used, an implementation that can be used on all platforms is generally
sufficient.</p>
<p>An overview of the implementation of a block driver is provided below.
For an actual implementation the comments provided in the Itf files must
be taken into account, particularly with regard to data consistency and
buffer administration.</p>
</div>
<div class="section" id="interface">
<h2>5.5.8.2. Interface<a class="headerlink" href="#interface" title="Permalink to this headline">¶</a></h2>
<p>A block driver is an ordinary component within the CODESYS runtime
system. It has no dedicated component manager interface. Instead it
registers each network interface it manages (e.g. each Ethernet card)
with the router component using the <em>RouterRegisterDevice</em> function. The
associated function prototype is shown below (from <em>CrouterItf.h</em>):</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>RTS\_RESULT CDECL
RouterRegisterNetworkInterface(NETWORKINTERFACEINFO
*pInterfaceInfo, RTS_HANDLE * phSubnet);
typedef struct
{
 PFBDSEND pfBDSend;
    /* pointer to the blockdrivers send method */
 RTS_HANDLE hInterface;
    /* Interfacehandle within the block driver. This handle is
       passed to all calls to the block driver */
 int nMaxBlockSize;
    /* The maximum size of a block that may be sent over this
       device. */
 int nNetworkAddressBitSize;
    /* Number of bits occupied by an address of this driver */
       int bServiceChannel;
    /* If TRUE, this device provides a service channel. */
 NETWORKADDRESS addrDevice;
    /* address of the device within its subnet (CAN-Node ID, etc.)
    */
 char szName[MAX_INTERFACE_NAME];
    /* human readable name of the device. Must be unique. */
    /* Could be something like &quot;eth0&quot; or &quot;Ethernetcard #1&quot; */
} NETWORKINTERFACEINFO;

typedef RTS_RESULT( *PFBDSEND) (RTS_HANDLE hInterface,
NETWORKADDRESS addrReceiver, PROTOCOL_DATA_UNIT pduData);
</pre></div>
</div>
<ul class="simple">
<li><p><em>pfBDSend</em> is a function that is called by the router in order to
forward a block (<em>pduData</em>) to the next relevant node
(<em>addrReceiver</em>).</p></li>
<li><p><em>hInterface</em> identifies the relevant network interface in the block
driver, if the driver manages several interfaces simultaneously.
The Id is assigned by the block driver and is transferred
whenever <em>pfBDSend</em> is called.</p></li>
<li><p><em>nMaxBlockSize</em> is the maximum size of a block that can be sent via
this interface.</p></li>
<li><p><em>nNetworkAddressBitSize</em> is the number of bits required for a network
address on this interface.</p></li>
<li><p><em>addrDevice</em> is the local address of the network interface.</p></li>
<li><p><em>szName</em> is the name of the interface as displayed to the system
user. This name is also used to configure the main network and
the subnets.</p></li>
<li><p><em>phSubnet</em> is assigned by the router and identifies the interface in
the router. When the block driver receives a block and forwards
it to the router it must also forward this Id (see below).</p></li>
</ul>
<p>When the block driver receives a correct block on one of its network
interfaces, it notifies the router via the <em>RouterHandleData</em> function.
The function prototype is (again from <em>CrouterItf.h</em>):</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">RTS_RESULT</span> <span class="n">CDECL</span> <span class="n">RouterHandleData</span><span class="p">(</span><span class="n">RTS_HANDLE</span> <span class="n">hSubnet</span><span class="p">,</span>
<span class="n">NETWORKADDRESS</span> <span class="n">sender</span><span class="p">,</span> <span class="n">PROTOCOL_DATA_UNIT</span> <span class="n">pduData</span><span class="p">,</span> <span class="kt">int</span>
<span class="n">bIsBroadcast</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><em>hSubnet</em> must be the Id assigned by the router on interface
registration.</p></li>
<li><p><em>sender</em> is the network address of the sender.</p></li>
<li><p><em>pduData</em> contains the received block</p></li>
<li><p><em>bIsBroadcast</em> should set to 1, if the received block was sent to a
broadcast address.</p></li>
</ul>
</div>
<div class="section" id="addressing">
<span id="id1"></span><h2>5.5.8.3. Addressing<a class="headerlink" href="#addressing" title="Permalink to this headline">¶</a></h2>
<p>The block driver has as many bits available for network addresses as it
specified on registration with the router. A network address in which
all bits are set to 1 is reserved as a broadcast address. The same
applies to a network address of length 0. Blocks for these addresses
therefore have to be distributed to all subnet devices.</p>
<p><em>An example:</em> Addressing in the UDP block driver</p>
<p>An IP address consists of four components &lt;a&gt;.&lt;b&gt;.&lt;c&gt;.&lt;d&gt;. In a Class C
network the first three components are identical for all devices.
Therefore only the last byte (d) is used for the network address, i.e. 8
bits are sufficient. Blocks for 0xFF are sent to address &lt;a&gt;.&lt;b&gt;.&lt;c&gt;.FF
(local broadcast within the network).</p>
</div>
<div class="section" id="general-implementation-procedure">
<h2>5.5.8.4. General implementation procedure<a class="headerlink" href="#general-implementation-procedure" title="Permalink to this headline">¶</a></h2>
<p>A simple block driver simply responds to associated system hooks and
polls its network interfaces at regular intervals. Faster response times
can be achieved if the block driver responds directly to events in its
network hardware. This aspect is not covered in this documentation. As
reference implementation we recommend BlkDrvUdp (supplied with the
runtime system).</p>
<p>Once addressing has been specified (see <a class="reference internal" href="#addressing"><span class="std std-ref">comm_implementation_aids</span></a>), a send function must be
implemented based on the <em>PFBDSEND</em> function prototype. It should return
the following values:</p>
<ul class="simple">
<li><p><strong>ERR_OK</strong> if the block could be sent or at least copied to an
internal buffer</p></li>
<li><p><strong>ERR_NOBUFFER</strong> if the block could not be sent immediately and no
internal buffer is available for intermediate data storage.
During the next cycle the router will try sending the block again.</p></li>
<li><p><strong>ERR_FAILED</strong> if an error, such as an invalid address, for example,
permanently prevents a block being sent. In this case the router
will discard the block.</p></li>
</ul>
<p>The block driver should initialize its network interfaces in the
<em>CH_Init</em> hook and register them with the router.</p>
<p>In the <em>CH_CommCycle</em> hook the block driver should continue resending
blocks that were not sent completely and check whether a new block was
received. If a block was received it must be forwarded to the router via
the <em>RouterHandleData</em> function.</p>
</div>
<div class="section" id="synchronisation">
<h2>5.5.8.5. Synchronisation<a class="headerlink" href="#synchronisation" title="Permalink to this headline">¶</a></h2>
<p>In principle the send function of the block driver can be called from
different threads. It is therefore important to ensure adequate and
correct synchronization.</p>
<p>Critical code components should be secured through suitable semaphore or
similar mechanisms. It is particularly important to ensure that a call
of RouterHandleData can initiate another send operation. Deadlocks must
be avoided. Before a RouterHandleData call all semaphores should
therefore be enabled if possible.</p>
<p>In single-tasking systems the semaphore mechanisms of the system
libraries have been route-optimized and are therefore irrelevant for
performance considerations.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="comm_implement_own_driver.html" title="5.5.9. Implementation of Own Communication Driver"
             >next</a> |</li>
        <li class="right" >
          <a href="comm_gateway_and_client.html" title="5.5.7. Gateway and Client"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">RuntimeSystemDocumentation V3.5.16.40</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >5. Architecture Manual</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="communication.html" >5.5. Communication</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020, 3S-Smart Software Solutions GmbH. This document is confidential. Unauthorized copying, disclosure or distribution of this document and the information contained herein is strictly forbidden.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.2.1.
    </div>
  </body>
</html>