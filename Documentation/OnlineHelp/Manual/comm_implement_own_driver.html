

<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>5.5.9. Implementation of Own Communication Driver &#8212; RuntimeSystemDocumentation V3.5.16.40</title>
    <link rel="stylesheet" href="../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/theme.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="5.5.10. Standard block drivers and their network addresses" href="comm_standard_block_drivers.html" />
    <link rel="prev" title="5.5.8. Implementation Aids" href="comm_implementation_aids.html" /> 
  </head><body>
	<div id="header">
		<a href="#" title="CODESYS" target="_top" id="logo"><img src="../_static/logo.png" width="134" height="130" alt=""></a>
		<a href="#" title="CODESYS Documentation" target="_top" id="logo-store"><img src="../_static/logo2.png" width="137" height="130" alt=""></a>
	</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="comm_standard_block_drivers.html" title="5.5.10. Standard block drivers and their network addresses"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="comm_implementation_aids.html" title="5.5.8. Implementation Aids"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">RuntimeSystemDocumentation V3.5.16.40</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >5. Architecture Manual</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="communication.html" accesskey="U">5.5. Communication</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
  <h4>Previous topic</h4>
  <p class="topless"><a href="comm_implementation_aids.html"
                        title="previous chapter">5.5.8. Implementation Aids</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="comm_standard_block_drivers.html"
                        title="next chapter">5.5.10. Standard block drivers and their network addresses</a></p>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="implementation-of-own-communication-driver">
<span id="comm-implement-own-driver"></span><h1>5.5.9. Implementation of Own Communication Driver<a class="headerlink" href="#implementation-of-own-communication-driver" title="Permalink to this headline">¶</a></h1>
<p>In contrast to block drivers communication drivers are structured
asymmetrically, i.e. there is a clear distinction between a client (on
the client side) and a server (on the gateway side). The transfer
perspective is also different from that of block drivers: While block
drivers invariably send or receive whole blocks or nothing,
communication drivers provide an “endless” data stream. Communication
drivers therefore do not deliver received data directly to the
gateway/client. Instead they report receipt of the data, which can then
be retrieved by the higher-level layer in freely selectable portions as
required.</p>
<p>The fundamental principle of the send and receive functions is the same
on both sides. However, the client must be able to actively establish a
connection to the server, while server has to respond to incoming client
connections. In addition the client must support a plug-in mechanism for
generic configuration of the connection.</p>
<p>Both sides make a secure <strong>stream</strong> available. Data may be sent and
delivered in portions of any size. The only requirements are that the
data must arrive at the receiver correctly, fully and in the right
order. If necessary the communication driver must deal with packet
repetition, checksums etc. If data are not retrieved fast enough from
the driver, suitable flow control mechanisms should be provided to avoid
data loss. If data have to be discarded or cannot be transferred
correctly, the connection must be terminated since it violates the
stream principle. In addition the communication driver should be able to
detect connection interruptions independently.</p>
<p>A normal TCP connection precisely meets the requirements of
communication drivers and can therefore be regarded as reference.</p>
<div class="section" id="communication-driver-for-the-gateway">
<h2>5.5.9.1. Communication driver for the gateway<a class="headerlink" href="#communication-driver-for-the-gateway" title="Permalink to this headline">¶</a></h2>
<p>The communication driver for TCP, <em>CmpGWCommDrvTcp</em>, should be regarded
as reference implementation.</p>
<p>In its <em>Cgateway.h</em> interface the gateway component provides four
functions for operation by a communication driver:</p>
<ul class="simple">
<li><dl class="simple">
<dt><strong>GWRegisterCommDrv</strong></dt><dd><p>For registration of a communication driver with the gateway.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>GWClientConnect</strong></dt><dd><p>Notifies the gateway about the fact that a new connection
with a client was established.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>GWClientDisconnect</strong></dt><dd><p>Notifies the gateway about the fact that a connection to a
client was terminated.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>GWConnectionReady</strong></dt><dd><p>This callback notifies the gateway about the fact that new
data can be received via a connection or now further data can be
sent.</p>
</dd>
</dl>
</li>
</ul>
<p>These functions are described in more detail below.</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">Int</span> <span class="n">CDECL</span> <span class="n">GWRegisterCommDrv</span> <span class="p">(</span><span class="n">COMMDRVINFO</span> <span class="o">*</span><span class="n">pInfo</span><span class="p">,</span>
 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">pdwDriverId</span><span class="p">);</span>
<span class="k">typedef</span> <span class="k">struct</span>

<span class="p">{</span>
 <span class="n">PFCOMMDRVSEND</span> <span class="n">pfSend</span><span class="p">;</span>
 <span class="n">PFCOMMDRVRECEIVE</span> <span class="n">pfReceive</span><span class="p">;</span>
 <span class="n">PFCOMMDRVCLOSE</span> <span class="n">pfClose</span><span class="p">;</span>
<span class="p">}</span> <span class="n">COMMDRVINFO</span><span class="p">;</span>

<span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="n">CDECL</span> <span class="o">*</span><span class="n">PFCOMMDRVSEND</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dwConnHandle</span><span class="p">,</span>
<span class="n">PROTOCOL_DATA_UNIT</span> <span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">pdwSent</span><span class="p">);</span>

<span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="n">CDECL</span> <span class="o">*</span><span class="n">PFCOMMDRVRECEIVE</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dwConnHandle</span><span class="p">,</span>
<span class="n">PROTOCOL_DATA_UNIT</span> <span class="o">*</span><span class="n">pData</span><span class="p">);</span>

<span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="n">CDECL</span> <span class="o">*</span><span class="n">PFCOMMDRVCLOSE</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dwConnHandle</span><span class="p">);</span>
</pre></div>
</div>
<p>This function is used by a communication driver for registering at a
gateway. In pInfo the driver passes on three function pointers for
sending and receiving data and for terminating an existing connection.
<em>pdwDriverId</em> is set by the gateway and must be passed to the gateway
with all further calls as driver identification.</p>
<ul class="simple">
<li><p><strong>PFCOMMDRVSEND</strong>:
Sends data (<em>data</em>) via an existing connection (<em>dwConnHandle</em>).
<em>pdwSent</em> must be set by the communication driver to the number
of bytes that were actually sent (or copied to the internal send buffer).
If not all bytes could be sent, the gateway will resent the unsent data
during the next cycle.</p></li>
<li><p><strong>PFCOMMDRVRECEIVE</strong>
Reads data for a connection (<em>dwConnHandle</em>) from the receive buffer
of the communication driver. During a call <em>pData-&gt;ulCount</em> contains
the maximum number of data to be read.
Existing data have to be copied to <em>pData-&gt;pBuffer</em>, and
<em>pData-&gt;ulCount</em> has to be set to the number of actually read data.</p></li>
<li><p><strong>PFCOMMDRVCLOSE</strong>
Closes a connection (<em>dwConnHandle</em>). <em>GWClientDisconnect</em> must <em>not</em> be called.</p></li>
</ul>
<p>For all three functions the following applies:</p>
<p>The function must not block and must not call gateways functions (either
directly or indirectly), because this may lead to deadlocks that cannot
be rectified!</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">Int</span> <span class="n">CDECL</span> <span class="n">GWClientConnect</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dwDriverId</span><span class="p">,</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dwConnHandle</span><span class="p">);</span>
</pre></div>
</div>
<p>This function is called by the communication driver once it has
established an incoming connection from a client. <em>dwDriverId</em>
identifies the communication driver and was returned by the gateway at
<em>GWRegisterCommDrv</em>. <em>dwConnHandle</em> is a driver-specific handle for the
new connection and is transferred by the gateway for <em>send, receive</em> and
<em>close</em> calls.</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">Int</span> <span class="n">CDECL</span> <span class="n">GWClientDisconnect</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dwDriverId</span><span class="p">,</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dwConnHandle</span><span class="p">);</span>
</pre></div>
</div>
<p>This function is called by the communication driver if a connection to a
client was cancelled or terminated by the client. <em>dwDriverId</em>
identifies the communication driver and was returned by the gateway at
<em>GWRegisterCommDrv</em>. <em>dwConnHandle</em> is the driver-specific handle for
the terminated connection, which the driver had transferred at
<em>GWClientConnect.</em></p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">Int</span> <span class="n">CDECL</span> <span class="n">GWConnectionReady</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dwDriverHandle</span><span class="p">,</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dwConnHandle</span><span class="p">,</span>
<span class="kt">int</span> <span class="n">nAction</span><span class="p">);</span>
</pre></div>
</div>
<p>This function can optionally be called by the communication driver
(<em>dwDriverHandle</em>) if new data are available for a connection
(<em>dwConnHandle</em>) or data can be sent. <em>nAction can have one of the
following values:</em></p>
<ul class="simple">
<li><p>COMMDRV_ACTION_SEND: There are free send buffers, i.e. data can be sent again.</p></li>
<li><p>COMMDRV_ACTION_RECEIVE: New data are available in the receive buffer.</p></li>
</ul>
<p>The same condition should not be signaled more than once per connection
as long as the gateway has not responded. After a
<em>COMMDRV_ACTION_SEND</em> for instance, this signal may only be triggered
again after a <em>send</em> on this connection.</p>
</div>
<div class="section" id="communication-driver-for-the-client">
<h2>5.5.9.2. Communication driver for the client<a class="headerlink" href="#communication-driver-for-the-client" title="Permalink to this headline">¶</a></h2>
<p>The communication driver for TCP, in this case <em>CmpGWClientCommDrvTcp</em>,
should be regarded as reference implementation.</p>
<p>In its <em>CGWClientItf.h</em> interface a client provides two functions for
interaction with communication drivers:</p>
<ul class="simple">
<li><p><strong>GWClientRegisterCommDrv</strong>
To register a communication driver</p></li>
<li><p><strong>GWClientConnectionReady</strong>
Notifies the client that new data are available or the driver
is ready again to send data.</p></li>
</ul>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">Int</span> <span class="n">CDECL</span> <span class="n">GWClientRegisterCommDrv</span><span class="p">(</span><span class="n">COMMDRVITF</span> <span class="o">*</span><span class="n">pItf</span><span class="p">,</span>
<span class="n">COMMDRVINFO</span> <span class="o">*</span><span class="n">pDrvInfo</span><span class="p">,</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">pdwDriverHandle</span><span class="p">);</span>

<span class="k">typedef</span> <span class="k">struct</span>
 <span class="p">{</span>
  <span class="n">PFCOMMDRVBEGINCONNECT</span> <span class="n">pfBeginConnect</span><span class="p">;</span>
  <span class="n">PFCOMMDRVENDCONNECT</span> <span class="n">pfEndConnect</span><span class="p">;</span>
  <span class="n">PFCOMMDRVSEND</span> <span class="n">pfSend</span><span class="p">;</span>
  <span class="n">PFCOMMDRVRECEIVE</span> <span class="n">pfReceive</span><span class="p">;</span>
  <span class="n">PFCOMMDRVCLOSE</span> <span class="n">pfClose</span><span class="p">;</span>
 <span class="p">}</span><span class="n">COMMDRVITF</span><span class="p">;</span>

 <span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="n">CDECL</span> <span class="o">*</span><span class="n">PFCOMMDRVSEND</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dwConnHandle</span><span class="p">,</span>
  <span class="n">PROTOCOL_DATA_UNIT</span> <span class="n">data</span><span class="p">,</span>
  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">pdwSent</span><span class="p">);</span>

 <span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="n">CDECL</span> <span class="o">*</span><span class="n">PFCOMMDRVRECEIVE</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dwConnHandle</span><span class="p">,</span>
  <span class="n">PROTOCOL_DATA_UNIT</span> <span class="o">*</span><span class="n">pData</span><span class="p">,</span>
  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dwReceive</span><span class="p">);</span>

 <span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="n">CDECL</span> <span class="o">*</span><span class="n">PFCOMMDRVBEGINCONNECT</span><span class="p">)(</span><span class="n">PARAMLIST</span> <span class="o">*</span><span class="n">pParams</span><span class="p">,</span>
  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">pdwConnHandle</span><span class="p">,</span>
  <span class="n">ASYNCRESULT</span> <span class="o">*</span><span class="n">pAsyncRes</span><span class="p">);</span>

 <span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="n">CDECL</span> <span class="o">*</span><span class="n">PFCOMMDRVENDCONNECT</span><span class="p">)</span> <span class="p">(</span><span class="n">ASYNCRESULT</span>
   <span class="o">*</span><span class="n">pAsyncRes</span><span class="p">,</span>
 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">pdwConnHandle</span><span class="p">);</span>

 <span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="n">CDECL</span> <span class="o">*</span><span class="n">PFCOMMDRVCLOSE</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dwConnHandle</span><span class="p">);</span>

 <span class="k">typedef</span> <span class="k">struct</span> <span class="nc">tagASYNCRESULT</span>
 <span class="p">{</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">pUser</span><span class="p">;</span>
  <span class="n">PFASYNCCALLBACK</span> <span class="n">pfCallback</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ulEvent</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ulRequestId</span><span class="p">;</span>
 <span class="p">}</span><span class="n">ASYNCRESULT</span><span class="p">;</span>
 <span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="n">STDCALL</span> <span class="o">*</span><span class="n">PFASYNCCALLBACK</span><span class="p">)(</span><span class="n">ASYNCRESULT</span> <span class="o">*</span><span class="n">pAsyncRes</span><span class="p">);</span>
</pre></div>
</div>
<p>The <em>GWClientRegisterCommDrv</em> function registers a communication driver
with the client. <em>pdwDriverHandle</em> is set by the client and must be
passed on by the communication driver to the client with all other
calls. <em>pItf</em> contains function pointers to the communication driver
functions, while <em>pDrvInfo</em> contains information about the driver itself
and about the parameters required for establishing a connection.</p>
<p>Functions required for <em>pItf</em>:</p>
<ul class="simple">
<li><dl class="simple">
<dt><strong>PFCOMMDRVSEND</strong></dt><dd><p>Sends data (<em>data</em>) via an existing connection
(<em>dwConnHandle</em>). <em>pdwSent</em> must be set by the communication
driver to the number of bytes that were actually sent (or copied
to the internal send buffer). If not all bytes could be sent, the
client will resent the unsent data during the next cycle.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>PFCOMMDRVRECEIVE</strong></dt><dd><p>Reads data for a connection (<em>dwConnHandle</em>) from the receive
buffer of the communication driver. During a call
<em>pData-&gt;ulCount</em> contains the maximum number of data to be read.
Existing data have to be copied to <em>pData-&gt;pBuffer</em>, and
<em>pData-&gt;ulCount</em> has to be set to the number of actually read
data.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>PFCOMMDRVBEGINCONNECT</strong></dt><dd><p>This function initiates a connection setup. The parameter
<em>pParams</em> is described in <a class="reference internal" href="../Reference/struct_p_a_r_a_m_l_i_s_t.html#struct-p-a-r-a-m-l-i-s-t"><span class="std std-ref">PARAMLIST Struct Reference</span></a>, Connection parameters.
This function is blocking if <em>pAsyncRes == NULL</em>. Otherwise this
function must be non-blocking. Two cases can be distinguished:</p>
</dd>
</dl>
</li>
</ul>
<p><strong>pAsyncRes != NULL and connection cannot be established immediately</strong>
The function returns ERR_PENDING, <em>pdwConnHandle</em> is not touched. The
function initializes the following fields of <em>pAsyncResult</em>: <em>ulEvent</em>
is assigned a handle for a SysEvent; <em>ulRequestId</em> can be used by the
function as required for identifying this asynchronous request.
The connection now has to be established in the background (e.g. in
CH_COMMCYCLE or in a dedicated thread). As soon as the connection has
been established or failed the driver sets <em>ulEvent</em>. If
<em>pAsyncRes-&gt;pfCallback</em> <em>!= NULL,</em> the driver calls this callback
function.
The caller of the function can call the function PFCOMMDRVENDCONNECT
at any time, generally in <em>pAsyncRes-&gt;pfCallback</em> or after
<em>pAsyncRes-&gt;ulEvent</em> was set, in order to retrieve the result of the
connection setup.
The driver may <em>not</em> remember the pointer to <em>pAsyncRes</em>. Instead it
usually retains a copy of <em>*pAsyncRes. pAsyncRes-&gt;pUser</em> is set by
the caller and is not touched by the driver.</p>
<p><strong>Otherwise:</strong>
<em>pAsyncRes</em> is not touched. The function blocks until the connection
setup result is known. If successful, <em>pdwConnHandle</em> is set to the
handle of the new connection, otherwise the function returns the
associated error code.</p>
<ul class="simple">
<li><p><strong>PFCOMMDRVENDCONNECT</strong>
This function returns the result of a previous asynchronous
call of <em>PFCOMMDRVBEGINCONNECT</em>. It must be called exactly once
if the asynchronous call returned <em>ERR_PENDING</em>. In all other
cases, including multiple calls, an error is returned.
The function blocks until asynchronous connection setup is
complete, identified through <em>pAsyncRes-&gt;ulRequestId</em>. It then
returns the result in the same form as <em>PFCOMMDRVBEGINCONNECT</em>
in the synchronous case.</p></li>
<li><p><strong>PFCOMMDRVCLOSE</strong>
Closes a connection (<em>dwConnHandle</em>).</p></li>
</ul>
<p>The data required in <em>pDrvInfo</em> are described in <a class="reference internal" href="../Reference/group___cmp_gw_client_itf.html#group-cmp-gw-client-itf"><span class="std std-ref">CmpGwClientItf</span></a>, Connection
parameters.</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">Int</span> <span class="n">CDECL</span> <span class="n">GWClientConnectionReady</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dwDriverHandle</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dwConnHandle</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nAction</span><span class="p">);</span>
</pre></div>
</div>
<p>This function can optionally be called by the communication driver
(<em>dwDriverHandle</em>) if new data are available for a connection
(<em>dwConnHandle</em>) or data can be sent. nAction can have one of the
following values:</p>
<ul class="simple">
<li><p><strong>COMMDRV_ACTION_SEND</strong>
There are free send buffers, i.e. data can be sent again.</p></li>
<li><p><strong>COMMDRV_ACTION_RECEIVE</strong>
New data are available in the receive buffer.</p></li>
</ul>
<p>The same condition should not be signaled more than once per connection
as long as the client has not responded. After a <em>COMMDRV_ACTION_SEND</em>
for instance, this signal may only be triggered again after a <em>send</em> on
this connection.</p>
<div class="section" id="connection-parameters">
<h3>Connection parameters<a class="headerlink" href="#connection-parameters" title="Permalink to this headline">¶</a></h3>
<p>A connection to a gateway has to be parameterized in different ways,
depending on the communication driver. A TCP connection, for example,
requires the IP address and the port of the remote terminal, while a
serial connection requires the COM port, baud rate, stop bits etc. The
required parameters are therefore specified by the driver itself. Since
the driver handle may change depending on the installed drivers, each
driver is allocated a unique number that also unambiguously identifies
the driver, even on different computers.</p>
<p>The driver therefore describes itself with the parameter <em>pDrvInfo</em> on
registration. This structure is defined as follows:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
 <span class="n">COMMDRIVERHANDLE</span> <span class="n">hDriver</span><span class="p">;</span>
 <span class="n">GUID</span> <span class="n">guid</span><span class="p">;</span>
 <span class="kt">wchar_t</span> <span class="o">*</span><span class="n">pwszName</span><span class="p">;</span>
 <span class="n">PARAMDEFLIST</span> <span class="n">params</span><span class="p">;</span>
<span class="p">}</span><span class="n">COMMDRVINFO</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">COMMDRIVERHANDLE</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
 <span class="kt">int</span> <span class="n">nNumParams</span><span class="p">;</span>
 <span class="n">PARAMETERDEFINITION</span> <span class="o">*</span><span class="n">pParam</span><span class="p">;</span>
<span class="p">}</span><span class="n">PARAMDEFLIST</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
 <span class="kt">wchar_t</span> <span class="n">pwszName</span><span class="p">[</span><span class="n">MAX_PARAM_NAME</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dwParamId</span><span class="p">;</span>
 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dwType</span><span class="p">;</span> <span class="cm">/* PT_xxx */</span>
<span class="p">}</span><span class="n">PARAMETERDEFINITION</span><span class="p">;</span>
</pre></div>
</div>
<p><em>hDriver</em> is set by the client. This parameter is independent of the
driver. <em>Guid</em> is a GUID, as generated by the guidgen tool from
Microsoft, for example. The GUID must be recreated for each driver. It
identifies the driver across different client instances. <em>pwszName</em> is
the name of the driver. It is displayed in the configuration dialog of
the client, for example. <em>Params</em> defines the parameters required for
connection setup for this driver. These parameters are also displayed in
the generic configuration dialog of the client. Suitable names should
therefore be chosen.</p>
<p><em>PARAMDEFLIST</em> is a list of parameters required for the driver. It
includes the number of required parameters (<em>nNumParams</em>) and an array
of <em>nNumParams</em> parameter definitions (<em>pParam</em>).</p>
<p>A PARAMETER DEFINITION describes an individual parameter through a name
(<em>pwszName</em>), Id (<em>dwParamId</em>, must be unique within the driver), and
type. Types are defined by PT_xxx (e.g. PT_CHAR, PT_INT16,
PT_string, …) constants in file <em>CGWClientItf.h</em>. All common numeric
data types and strings are available.</p>
<p>An example:</p>
<p>The communication driver for TCP requires two parameters. One <em>IP
address</em> parameter with Id 0 that either contains the address or the DNS
name of the gateway as a string, and one <em>Port</em> parameter, a 16-bit
value with Id 1 that specifies the port for the gateway. The parameter
array for the definition has the following structure:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">PARAMETERDEFINITION</span> <span class="n">s_ParamDefinitions</span><span class="p">[]</span> <span class="o">=</span>
   <span class="p">{</span>
     <span class="p">{</span><span class="sa">L</span><span class="s">&quot;IP-Address&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">PT_string</span><span class="p">},</span>
     <span class="p">{</span><span class="sa">L</span><span class="s">&quot;Port&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">PT_uint16</span><span class="p">}</span>
   <span class="p">};</span>
</pre></div>
</div>
<p>From this list the client generates a parameter list (<em>pParams</em>) during
connection setup (<em>PFCOMMDRVBEGINCONNECT</em>) containing specific values
for the individual parameters. The values are transferred as pointers to
the type corresponding to the parameter definition <em>(short</em>, int*,
…)*. Strings are transferred in the usual way as pointers to the first
element of the string, i.e. as <em>char*</em>. The parameter list is defined
as follows:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
 <span class="kt">int</span> <span class="n">nNumParams</span><span class="p">;</span>
 <span class="n">PARAMETER</span> <span class="o">*</span><span class="n">pParam</span><span class="p">;</span>
<span class="p">}</span><span class="n">PARAMLIST</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dwParamId</span><span class="p">;</span>
 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">type</span><span class="p">;</span>
 <span class="kt">void</span> <span class="o">*</span> <span class="n">pValue</span><span class="p">;</span>
<span class="p">}</span><span class="n">PARAMETER</span><span class="p">;</span>
</pre></div>
</div>
<p>An example:</p>
<p>The following code establishes a connection to gateway 192.168.100.70 on
port 1217 using the TCP communication driver from the previous example.
In the interest of transparency the configuration is static in this case
and uses the parameter definition of the communication driver described
above. In real applications the list is generated dynamically based on
the user inputs and the parameter definition of the driver.</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>Int nResult;
unsigned long ulConnHandle;
ASYNCRESULT async = {NULL,NULL,0,0};
char stAddr[] = &quot;192.168.100.70&quot;;
unsigned short usPort = &quot;1217&quot;;
PARAMETER params[2] =
{
 {0, PT_string, stAddr}, /* stAddr is already a pointer */
 {1, PT_uint16, &amp;usPort} /* numeric values as pointer on value */
   }
   PARAMLIST list = {2, params};
   nResult = pfCommDrvBeginConnect(&amp;list, &amp;ulConnHandle, &amp;async);
   if(nResult == ERR_PENDING)
   {
    CAL_SysEventWait(async.ulEvent, -1); /* Wait until finished */
    nResult = pfCommDrvEndConnect(&amp;async, &amp;ulConnHandle);
   }
   if(nResult == ERR_OK)
   {
   /* Send and receive data */
   …
   pfCommDrvClose(ulConnHandle);
   }
   …
</pre></div>
</div>
</div>
<div class="section" id="implementation-of-beginconnect">
<h3>Implementation of BeginConnect<a class="headerlink" href="#implementation-of-beginconnect" title="Permalink to this headline">¶</a></h3>
<p>The following code snippet illustrates the basic structure of the
CommDrvBeginConnect and CommDrvEndConnect functions with correct
handling of the <em>pAsyncResult</em> parameter. While other implementations
are conceivable and indeed often desirable, connection setup is always
asynchronous in the example. For the case <em>pAsyncRes</em> == <em>NULL</em> an
additional short code snippet is included that converts the asynchronous
function into a synchronous function through the function
<em>CommDrvBeginConnect</em> recalling itself recursively and then blocking
itself by calling <em>CommDrvEndConnect</em>. In the synchronous case
CommCycleHook may therefore be blocked. In this implementation a
separate thread must therefore be used for asynchronous connection
setup.</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">Int</span> <span class="nf">BeginConnect</span><span class="p">(</span><span class="n">PARAMLIST</span> <span class="o">*</span><span class="n">pList</span><span class="p">,</span> <span class="n">ulong</span> <span class="o">*</span><span class="n">pdwHandle</span><span class="p">,</span> <span class="n">ASYNCRESULT</span> <span class="o">*</span><span class="n">pAsyncRes</span><span class="p">)</span>
<span class="p">{</span>
 <span class="kt">int</span> <span class="n">nRes</span><span class="p">;</span>
 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ulReqId</span><span class="p">;</span>
 <span class="k">if</span><span class="p">(</span><span class="n">pAsyncRes</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
 <span class="p">{</span>
  <span class="n">AsyncRes</span> <span class="n">async</span> <span class="o">=</span> <span class="p">{</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
  <span class="n">nRes</span> <span class="o">=</span> <span class="n">BeginConnect</span><span class="p">(</span><span class="n">pList</span><span class="p">,</span> <span class="n">pdwHandle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">async</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="n">nRes</span> <span class="o">==</span> <span class="n">ERR_PENDING</span><span class="p">)</span>
  <span class="n">nRes</span> <span class="o">=</span> <span class="n">EndConnect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">async</span><span class="p">,</span> <span class="n">pdwHandle</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">nRes</span><span class="p">;</span>
 <span class="p">}</span>
 <span class="n">CheckParameters</span><span class="p">(</span><span class="n">pList</span><span class="p">);</span> <span class="c1">// All available? Correct types?</span>
 <span class="n">ulReqId</span> <span class="o">=</span> <span class="n">StartAsyncConnect</span><span class="p">(</span><span class="n">pList</span><span class="p">);</span>
 <span class="n">pAsyncRes</span><span class="o">-&gt;</span><span class="n">ulRequestId</span> <span class="o">=</span> <span class="n">ulReqId</span><span class="p">;</span>
 <span class="n">pAsyncRes</span><span class="o">-&gt;</span><span class="n">ulEvent</span> <span class="o">=</span> <span class="n">SysEventCreate</span><span class="p">(</span><span class="n">LongToString</span><span class="p">(</span><span class="n">ulReqId</span><span class="p">));</span>
 <span class="n">AddPendingRequest</span><span class="p">(</span><span class="o">*</span><span class="n">pAsyncRes</span><span class="p">);</span>
 <span class="k">return</span> <span class="n">ERR_PENDING</span><span class="p">;</span>
<span class="p">}</span>

 <span class="kt">int</span> <span class="nf">EndConnect</span><span class="p">(</span><span class="n">ASYNCRESULT</span> <span class="o">*</span><span class="n">pAsyncRes</span><span class="p">,</span> <span class="n">ulong</span> <span class="o">*</span><span class="n">pdwHandle</span><span class="p">)</span>
 <span class="p">{</span>
  <span class="n">Request</span> <span class="n">req</span><span class="p">;</span>
  <span class="n">req</span> <span class="o">=</span> <span class="n">GetPendingRequest</span><span class="p">(</span><span class="n">pAsyncRes</span><span class="o">-&gt;</span><span class="n">ulRequestId</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="n">req</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">ERR_PARAMETER</span><span class="p">;</span>
  <span class="n">SysEventWait</span><span class="p">(</span><span class="n">req</span><span class="p">.</span><span class="n">asyncRes</span><span class="p">.</span><span class="n">ulEvent</span><span class="p">,</span> <span class="mi">-1</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="n">req</span><span class="p">.</span><span class="n">result</span> <span class="o">==</span> <span class="n">ERR_OK</span><span class="p">)</span>
  <span class="o">*</span><span class="n">pdwHandle</span> <span class="o">=</span> <span class="n">req</span><span class="p">.</span><span class="n">handle</span><span class="p">;</span>
  <span class="n">RemovePendingRequest</span><span class="p">(</span><span class="n">pAsyncRes</span><span class="o">-&gt;</span><span class="n">ulRequestId</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">req</span><span class="p">.</span><span class="n">result</span><span class="p">;</span>
 <span class="p">}</span>
  <span class="cm">/* Callback example. We assume that this function is called by</span>
<span class="cm">     the network layer, for example, as soon as connection setup was</span>
<span class="cm">     either completed or has failed.</span>
<span class="cm">     The function is intended to indicate driver behavior required for</span>
<span class="cm">     signaling the end of the asynchronous call to the client</span>
<span class="cm">     application.</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">OnConnectFinished</span><span class="p">(</span><span class="kt">int</span> <span class="n">reqId</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nResult</span><span class="p">,</span> <span class="n">ulong</span> <span class="n">ulHandle</span><span class="p">)</span>
 <span class="p">{</span>
  <span class="n">Request</span> <span class="n">req</span><span class="p">;</span>
  <span class="n">req</span> <span class="o">=</span> <span class="n">GetPendingRequest</span><span class="p">(</span><span class="n">reqId</span><span class="p">);</span>
  <span class="n">req</span><span class="p">.</span><span class="n">result</span> <span class="o">=</span> <span class="n">nResult</span><span class="p">;</span>
  <span class="n">req</span><span class="p">.</span><span class="n">handle</span> <span class="o">=</span> <span class="n">ulHandle</span><span class="p">;</span>
  <span class="n">SysEventSet</span><span class="p">(</span><span class="n">req</span><span class="p">.</span><span class="n">asyncRes</span><span class="p">.</span><span class="n">ulEvent</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="n">req</span><span class="p">.</span><span class="n">asyncRes</span><span class="p">.</span><span class="n">pfCallback</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
  <span class="n">req</span><span class="p">.</span><span class="n">asyncRes</span><span class="p">.</span><span class="n">pfCallback</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">req</span><span class="p">.</span><span class="n">asyncRes</span><span class="p">));</span>
 <span class="p">}</span>
</pre></div>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="comm_standard_block_drivers.html" title="5.5.10. Standard block drivers and their network addresses"
             >next</a> |</li>
        <li class="right" >
          <a href="comm_implementation_aids.html" title="5.5.8. Implementation Aids"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">RuntimeSystemDocumentation V3.5.16.40</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >5. Architecture Manual</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="communication.html" >5.5. Communication</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020, 3S-Smart Software Solutions GmbH. This document is confidential. Unauthorized copying, disclosure or distribution of this document and the information contained herein is strictly forbidden.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.2.1.
    </div>
  </body>
</html>