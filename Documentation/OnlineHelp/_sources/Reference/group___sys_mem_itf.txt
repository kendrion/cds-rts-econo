.. first line of composition.rst template

.. first line of group.rst template

.. _group___sys_mem_itf:

=========
SysMemItf
=========

Interface of SysMem. :ref:`More... <group___sys_mem_itf-details>`

Modules
-------

- :ref:`Area Types <group___sys_mem_itf___area_types>`

- :ref:`Settings <group___sys_mem_itf___settings>`

- :ref:`Static defines <group___sys_mem_itf___staticdefines>`

Data Structures
---------------

- struct :ref:`tagsysmemallocarea_struct <structtagsysmemallocarea__struct>`

- struct :ref:`tagsysmemalloccode_struct <structtagsysmemalloccode__struct>`

- struct :ref:`tagsysmemallocdata_struct <structtagsysmemallocdata__struct>`

- struct :ref:`tagsysmemcmp_struct <structtagsysmemcmp__struct>`

- struct :ref:`tagsysmemcpy_struct <structtagsysmemcpy__struct>`

- struct :ref:`tagsysmemforceswap_struct <structtagsysmemforceswap__struct>`

- struct :ref:`tagsysmemfreearea_struct <structtagsysmemfreearea__struct>`

- struct :ref:`tagsysmemfreecode_struct <structtagsysmemfreecode__struct>`

- struct :ref:`tagsysmemfreedata_struct <structtagsysmemfreedata__struct>`

- struct :ref:`tagsysmemgetcurrentheapsize_struct <structtagsysmemgetcurrentheapsize__struct>`

- struct :ref:`tagsysmemisvalidpointer_struct <structtagsysmemisvalidpointer__struct>`

- struct :ref:`tagsysmemmove_struct <structtagsysmemmove__struct>`

- struct :ref:`tagsysmemreallocdata_struct <structtagsysmemreallocdata__struct>`

- struct :ref:`tagsysmemset_struct <structtagsysmemset__struct>`

- struct :ref:`tagsysmemswap_struct <structtagsysmemswap__struct>`

- struct :ref:`ISysMem_C <struct_i_sys_mem___c>`

Macros
------

- #define :ref:`ITF_SysMem <group___sys_mem_itf_1ga518377cee9b598ae4c33c4e36bb4638e>`

- #define :ref:`EXTITF_SysMem <group___sys_mem_itf_1ga077fe52c5838d09ec79a85897c10832e>`

Typedefs
--------

- typedef struct :ref:`tagsysmemallocarea_struct <structtagsysmemallocarea__struct>` :ref:`sysmemallocarea_struct <group___sys_mem_itf_1ga8afaf2523e5806d88481724855a0046c>`

- typedef struct :ref:`tagsysmemalloccode_struct <structtagsysmemalloccode__struct>` :ref:`sysmemalloccode_struct <group___sys_mem_itf_1gae060a4b21d8f50f86ec6e10ae1ad346d>`

- typedef struct :ref:`tagsysmemallocdata_struct <structtagsysmemallocdata__struct>` :ref:`sysmemallocdata_struct <group___sys_mem_itf_1ga5ae81e3ca0a345e5a588e72ed64c8863>`

- typedef struct :ref:`tagsysmemcmp_struct <structtagsysmemcmp__struct>` :ref:`sysmemcmp_struct <group___sys_mem_itf_1gaf4632cf710bb2867d44d124027b92d47>`

- typedef struct :ref:`tagsysmemcpy_struct <structtagsysmemcpy__struct>` :ref:`sysmemcpy_struct <group___sys_mem_itf_1ga2463b9ece5670be8fa29d5971ff2c95f>`

- typedef struct :ref:`tagsysmemforceswap_struct <structtagsysmemforceswap__struct>` :ref:`sysmemforceswap_struct <group___sys_mem_itf_1ga24ed851a673200e2ed397d6363c43f71>`

- typedef struct :ref:`tagsysmemfreearea_struct <structtagsysmemfreearea__struct>` :ref:`sysmemfreearea_struct <group___sys_mem_itf_1gabb6ef676543c7252110ed7a29bbb892a>`

- typedef struct :ref:`tagsysmemfreecode_struct <structtagsysmemfreecode__struct>` :ref:`sysmemfreecode_struct <group___sys_mem_itf_1gaaafb56830ac9c5a197e308ce540b0d83>`

- typedef struct :ref:`tagsysmemfreedata_struct <structtagsysmemfreedata__struct>` :ref:`sysmemfreedata_struct <group___sys_mem_itf_1ga8b14a664dc28814d65efc769e706e79d>`

- typedef struct :ref:`tagsysmemgetcurrentheapsize_struct <structtagsysmemgetcurrentheapsize__struct>` :ref:`sysmemgetcurrentheapsize_struct <group___sys_mem_itf_1ga196ab93b89a8a69159462b85a4bf5720>`

- typedef struct :ref:`tagsysmemisvalidpointer_struct <structtagsysmemisvalidpointer__struct>` :ref:`sysmemisvalidpointer_struct <group___sys_mem_itf_1gaee6232bf40273389df25caecdcd3ec99>`

- typedef struct :ref:`tagsysmemmove_struct <structtagsysmemmove__struct>` :ref:`sysmemmove_struct <group___sys_mem_itf_1gaecb6d101723f83e0ed8fd19676bb11ed>`

- typedef struct :ref:`tagsysmemreallocdata_struct <structtagsysmemreallocdata__struct>` :ref:`sysmemreallocdata_struct <group___sys_mem_itf_1ga0cec4bf41fbd0420008575436a91486d>`

- typedef struct :ref:`tagsysmemset_struct <structtagsysmemset__struct>` :ref:`sysmemset_struct <group___sys_mem_itf_1ga419f68ab97b5eb63f216c6cbc802f382>`

- typedef struct :ref:`tagsysmemswap_struct <structtagsysmemswap__struct>` :ref:`sysmemswap_struct <group___sys_mem_itf_1gaebb64f077680a25e61c3738c5d91f450>`

- typedef :ref:`ISysMem_C <struct_i_sys_mem___c>` :ref:`ISysMem <group___sys_mem_itf_1ga0667306fbdd90d944f5df7d1a7c1b4ed>`

Functions
---------

- void :ref:`sysmemallocarea <group___sys_mem_itf_1gaa55daea9b004df5a78c2868e174ae7ce>` (:ref:`sysmemallocarea_struct <group___sys_mem_itf_1ga8afaf2523e5806d88481724855a0046c>` * p)

- void :ref:`sysmemalloccode <group___sys_mem_itf_1ga4dc18c1bdbf4b355fe281184b026b437>` (:ref:`sysmemalloccode_struct <group___sys_mem_itf_1gae060a4b21d8f50f86ec6e10ae1ad346d>` * p)

- void :ref:`sysmemallocdata <group___sys_mem_itf_1ga9be7fc4ab21668bd2d812975c787a57d>` (:ref:`sysmemallocdata_struct <group___sys_mem_itf_1ga5ae81e3ca0a345e5a588e72ed64c8863>` * p)

- void :ref:`sysmemcmp <group___sys_mem_itf_1ga0252a63a3f02ceeb78403a4febcdb3ef>` (:ref:`sysmemcmp_struct <group___sys_mem_itf_1gaf4632cf710bb2867d44d124027b92d47>` * p)

- void :ref:`sysmemcpy <group___sys_mem_itf_1gaf40b759810e746fd3fa955f16cf22533>` (:ref:`sysmemcpy_struct <group___sys_mem_itf_1ga2463b9ece5670be8fa29d5971ff2c95f>` * p)

- void :ref:`sysmemforceswap <group___sys_mem_itf_1ga4d7d5136b8c20129d8c46ccb6c12a1e9>` (:ref:`sysmemforceswap_struct <group___sys_mem_itf_1ga24ed851a673200e2ed397d6363c43f71>` * p)

- void :ref:`sysmemfreearea <group___sys_mem_itf_1ga616d71aaaee90cc73db5fed199f88587>` (:ref:`sysmemfreearea_struct <group___sys_mem_itf_1gabb6ef676543c7252110ed7a29bbb892a>` * p)

- void :ref:`sysmemfreecode <group___sys_mem_itf_1ga9a95e6d10f2c6651c5b9619576d605c7>` (:ref:`sysmemfreecode_struct <group___sys_mem_itf_1gaaafb56830ac9c5a197e308ce540b0d83>` * p)

- void :ref:`sysmemfreedata <group___sys_mem_itf_1gabfe64f2196de4032c701f1c7f1c961fc>` (:ref:`sysmemfreedata_struct <group___sys_mem_itf_1ga8b14a664dc28814d65efc769e706e79d>` * p)

- void :ref:`sysmemgetcurrentheapsize <group___sys_mem_itf_1ga8a0b5b45c43150e6ef4bcb83adb87135>` (:ref:`sysmemgetcurrentheapsize_struct <group___sys_mem_itf_1ga196ab93b89a8a69159462b85a4bf5720>` * p)

- void :ref:`sysmemisvalidpointer <group___sys_mem_itf_1ga61681e8c33fc68a60258600196aaec37>` (:ref:`sysmemisvalidpointer_struct <group___sys_mem_itf_1gaee6232bf40273389df25caecdcd3ec99>` * p)

- void :ref:`sysmemmove <group___sys_mem_itf_1gac8722f0e76df67526d3500b9f86eb747>` (:ref:`sysmemmove_struct <group___sys_mem_itf_1gaecb6d101723f83e0ed8fd19676bb11ed>` * p)

- void :ref:`sysmemreallocdata <group___sys_mem_itf_1ga8b2ab0a2ed0d0c778938934463e87347>` (:ref:`sysmemreallocdata_struct <group___sys_mem_itf_1ga0cec4bf41fbd0420008575436a91486d>` * p)

- void :ref:`sysmemset <group___sys_mem_itf_1ga3d1fa596ed04c4ce61ded5f70d5b8428>` (:ref:`sysmemset_struct <group___sys_mem_itf_1ga419f68ab97b5eb63f216c6cbc802f382>` * p)

- void :ref:`sysmemswap <group___sys_mem_itf_1ga04810c5739c2dd3c5fd8bc2f575940c9>` (:ref:`sysmemswap_struct <group___sys_mem_itf_1gaebb64f077680a25e61c3738c5d91f450>` * p)

- RTS_RESULT :ref:`SysMemOSInit <group___sys_mem_itf_1gaa8386a4d545b44f1ca2733aa31bfb891>` (INIT_STRUCT * pInit)

- RTS_RESULT :ref:`SysMemOSHookFunction <group___sys_mem_itf_1gaa309717bad44320b73c0ebb0b553d129>` (RTS_UI32 ulHook, RTS_UINTPTR ulParam1, RTS_UINTPTR ulParam2)

- void * :ref:`SysMemAllocData <group___sys_mem_itf_1gac86cb3a6875b73f207e0c14292b96e4e>` (char * pszComponentName, RTS_SIZE ulSize, RTS_RESULT * pResult)

- void * :ref:`SysMemReallocData <group___sys_mem_itf_1gac803284edcb99a3d288904f27349a761>` (char * pszComponentName, void * pData, RTS_SIZE ulSize, RTS_RESULT * pResult)

- RTS_RESULT :ref:`SysMemFreeData <group___sys_mem_itf_1ga2ed61c79d0610fcf07f89582f2cba1da>` (char * pszComponentName, void * pData)

- void * :ref:`SysMemAllocArea <group___sys_mem_itf_1ga7ba42e875fb5a4b94adf7a98597675d8>` (char * pszComponentName, unsigned short usType, RTS_SIZE ulSize, RTS_RESULT * pResult)

- RTS_RESULT :ref:`SysMemFreeArea <group___sys_mem_itf_1gac601bc9910fc46027d782ac9f1a75ab8>` (char * pszComponentName, void * pData)

- void * :ref:`SysMemAllocCode <group___sys_mem_itf_1ga8d5e3cdf2959853e263068788ae612a7>` (char * pszComponentName, RTS_SIZE ulSize, RTS_RESULT * pResult)

- RTS_RESULT :ref:`SysMemFreeCode <group___sys_mem_itf_1ga2fe60fc89792ced09b6a86f47a57a3bd>` (char * pszComponentName, void * pCode)

- RTS_RESULT :ref:`SysMemIsValidPointer <group___sys_mem_itf_1ga3b6dfb1099dbb85bcaf196b13254c75e>` (void * ptr, RTS_SIZE ulSize, int bWrite)

- int :ref:`SysMemSwap <group___sys_mem_itf_1ga6407a80e389a69fb52881cc664a1b171>` (unsigned char * pbyBuffer, int iSize, int iCount)

- int :ref:`SysMemForceSwap <group___sys_mem_itf_1ga098f0a5b0146da61aa1c206dbae76e7d>` (unsigned char * pbyBuffer, int iSize, int iCount)

- RTS_SIZE :ref:`SysMemGetCurrentHeapSize <group___sys_mem_itf_1gac9ede21074e5918f3f84a2b74c1a5951>` (RTS_RESULT * pResult)

.. _group___sys_mem_itf-details:

Detailed Description
--------------------

Interface of SysMem.

The SysMem interface is projected to get access to heap memory or special memory areas for the plc program.

**Copyright:**

Copyright (c) 2017-2018 CODESYS GmbH, Copyright (c) 1994-2016 3S-Smart Software Solutions GmbH. All rights reserved.

Macro Definition Documentation
------------------------------
.. _group___sys_mem_itf_1ga518377cee9b598ae4c33c4e36bb4638e:

#define ITF_SysMem
^^^^^^^^^^^^^^^^^^

.. _group___sys_mem_itf_1ga077fe52c5838d09ec79a85897c10832e:

#define EXTITF_SysMem
^^^^^^^^^^^^^^^^^^^^^

Typedef Documentation
---------------------

.. _group___sys_mem_itf_1ga8afaf2523e5806d88481724855a0046c:

typedef struct tagsysmemallocarea_struct  sysmemallocarea_struct
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

EXTERN LIB SECTION BEGIN

Reserved function for the runtime system! Should not be used by an IEC application!

.. _group___sys_mem_itf_1gae060a4b21d8f50f86ec6e10ae1ad346d:

typedef struct tagsysmemalloccode_struct  sysmemalloccode_struct
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Reserved function for the runtime system! Should not be used by an IEC application!

.. _group___sys_mem_itf_1ga5ae81e3ca0a345e5a588e72ed64c8863:

typedef struct tagsysmemallocdata_struct  sysmemallocdata_struct
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Allocates data memory of the specified size RETURN: Pointer to the memory block. 0 if no memory is not available

.. _group___sys_mem_itf_1gaf4632cf710bb2867d44d124027b92d47:

typedef struct tagsysmemcmp_struct  sysmemcmp_struct
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Compares the content of two buffers RETURN: Returns 0 if the buffer contents are equal, else !=0

.. _group___sys_mem_itf_1ga2463b9ece5670be8fa29d5971ff2c95f:

typedef struct tagsysmemcpy_struct  sysmemcpy_struct
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Copy the content from source (pSrc) to destination buffer (pDest) RETURN: Pointer to the destination buffer, where the copy was done

.. _group___sys_mem_itf_1ga24ed851a673200e2ed397d6363c43f71:

typedef struct tagsysmemforceswap_struct  sysmemforceswap_struct
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Routine to force swapping memory independant of the byteorder of the system! RETURN: Number of bytes swapped: + -1 = failed (size too large) + >0 = Number of bytes swapped

.. _group___sys_mem_itf_1gabb6ef676543c7252110ed7a29bbb892a:

typedef struct tagsysmemfreearea_struct  sysmemfreearea_struct
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Reserved function for the runtime system! Should not be used by an IEC application! RETURN: Error code

.. _group___sys_mem_itf_1gaaafb56830ac9c5a197e308ce540b0d83:

typedef struct tagsysmemfreecode_struct  sysmemfreecode_struct
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Reserved function for the runtime system! Should not be used by an IEC application! RETURN: Error code

.. _group___sys_mem_itf_1ga8b14a664dc28814d65efc769e706e79d:

typedef struct tagsysmemfreedata_struct  sysmemfreedata_struct
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Release data memory RETURN: Returns the runtime system error code (see CmpErrors_Itfs.library)

.. _group___sys_mem_itf_1ga196ab93b89a8a69159462b85a4bf5720:

typedef struct tagsysmemgetcurrentheapsize_struct  sysmemgetcurrentheapsize_struct
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Routine to get total size of the currently allocated heap memory RETURN: Size of the memory in bytes that is currently allocated from the heap

.. _group___sys_mem_itf_1gaee6232bf40273389df25caecdcd3ec99:

typedef struct tagsysmemisvalidpointer_struct  sysmemisvalidpointer_struct
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Check if a pointer points to a valid address RETURN: Returns the runtime system error code (see CmpErrors_Itfs.library): + ERR_OK: Memory is valid + ERR_FAILED: Memory is invalid. Cannot be accessed with the requested access mode bWrite

.. _group___sys_mem_itf_1gaecb6d101723f83e0ed8fd19676bb11ed:

typedef struct tagsysmemmove_struct  sysmemmove_struct
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Copy the content from source (pSrc) to destination buffer (pDest). This routine works for overlapping buffers too in opposite to SysMemCpy! RETURN: Pointer to the destination buffer, where the move was done

.. _group___sys_mem_itf_1ga0cec4bf41fbd0420008575436a91486d:

typedef struct tagsysmemreallocdata_struct  sysmemreallocdata_struct
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Reallocate data memory with the specified size. By use of this function the size of a memory block can be modified (reallocation). Therefor a pointer on the memory block to be reallocated is passed to the function. The content of the memory block will not be modified. If the requested memory size cannot made available at the same place (address) , the function will allocate new memory space, RETURN: Pointer to the memory block. 0 if no memory is not available

.. _group___sys_mem_itf_1ga419f68ab97b5eb63f216c6cbc802f382:

typedef struct tagsysmemset_struct  sysmemset_struct
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

By use of this function a memory space is initialized with a specified value RETURN: Pointer to the memory block which was initialized. 0 if the operation failed

.. _group___sys_mem_itf_1gaebb64f077680a25e61c3738c5d91f450:

typedef struct tagsysmemswap_struct  sysmemswap_struct
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Routine to swap memory into littel endian. If little endian (intel) byteorder is received and platform has big endian (motorola) byteorder. On little endian byteorder platforms, routine does nothing RETURN: Number of bytes swapped: + -1 = failed (iSize too large) + 0 = no swapping necessary (little endian byteorder) + >0 = Number of bytes swapped (big endian byteorder)

.. _group___sys_mem_itf_1ga0667306fbdd90d944f5df7d1a7c1b4ed:

typedef ISysMem_C ISysMem
^^^^^^^^^^^^^^^^^^^^^^^^^

Function Documentation
----------------------

.. _group___sys_mem_itf_1gaa55daea9b004df5a78c2868e174ae7ce:

void sysmemallocarea (sysmemallocarea_struct *p)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. _group___sys_mem_itf_1ga4dc18c1bdbf4b355fe281184b026b437:

void sysmemalloccode (sysmemalloccode_struct *p)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. _group___sys_mem_itf_1ga9be7fc4ab21668bd2d812975c787a57d:

void sysmemallocdata (sysmemallocdata_struct *p)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. _group___sys_mem_itf_1ga0252a63a3f02ceeb78403a4febcdb3ef:

void sysmemcmp (sysmemcmp_struct *p)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. _group___sys_mem_itf_1gaf40b759810e746fd3fa955f16cf22533:

void sysmemcpy (sysmemcpy_struct *p)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. _group___sys_mem_itf_1ga4d7d5136b8c20129d8c46ccb6c12a1e9:

void sysmemforceswap (sysmemforceswap_struct *p)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. _group___sys_mem_itf_1ga616d71aaaee90cc73db5fed199f88587:

void sysmemfreearea (sysmemfreearea_struct *p)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. _group___sys_mem_itf_1ga9a95e6d10f2c6651c5b9619576d605c7:

void sysmemfreecode (sysmemfreecode_struct *p)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. _group___sys_mem_itf_1gabfe64f2196de4032c701f1c7f1c961fc:

void sysmemfreedata (sysmemfreedata_struct *p)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. _group___sys_mem_itf_1ga8a0b5b45c43150e6ef4bcb83adb87135:

void sysmemgetcurrentheapsize (sysmemgetcurrentheapsize_struct *p)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. _group___sys_mem_itf_1ga61681e8c33fc68a60258600196aaec37:

void sysmemisvalidpointer (sysmemisvalidpointer_struct *p)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. _group___sys_mem_itf_1gac8722f0e76df67526d3500b9f86eb747:

void sysmemmove (sysmemmove_struct *p)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. _group___sys_mem_itf_1ga8b2ab0a2ed0d0c778938934463e87347:

void sysmemreallocdata (sysmemreallocdata_struct *p)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. _group___sys_mem_itf_1ga3d1fa596ed04c4ce61ded5f70d5b8428:

void sysmemset (sysmemset_struct *p)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. _group___sys_mem_itf_1ga04810c5739c2dd3c5fd8bc2f575940c9:

void sysmemswap (sysmemswap_struct *p)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. _group___sys_mem_itf_1gaa8386a4d545b44f1ca2733aa31bfb891:

RTS_RESULT SysMemOSInit (INIT_STRUCT *pInit)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

EXTERN LIB SECTION END

Init routines for OS specific modules

**Parameters**

+---------+-------+-------------------------------------+
| [in]    | pInit | Init Struct for OS specific modules |
+---------+-------+-------------------------------------+

**Returns:**

Result of Initialisation.

.. _group___sys_mem_itf_1gaa309717bad44320b73c0ebb0b553d129:

RTS_RESULT SysMemOSHookFunction (RTS_UI32 ulHook, RTS_UINTPTR ulParam1, RTS_UINTPTR ulParam2)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Hook Function for OS specific modules

**Parameters**

+---------+----------+-----------------------------------------------+
| [in]    | ulHook   | Hook Type for OS specific modules             |
+---------+----------+-----------------------------------------------+
| [in]    | ulParam1 | First Hook Parameter for OS specific modules  |
+---------+----------+-----------------------------------------------+
| [in]    | ulParam2 | Second Hook Parameter for OS specific modules |
+---------+----------+-----------------------------------------------+

**Returns:**

Result of OS Hook.

.. _group___sys_mem_itf_1gac86cb3a6875b73f207e0c14292b96e4e:

void* SysMemAllocData (char *pszComponentName, RTS_SIZE ulSize, RTS_RESULT *pResult)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Allocates data memory of the specified size. IMPLEMENTATION NOTE: New allocated memory must be initialized with 0!

**Parameters**

+---------+------------------+------------------------------+
| [in]    | pszComponentName | Name of the component        |
+---------+------------------+------------------------------+
| [in]    | ulSize           | Requested size of the memory |
+---------+------------------+------------------------------+
| [out]   | pResult          | Pointer to error code        |
+---------+------------------+------------------------------+

**Return values**

+-------------------+--------------------------------------------------------------------------------------+
| ERR_OK            | Memory could be allocated                                                            |
+-------------------+--------------------------------------------------------------------------------------+
| ERR_NOMEMORY      | If memory could not be allocated                                                     |
+-------------------+--------------------------------------------------------------------------------------+
| ERR_OUT_OF_LIMITS | Memory could not be allocated because memory limit of the component has been reached |
+-------------------+--------------------------------------------------------------------------------------+

**Returns:**

Pointer to the memory block. NULL if no memory is available.

.. _group___sys_mem_itf_1gac803284edcb99a3d288904f27349a761:

void* SysMemReallocData (char *pszComponentName, void *pData, RTS_SIZE ulSize, RTS_RESULT *pResult)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Reallocate data memory with the specified size

**Parameters**

+---------+------------------+------------------------------+
| [in]    | pszComponentName | Name of the component        |
+---------+------------------+------------------------------+
| [in]    | pData            | Pointer to memory to resize  |
+---------+------------------+------------------------------+
| [in]    | ulSize           | Requested size of the memory |
+---------+------------------+------------------------------+
| [out]   | pResult          | Pointer to error code        |
+---------+------------------+------------------------------+

**Returns:**

Pointer to the memory block. NULL if no memory is available.

.. _group___sys_mem_itf_1ga2ed61c79d0610fcf07f89582f2cba1da:

RTS_RESULT SysMemFreeData (char *pszComponentName, void *pData)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Release data memory

**Parameters**

+---------+------------------+----------------------------------------------------------------------------------+
| [in]    | pszComponentName | Name of the component                                                            |
+---------+------------------+----------------------------------------------------------------------------------+
| [in]    | pData            | Pointer to memory to be released. If pointer is NULL, ERR_PARAMETER is returned. |
+---------+------------------+----------------------------------------------------------------------------------+

**Returns:**

error code

**Return values**

+---------------+--------------------------+
| ERR_OK        | Memory could be released |
+---------------+--------------------------+
| ERR_PARAMETER | Memory pointer is NULL   |
+---------------+--------------------------+

.. _group___sys_mem_itf_1ga7ba42e875fb5a4b94adf7a98597675d8:

void* SysMemAllocArea (char *pszComponentName, unsigned short usType, RTS_SIZE ulSize, RTS_RESULT *pResult)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Allocates any kind of memory area for an IEC application. See category "Area Types" for detailled description! Can be used to set an application area to a still existing memory location.

IMPLEMENTATION NOTE:

- New allocated memory must be initialized with 0, but _not_ the retain memory!

- Memory area must be aligned specified by SYSMEM_IECAREA_BYTE_ALIGNMENT! So the pointer to the area must be correctly aligned before returning the pointer or you have to use an appropriate operating system API function to get an aligned heap memory block from the memory manager!

**Parameters**

+---------+------------------+--------------------------------------------------------------------------------------------------------------------+
| [in]    | pszComponentName | Name of the component RANGE=[NULL,VALID_COMPONENT_NAME]                                                            |
+---------+------------------+--------------------------------------------------------------------------------------------------------------------+
| [in]    | usType           | Type of the area (see category "Area Types") RANGE=[DA_NONE,DA_CODE,DA_CONSTANT,DA_DATA,DA_RETAIN,INVALID_DA_AREA] |
+---------+------------------+--------------------------------------------------------------------------------------------------------------------+
| [in]    | ulSize           | Requested size of the memory RANGE=[0,VALID_SIZE,RTS_SIZE_MAX]                                                     |
+---------+------------------+--------------------------------------------------------------------------------------------------------------------+
| [out]   | pResult          | Pointer to error code                                                                                              |
+---------+------------------+--------------------------------------------------------------------------------------------------------------------+

**Return values**

+------------------------+---------------------------------------------------------------------------------------------------------------------------+
| ERR_OK                 | Memory Area could be allocated                                                                                            |
+------------------------+---------------------------------------------------------------------------------------------------------------------------+
| ERR_FAILED             | The requested Area could not be allocated - invalid combination of DA-Flags, or all areas of this type are already in use |
+------------------------+---------------------------------------------------------------------------------------------------------------------------+
| ERR_NOT_SUPPORTED      | Allocation is not supported, it might be allocated dynamically                                                            |
+------------------------+---------------------------------------------------------------------------------------------------------------------------+
| ERR_OUT_OF_LIMITS      | The requested area size was too large or too small                                                                        |
+------------------------+---------------------------------------------------------------------------------------------------------------------------+
| ERR_APP_DONT_INIT_AREA | The returned area must not be initialized outside, because the content is handled inside this function!                   |
+------------------------+---------------------------------------------------------------------------------------------------------------------------+

**Returns:**

Pointer to the memory block. NULL if no memory is available (allocate area on heap).

.. _group___sys_mem_itf_1gac601bc9910fc46027d782ac9f1a75ab8:

RTS_RESULT SysMemFreeArea (char *pszComponentName, void *pData)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Release data area of an application.

Note: On SIL2 Runtimes, this function may generate an exception, when called in SAFE-Mode.

**Parameters**

+---------+---------------------+-----------------------------------------------------------------------------------------------------------------+
| [in]    | pszComponentName    | Name of the component RANGE=[NULL,VALID_COMPONENT_NAME]                                                         |
+---------+---------------------+-----------------------------------------------------------------------------------------------------------------+
| [in]    | pData               | Pointer to area to free RANGE=[NULL,VALID_AREA_POINTER,INVALID_AREA_POINTER]                                    |
+---------+---------------------+-----------------------------------------------------------------------------------------------------------------+
| [in]    | OperationMode       | ***PSEUDO*** Specifies the current operation mode of the PLC RANGE=[RTS_SIL2_OPMODE_SAFE,RTS_SIL2_OPMODE_DEBUG] |
+---------+---------------------+-----------------------------------------------------------------------------------------------------------------+
| [out]   | bExceptionGenerated | ***PSEUDO*** Specifies, if an exception occured, or not RANGE=[TRUE,FALSE]                                      |
+---------+---------------------+-----------------------------------------------------------------------------------------------------------------+

**Returns:**

error code

**Return values**

+---------------+-----------------------------------------------------------------------------------+
| ERR_OK        | Memory Area could be freed                                                        |
+---------------+-----------------------------------------------------------------------------------+
| ERR_FAILED    | The memory area could not be freed (wrong area pointer, or area is not allocated) |
+---------------+-----------------------------------------------------------------------------------+
| ERR_PARAMETER | Parameter pData was NULL                                                          |
+---------------+-----------------------------------------------------------------------------------+

.. _group___sys_mem_itf_1ga8d5e3cdf2959853e263068788ae612a7:

void* SysMemAllocCode (char *pszComponentName, RTS_SIZE ulSize, RTS_RESULT *pResult)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Allocate code memory with the specified size (in the memory, code can be executed). NOTE: This routine can be used on architectures, where standard data memory is protected against code execution! IMPLEMENTATION NOTE: New allocated memory must be initialized with 0!

**Parameters**

+---------+------------------+------------------------------+
| [in]    | pszComponentName | Name of the component        |
+---------+------------------+------------------------------+
| [in]    | ulSize           | Requested size of the memory |
+---------+------------------+------------------------------+
| [out]   | pResult          | Pointer to error code        |
+---------+------------------+------------------------------+

**Returns:**

Pointer to the memory block. NULL if no memory is available.

.. _group___sys_mem_itf_1ga2fe60fc89792ced09b6a86f47a57a3bd:

RTS_RESULT SysMemFreeCode (char *pszComponentName, void *pCode)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Release code memory

**Parameters**

+---------+------------------+-----------------------------+
| [in]    | pszComponentName | Name of the component       |
+---------+------------------+-----------------------------+
| [in]    | pData            | Pointer to memory to resize |
+---------+------------------+-----------------------------+

**Returns:**

error code

.. _group___sys_mem_itf_1ga3b6dfb1099dbb85bcaf196b13254c75e:

RTS_RESULT SysMemIsValidPointer (void *ptr, RTS_SIZE ulSize, int bWrite)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Check if a pointer points to a valid address.

**Parameters**

+---------+--------+------------------------------------------------------------------------------+
| [in]    | ptr    | Pointer to the memory to be checked RANGE=[NULL,VALID_MEMORY,INVALID_MEMORY] |
+---------+--------+------------------------------------------------------------------------------+
| [in]    | ulSize | Size of the memory to be checked RANGE=[0,VALID_SIZE]                        |
+---------+--------+------------------------------------------------------------------------------+
| [in]    | bWrite | 1=Check, if memory can be written, 0=Check only for read access RANGE=[0,1]  |
+---------+--------+------------------------------------------------------------------------------+

**Returns:**

Error code:

- ERR_OK: Memory is valid

- ERR_FAILED: Memory is invalid. Cannot be accessed with the requested access mode bWrite

.. _group___sys_mem_itf_1ga6407a80e389a69fb52881cc664a1b171:

int SysMemSwap (unsigned char *pbyBuffer, int iSize, int iCount)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Routine to swap memory. If little endian (intel) byteorder is received and platform has big endian (motorola) byteorder. On little endian byteorder platforms, routine does nothing.

**Parameters**

+---------+-----------+------------------------------------------------------------------------------------------------------------+
| [in]    | pbyBuffer | Pointer to data to swap. You can check, which order is selected by calling the routine with pbyBuffer=NULL |
+---------+-----------+------------------------------------------------------------------------------------------------------------+
| [in]    | iSize     | Size of one element to swap                                                                                |
+---------+-----------+------------------------------------------------------------------------------------------------------------+
| [in]    | iCount    | Number of elements to swap                                                                                 |
+---------+-----------+------------------------------------------------------------------------------------------------------------+

**Returns:**

-1 = failed (iSize too large) *0 = no swapping necessary (little endian byteorder) >0 = Number of bytes swapped (big endian byteorder) *1 = big endian byteorder, if pbyBuffer=NULL

.. _group___sys_mem_itf_1ga098f0a5b0146da61aa1c206dbae76e7d:

int SysMemForceSwap (unsigned char *pbyBuffer, int iSize, int iCount)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Routine to force swapping memory independant of the byteorder of the system!

**Parameters**

+---------+-----------+------------------------------------------------------------------------------------------------------------+
| [in]    | pbyBuffer | Pointer to data to swap. You can check, which order is selected by calling the routine with pbyBuffer=NULL |
+---------+-----------+------------------------------------------------------------------------------------------------------------+
| [in]    | iSize     | Size of one element to swap                                                                                |
+---------+-----------+------------------------------------------------------------------------------------------------------------+
| [in]    | iCount    | Number of elements to swap                                                                                 |
+---------+-----------+------------------------------------------------------------------------------------------------------------+

**Returns:**

-1 = failed (iSize too large) >0 = Number of bytes swapped

.. _group___sys_mem_itf_1gac9ede21074e5918f3f84a2b74c1a5951:

RTS_SIZE SysMemGetCurrentHeapSize (RTS_RESULT *pResult)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Routine to get total size of the currently allocated heap memory.

**Parameters**

+---------+---------+-----------------------+
| [out]   | pResult | Pointer to error code |
+---------+---------+-----------------------+

**Return values**

+-------------------+--------------------------------------------------------------------------+
| ERR_OK            | Current heap size is available                                           |
+-------------------+--------------------------------------------------------------------------+
| ERR_NOT_SUPPORTED | Determination of current heap size not supported. CmpMemGC is necessary! |
+-------------------+--------------------------------------------------------------------------+

**Returns:**

Size of the memory in bytes that is currently allocated from the heap

.. last line of group.rst template
.. last line of composition.rst template


