.. first line of composition.rst template

.. first line of group.rst template

.. _group___sys_cpu_handling_itf:

=================
SysCpuHandlingItf
=================

Interface of SysCpuHandling. :ref:`More... <group___sys_cpu_handling_itf-details>`

Modules
-------

- :ref:`!	Platform defines - IEC codegenerator specific! <group___sys_cpu_handling_itf___platformdefines-_i_e_ccodegeneratorspecific>`

- :ref:`Platform defines <group___sys_cpu_handling_itf___platformdefines>`

- :ref:`Register Offsets <group___sys_cpu_handling_itf___register_offsets>`

- :ref:`Settings <group___sys_cpu_handling_itf___settings>`

- :ref:`Static defines <group___sys_cpu_handling_itf___staticdefines>`

Data Structures
---------------

- struct :ref:`tagsyscpuatomicadd_struct <structtagsyscpuatomicadd__struct>`

- struct :ref:`tagsyscpuatomicadd64_struct <structtagsyscpuatomicadd64__struct>`

- struct :ref:`tagsyscpuatomiccompareandswap_struct <structtagsyscpuatomiccompareandswap__struct>`

- struct :ref:`tagsyscpucalliecfuncwithparams_struct <structtagsyscpucalliecfuncwithparams__struct>`

- struct :ref:`tagsyscputestandreset_struct <structtagsyscputestandreset__struct>`

- struct :ref:`tagsyscputestandset_struct <structtagsyscputestandset__struct>`

- struct :ref:`tagsyscputestandsetbit_struct <structtagsyscputestandsetbit__struct>`

- struct :ref:`ISysCpuHandling_C <struct_i_sys_cpu_handling___c>`

Macros
------

- #define :ref:`ITF_SysCpuHandling <group___sys_cpu_handling_itf_1ga7714b75559c7f21bb5d6dd01bf3bcee5>`

- #define :ref:`EXTITF_SysCpuHandling <group___sys_cpu_handling_itf_1ga5624e438e0e63b44d0defa028bf4d467>`

Typedefs
--------

- typedef struct :ref:`tagsyscpuatomicadd_struct <structtagsyscpuatomicadd__struct>` :ref:`syscpuatomicadd_struct <group___sys_cpu_handling_itf_1ga50aabc20d5e6ebeb33501c4c2a08176a>`

- typedef struct :ref:`tagsyscpuatomicadd64_struct <structtagsyscpuatomicadd64__struct>` :ref:`syscpuatomicadd64_struct <group___sys_cpu_handling_itf_1ga2d5fc38c2d2b1686471aa0b2777465f7>`

- typedef struct :ref:`tagsyscpuatomiccompareandswap_struct <structtagsyscpuatomiccompareandswap__struct>` :ref:`syscpuatomiccompareandswap_struct <group___sys_cpu_handling_itf_1ga514f459b5057ef79692f596e01b87271>`

- typedef struct :ref:`tagsyscpucalliecfuncwithparams_struct <structtagsyscpucalliecfuncwithparams__struct>` :ref:`syscpucalliecfuncwithparams_struct <group___sys_cpu_handling_itf_1ga9ad4c2d68fbe821e17fc3e1ddddc92d7>`

- typedef struct :ref:`tagsyscputestandreset_struct <structtagsyscputestandreset__struct>` :ref:`syscputestandreset_struct <group___sys_cpu_handling_itf_1ga4ce7f1fe46dbd728cef005e0d1ea2e07>`

- typedef struct :ref:`tagsyscputestandset_struct <structtagsyscputestandset__struct>` :ref:`syscputestandset_struct <group___sys_cpu_handling_itf_1ga9ce286678bdba5814a3661e511732d2b>`

- typedef struct :ref:`tagsyscputestandsetbit_struct <structtagsyscputestandsetbit__struct>` :ref:`syscputestandsetbit_struct <group___sys_cpu_handling_itf_1ga3d7349a82fde096015e748c153642176>`

- typedef :ref:`ISysCpuHandling_C <struct_i_sys_cpu_handling___c>` :ref:`ISysCpuHandling <group___sys_cpu_handling_itf_1ga117e46ae162923b95d2a653634b0a217>`

Functions
---------

- void :ref:`syscpuatomicadd <group___sys_cpu_handling_itf_1ga8c261020d58afb5468eb75cd51370829>` (:ref:`syscpuatomicadd_struct <group___sys_cpu_handling_itf_1ga50aabc20d5e6ebeb33501c4c2a08176a>` * p)

- void :ref:`syscpuatomicadd64 <group___sys_cpu_handling_itf_1gaee858b810cf1482f1a5ba709f0774e72>` (:ref:`syscpuatomicadd64_struct <group___sys_cpu_handling_itf_1ga2d5fc38c2d2b1686471aa0b2777465f7>` * p)

- void :ref:`syscpuatomiccompareandswap <group___sys_cpu_handling_itf_1gaacc60cea73b09061bc6579895cab7f3b>` (:ref:`syscpuatomiccompareandswap_struct <group___sys_cpu_handling_itf_1ga514f459b5057ef79692f596e01b87271>` * p)

- void :ref:`syscpucalliecfuncwithparams <group___sys_cpu_handling_itf_1ga342ad004d7518950bad3f3b11a7b9bc0>` (:ref:`syscpucalliecfuncwithparams_struct <group___sys_cpu_handling_itf_1ga9ad4c2d68fbe821e17fc3e1ddddc92d7>` * p)

- void :ref:`syscputestandreset <group___sys_cpu_handling_itf_1ga9e0dc508a43652ec1d666a63d4e0e92d>` (:ref:`syscputestandreset_struct <group___sys_cpu_handling_itf_1ga4ce7f1fe46dbd728cef005e0d1ea2e07>` * p)

- void :ref:`syscputestandset <group___sys_cpu_handling_itf_1ga6e1edd6a282e2dc1bbd01b01de3750cf>` (:ref:`syscputestandset_struct <group___sys_cpu_handling_itf_1ga9ce286678bdba5814a3661e511732d2b>` * p)

- void :ref:`syscputestandsetbit <group___sys_cpu_handling_itf_1gac254a4ee5e08aae17ac9e1ac68b1b22c>` (:ref:`syscputestandsetbit_struct <group___sys_cpu_handling_itf_1ga3d7349a82fde096015e748c153642176>` * p)

- RTS_RESULT :ref:`SysCpuHandlingOSInit <group___sys_cpu_handling_itf_1gadce9940c690ed21f47d007f9878c5519>` (INIT_STRUCT * pInit)

- RTS_RESULT :ref:`SysCpuHandlingOSHookFunction <group___sys_cpu_handling_itf_1ga215b7f5823e79aee802deef8bcfd39ca>` (RTS_UI32 ulHook, RTS_UINTPTR ulParam1, RTS_UINTPTR ulParam2)

- int :ref:`SysCpuFlushInstructionCache <group___sys_cpu_handling_itf_1gad9c708fa59e4da7c362a2bd305dee8bc>` (void * pBaseAddress, unsigned long ulSize)

- RTS_RESULT :ref:`SysCpuCallIecFuncWithParams <group___sys_cpu_handling_itf_1ga008f25292ebc98e6882d51ebd6303c14>` (RTS_VOID_FCTPTR pfIECFunc, void * pParam, int iSize)

- RTS_RESULT :ref:`SysCpuSetRegisterValue <group___sys_cpu_handling_itf_1gab93592451daf8f547df9e5ff298104a2>` (RTS_UINTPTR * pRegBuff, RTS_I32 nRegisterNumber, RTS_UINTPTR newValue)

- void :ref:`syscpudebughandler <group___sys_cpu_handling_itf_1gaf578b1b3a5575decb892beb9ce698a90>` (void)

- RTS_RESULT :ref:`SysCpuGetBreakpointCode <group___sys_cpu_handling_itf_1gaebc0723f197000901171b7967ee8969e>` (unsigned char * pbyAreaStart, unsigned char * pbyBPAddress, unsigned char * pbyOpCode, int * piOpcodeSize)

- RTS_RESULT :ref:`SysCpuGetCallstackEntry <group___sys_cpu_handling_itf_1gacd19edb2dbc783f7deb654d33d60102a>` (RTS_UINTPTR * pBP, void ** ppAddress)

- RTS_RESULT :ref:`SysCpuGetCallstackEntry2 <group___sys_cpu_handling_itf_1ga81a59c15038759a6a8b84f8fc1a776bf>` (RTS_I32 bIecCode, RTS_UINTPTR * pBP, void ** ppAddress)

- RTS_RESULT :ref:`SysCpuGetCallstackEntry3 <group___sys_cpu_handling_itf_1gad47b07d01ccaab9a433ea87080d89ab1>` (RTS_I32 bIecCode, :ref:`RegContext <group___sys_except_itf___exceptioncontext_1gab00884ef66266dc256618d479aade118>` * pContext, void ** ppAddress)

- RTS_UINTPTR * :ref:`SysCpuSearchOnStack_ <group___sys_cpu_handling_itf_1ga29efadcd4e9cb59135d39c400a764105>` (RTS_UINTPTR * pSP, RTS_UINTPTR pattern, RTS_RESULT * pResult)

- RTS_RESULT :ref:`SysCpuGetInstancePointer <group___sys_cpu_handling_itf_1ga2722c29654c8d24b447b45026f539318>` (RTS_UINTPTR * pBP, void ** ppInstancePointer)

- RTS_RESULT :ref:`SysCpuGetMonitoringBase <group___sys_cpu_handling_itf_1ga404cef3173477767d7ca48ae0f1cd21b>` (RTS_UINTPTR * pBP)

- RTS_RESULT :ref:`SysCpuTestAndSet <group___sys_cpu_handling_itf_1gaad809fbddfc71b5cd8948e0df09dfc16>` (RTS_UI32 * pul, int iBit)

- RTS_RESULT :ref:`SysCpuTestAndReset <group___sys_cpu_handling_itf_1ga5aa3e6598c2ed1d99444811172505991>` (RTS_UI32 * pul, int iBit)

- RTS_RESULT :ref:`SysCpuTestAndSetBit <group___sys_cpu_handling_itf_1ga6f2a3920d62c0af0c60ba69fec79fff4>` (void * pAddress, int nLen, int iBit, int bSet)

- RTS_RESULT :ref:`SysCpuGetContext <group___sys_cpu_handling_itf_1ga84f32e87a6568e4aab2cb573aebbf0be>` (:ref:`RegContext <group___sys_except_itf___exceptioncontext_1gab00884ef66266dc256618d479aade118>` * pContext)

- RTS_I32 :ref:`SysCpuAtomicAdd <group___sys_cpu_handling_itf_1gaa546c6642b797434c619a165d0cd3714>` (RTS_I32 * piValue, RTS_I32 nSum, RTS_RESULT * pResult)

- RTS_I64 :ref:`SysCpuAtomicAdd64 <group___sys_cpu_handling_itf_1ga76fae609a3a3212e3ba964a7f563a1c1>` (RTS_I64 * pi64Value, RTS_I64 nSum, RTS_RESULT * pResult)

- RTS_RESULT :ref:`SysCpuAtomicCompareAndSwap <group___sys_cpu_handling_itf_1gab1318c09a385367612ec8efbae08ed22>` (void * pAddress, void * pSwapValue, void * pCompareValue, RTS_UI8 valueSize)

- RTS_I64 :ref:`SysCpuReadInt64 <group___sys_cpu_handling_itf_1ga61ac7c09ad81724a97709944a601dc9f>` (RTS_I64 * pSrc, RTS_RESULT * pResult)

- RTS_RESULT :ref:`SysCpuWriteInt64 <group___sys_cpu_handling_itf_1gadcdac72472ff6647d7649236eb71de26>` (RTS_I64 * pDest, RTS_I64 i64Value)

- RTS_REAL64 :ref:`SysCpuReadReal64 <group___sys_cpu_handling_itf_1ga385c32805057dd999ad5a02452b1f2b2>` (RTS_REAL64 * pSrc, RTS_RESULT * pResult)

- RTS_RESULT :ref:`SysCpuWriteReal64 <group___sys_cpu_handling_itf_1gaedab8a704ce10c7088ac852a99c2905d>` (RTS_REAL64 * pDest, RTS_REAL64 r64Value)

- RTS_RESULT :ref:`SysCpuWriteValueAtomic <group___sys_cpu_handling_itf_1ga8e4cc6e035e5082ca20a32ea4a904be3>` (void * pDest, void * pSrc, RTS_UI32 nLen)

- RTS_RESULT :ref:`SysCpuReadValueAtomic <group___sys_cpu_handling_itf_1ga83020bd88a10f540befa908c6fafa96c>` (void * pSrc, void * pDest, RTS_UI32 nLen)

.. _group___sys_cpu_handling_itf-details:

Detailed Description
--------------------

Interface of SysCpuHandling.

The SysCpuHandling interface contains all cpu specific routines.

To detect, for which platform the component is compiled, there are special defines that must be set in sysdefines.h dependant of the compiler specific options (see category "Processor ID" in :ref:`SysTargetItf.h <_sys_target_itf_8h>` )

**Copyright:**

Copyright (c) 2017-2018 CODESYS GmbH, Copyright (c) 1994-2016 3S-Smart Software Solutions GmbH. All rights reserved.

Macro Definition Documentation
------------------------------
.. _group___sys_cpu_handling_itf_1ga7714b75559c7f21bb5d6dd01bf3bcee5:

#define ITF_SysCpuHandling
^^^^^^^^^^^^^^^^^^^^^^^^^^

.. _group___sys_cpu_handling_itf_1ga5624e438e0e63b44d0defa028bf4d467:

#define EXTITF_SysCpuHandling
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Typedef Documentation
---------------------

.. _group___sys_cpu_handling_itf_1ga50aabc20d5e6ebeb33501c4c2a08176a:

typedef struct tagsyscpuatomicadd_struct  syscpuatomicadd_struct
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

EXTERN LIB SECTION BEGIN <SIL2>

Function to increment the content of the given pointer by nSum in one atomic operation (task safe). IMPLEMENTATION NOTE:

- Add/Sub the value to the content of the pointer

- Return the value after the Add/Sub operation Both things must be done atomic!

**Returns:**

*RESULT: Returns the value after the increment operation in an atomic way!

.. _group___sys_cpu_handling_itf_1ga2d5fc38c2d2b1686471aa0b2777465f7:

typedef struct tagsyscpuatomicadd64_struct  syscpuatomicadd64_struct
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

<SIL2>

Function to increment the content of the given pointer by nSum in one atomic operation (task safe). IMPLEMENTATION NOTE:

- Add/Sub the value to the content of the pointer

- Return the value after the Add/Sub operation Both things must be done atomic!

**Returns:**

*RESULT: Returns the value after the increment operation in an atomic way!

.. _group___sys_cpu_handling_itf_1ga514f459b5057ef79692f596e01b87271:

typedef struct tagsyscpuatomiccompareandswap_struct  syscpuatomiccompareandswap_struct
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

<SIL2>

Function for compare-and-swap in one atomic operation (task safe). Supports only 32- and 64-bit types

**Returns:**

*RESULT: Returns ERR_OK if the swap was successful

.. _group___sys_cpu_handling_itf_1ga9ad4c2d68fbe821e17fc3e1ddddc92d7:

typedef struct tagsyscpucalliecfuncwithparams_struct  syscpucalliecfuncwithparams_struct
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

<SIL2>

Call an IEC function from plain C code. Since different CPU's/systems use different calling conventions, this function should be used as a wrapper. IEC functions or methods of function block use all the same calling convention: They have no return value and exactly one parameter, which is a pointer to a struct that contains all required IN and OUT parameters. RETURN: Returns the runtime system error code (see CmpErrors.library)

.. _group___sys_cpu_handling_itf_1ga4ce7f1fe46dbd728cef005e0d1ea2e07:

typedef struct tagsyscputestandreset_struct  syscputestandreset_struct
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Test and reset a bit in an ULONG variable in one processor step. This operation is to provide a multitasking save operation.

**Returns:**

*RESULT: Returns the runtime system error code (see CmpErrors.library). *ERR_OK: If bit could be reset and was set before, *ERR_FAILED: If bit is still reset

.. _group___sys_cpu_handling_itf_1ga9ce286678bdba5814a3661e511732d2b:

typedef struct tagsyscputestandset_struct  syscputestandset_struct
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Test and set a bit in an ULONG variable in one processor step. This operation is to provide a multitasking save operation.

**Returns:**

*RESULT: Returns the runtime system error code (see CmpErrors.library). *ERR_OK: If bit could be set and was set before, *ERR_FAILED: If bit is still set

.. _group___sys_cpu_handling_itf_1ga3d7349a82fde096015e748c153642176:

typedef struct tagsyscputestandsetbit_struct  syscputestandsetbit_struct
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

<SIL2>

The function test and set or clear a bit in a variable in one processor step. This operation must be atomic to provide a multitasking save operation.

IMPLEMENTATION NOTE: Try to use a processor opcode, that provides this operation. If such an opcode is not available, use SysCpuTestAndSetBitBase in your platform adaptation.

**Returns:**

*RESULT: Returns the runtime system error code (see CmpErrors.library).

- ERR_OK: bSet=1: If bit could be set and was not set before bSet=0: If bit could be cleared and was set before

- ERR_FAILED: bSet=1: If bit is still set bSet=0: If bit is still cleared

- ERR_PARAMETER: If pAddress=NULL or pAddress is unaligned or iBit is out nSize range

- ERR_NOT_SUPPORTED: If function is not available because of missing components (e.g. SysInt for locking bit access)

- ERR_NOTIMPLEMENTED: If function is not implemented on this platform

.. _group___sys_cpu_handling_itf_1ga117e46ae162923b95d2a653634b0a217:

typedef ISysCpuHandling_C ISysCpuHandling
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Function Documentation
----------------------

.. _group___sys_cpu_handling_itf_1ga8c261020d58afb5468eb75cd51370829:

void syscpuatomicadd (syscpuatomicadd_struct *p)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. _group___sys_cpu_handling_itf_1gaee858b810cf1482f1a5ba709f0774e72:

void syscpuatomicadd64 (syscpuatomicadd64_struct *p)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. _group___sys_cpu_handling_itf_1gaacc60cea73b09061bc6579895cab7f3b:

void syscpuatomiccompareandswap (syscpuatomiccompareandswap_struct *p)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. _group___sys_cpu_handling_itf_1ga342ad004d7518950bad3f3b11a7b9bc0:

void syscpucalliecfuncwithparams (syscpucalliecfuncwithparams_struct *p)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. _group___sys_cpu_handling_itf_1ga9e0dc508a43652ec1d666a63d4e0e92d:

void syscputestandreset (syscputestandreset_struct *p)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. _group___sys_cpu_handling_itf_1ga6e1edd6a282e2dc1bbd01b01de3750cf:

void syscputestandset (syscputestandset_struct *p)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. _group___sys_cpu_handling_itf_1gac254a4ee5e08aae17ac9e1ac68b1b22c:

void syscputestandsetbit (syscputestandsetbit_struct *p)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. _group___sys_cpu_handling_itf_1gadce9940c690ed21f47d007f9878c5519:

RTS_RESULT SysCpuHandlingOSInit (INIT_STRUCT *pInit)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

EXTERN LIB SECTION END

.. _group___sys_cpu_handling_itf_1ga215b7f5823e79aee802deef8bcfd39ca:

RTS_RESULT SysCpuHandlingOSHookFunction (RTS_UI32 ulHook, RTS_UINTPTR ulParam1, RTS_UINTPTR ulParam2)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. _group___sys_cpu_handling_itf_1gad9c708fa59e4da7c362a2bd305dee8bc:

int SysCpuFlushInstructionCache (void *pBaseAddress, unsigned long ulSize)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

On some processors/operating systems this function must be called after code has been changed, so that the CPU is notified about the change.

**Parameters**

+---------+--------------+-------------------------------------------------------------------------------------------------+
| [in]    | pBaseAddress | Start address of the region to be flushed. Set to NULL to flush the complete instruction cache. |
+---------+--------------+-------------------------------------------------------------------------------------------------+
| [in]    | ulSize       | Length of the region to be flushed. This parameter is ignored if pBaseAddress is NULL.          |
+---------+--------------+-------------------------------------------------------------------------------------------------+

**Returns:**

error code

.. _group___sys_cpu_handling_itf_1ga008f25292ebc98e6882d51ebd6303c14:

RTS_RESULT SysCpuCallIecFuncWithParams (RTS_VOID_FCTPTR pfIECFunc, void *pParam, int iSize)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Call an IEC function from plain C code. Since different CPU's/systems use different calling conventions, this function should be used as a wrapper. But this function respectively the IEC callback code is not synchronized against an OnlineChange of the corresponding application!

ATTENTION: To be safe on multitasking and muticore systems you have to use :ref:`IecTaskCallIecFuncWithParams() <group___cmp_app_dep___task_1ga2d017ea03010554b1edcc575fa3b3d1a>` instead (see :ref:`CmpIecTaskItf.h <_cmp_iec_task_itf_8h>` )!

IEC functions or methods of function block use all the same calling convention: They have no return value and exactly one parameter, which is a pointer to a struct that contains all required IN and OUT parameters.

IMPLEMENTATION NOTE: The content of the parameter structure must be copied completely on the stack as an input parameter! Don't copy only the pointer! Because of this, the size of the structure is provided as a separate parameter to this function. Additionally, the structure of the IEC function must be copied back into the give parameter to return result values of the IEC function! For all this operations you have to ensure the stack alignment, but avoid copying more bytes than iSize

IMPLEMENTATION NOTE: Unused parameter pParam can be NULL, if function has no argument and no result (e.g. CodeInit)!

**Parameters**

+---------+-----------+-----------------------------------------------------------------------------------------------------------------------------+
| [in]    | pfIECFunc | Pointer to the IEC function that should be called RANGE=[NULL,VALID_IEC_FUNC,INVALID_IEC_FUNC]                              |
+---------+-----------+-----------------------------------------------------------------------------------------------------------------------------+
| [inout] | pParam    | Pointer to the parameter struct that contains the function parameters. ATTENTION: Can be NULL! RANGE=[NULL,VALID_PARAMETER] |
+---------+-----------+-----------------------------------------------------------------------------------------------------------------------------+
| [in]    | iSize     | Size of the parameter structure to copy the content on stack. ATTENTION: Can be 0! RANGE=[0,VALID_SIZE]                     |
+---------+-----------+-----------------------------------------------------------------------------------------------------------------------------+

**Return values**

+--------------------+-------------------------------------------------------------+
| ERR_OK             | Parameter check was successfull and pfIECFunc was called    |
+--------------------+-------------------------------------------------------------+
| ERR_PARAMETER      | pfIECFunc is NULL or for a paramter size > 0 pParam is NULL |
+--------------------+-------------------------------------------------------------+
| ERR_NOTIMPLEMENTED | Function is not implemented                                 |
+--------------------+-------------------------------------------------------------+

**Returns:**

error code

.. _group___sys_cpu_handling_itf_1gab93592451daf8f547df9e5ff298104a2:

RTS_RESULT SysCpuSetRegisterValue (RTS_UINTPTR *pRegBuff, RTS_I32 nRegisterNumber, RTS_UINTPTR newValue)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Sets the specified register to the given value inside the 'syscpudebughandler'

**Parameters**

+---------+-----------------+------------------------------------------------------------------------+
| [in]    | pRegBuff        | Pointer to start of saved registers                                    |
+---------+-----------------+------------------------------------------------------------------------+
| [in]    | nRegisterNumber | Register number to be set. See category "Register offsets" for details |
+---------+-----------------+------------------------------------------------------------------------+
| [in]    | newValue        | The new value                                                          |
+---------+-----------------+------------------------------------------------------------------------+

**Returns:**

error code

.. _group___sys_cpu_handling_itf_1gaf578b1b3a5575decb892beb9ce698a90:

void syscpudebughandler (void)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Routine is the entry of the IEC code debugger. Is called out of the IEC task if breakpoint is reached.

IMPLEMENTATION NOTE: In this routine, the :ref:`AppDebugHandler() <group___cmp_app_b_p_itf_1ga6b17f465662ba51cf0832f8c2baf0dfd>` function of CmpApp must be called with the appropriate parameters. See :ref:`CmpAppItf.h <_cmp_app_itf_8h>` for detailed information. The return value of :ref:`AppDebugHandler() <group___cmp_app_b_p_itf_1ga6b17f465662ba51cf0832f8c2baf0dfd>` must be used to set the return address in the IEC code. To this address we will return when leaving :ref:`syscpudebughandler() <group___sys_cpu_handling_itf_1gaf578b1b3a5575decb892beb9ce698a90>` .

SIL2 IMPLEMENTATION NOTE: This routine may never be reached within safety mode. If it is called in safety mode an Exception must be generated immediately! The Execution may not proceed to further debug mechanism!

**Parameters**

+---------+-------------------+-------------------------------------------------------------------------------------------------------------------+
| [in]    | OperationMode     | ***PSEUDO*** Specifies only that the function should be called RANGE=[RTS_SIL2_OPMODE_SAFE,RTS_SIL2_OPMODE_DEBUG] |
+---------+-------------------+-------------------------------------------------------------------------------------------------------------------+
| [out]   | bExceptionOccured | ***PSEUDO*** Specifies, if an exception should occure, or not RANGE=[TRUE,FALSE]                                  |
+---------+-------------------+-------------------------------------------------------------------------------------------------------------------+

**Returns:**

no return value

.. _group___sys_cpu_handling_itf_1gaebc0723f197000901171b7967ee8969e:

RTS_RESULT SysCpuGetBreakpointCode (unsigned char *pbyAreaStart, unsigned char *pbyBPAddress, unsigned char *pbyOpCode, int *piOpcodeSize)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Routine retrieves the breakpoint opcode for IEC code debugging. This is cpu dependant and depends additionally on the CoDeSys codegenerator.

**Parameters**

+---------+--------------+-----------------------------------------------------------------------------------------------------------------------------------+
| [in]    | pbyAreaStart | Pointer to start of the area.                                                                                                     |
+---------+--------------+-----------------------------------------------------------------------------------------------------------------------------------+
| [in]    | pbyBPAddress | Pointer to breakpoint address (where the breakpoint will be set). This parameter is used for breakpoints that uses absolut jumps. |
+---------+--------------+-----------------------------------------------------------------------------------------------------------------------------------+
| [out]   | pbyOpCode    | Pointer to get opcode                                                                                                             |
+---------+--------------+-----------------------------------------------------------------------------------------------------------------------------------+
| [inout] | piOpcodeSize | Pointer to maximum size of opcode buffer and return the real size of the opcode                                                   |
+---------+--------------+-----------------------------------------------------------------------------------------------------------------------------------+

**Returns:**

error code

.. _group___sys_cpu_handling_itf_1gacd19edb2dbc783f7deb654d33d60102a:

RTS_RESULT SysCpuGetCallstackEntry (RTS_UINTPTR *pBP, void **ppAddress)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Routine retrieves an IEC callstack entry, if the IEC code execution is stopped in the IEC code (breakpoint, exception, etc.). The callstack can be investigated out of the stack frames of each entered nested function. The first callstack entry is calculated outside this routine from the instruction pointer address (IP) that is provided for the :ref:`AppDebugHandler() <group___cmp_app_b_p_itf_1ga6b17f465662ba51cf0832f8c2baf0dfd>` routine from :ref:`syscpudebughandler() <group___sys_cpu_handling_itf_1gaf578b1b3a5575decb892beb9ce698a90>` . All further entries are called from this routine.

IMPLEMENTATION NOTE: The stack frame has typically the following structure:
::
    *				 .         STACK                        CODE
    *				 .         -----                        ----
    *				 .
    *				 .         BP0 /--------|               Fct0:
    *				 .                      |                    ...
    *				 .         Return Fct0  |                    Call Fct1
    *				 .    |--\ BP1 ---------|                    Return Fct0
    *				 .    |
    *				 .    |    Return Fct1                  Fct1:
    *				 .    |--- BP2 /--------|                    ...
    *				 .         ...          |                    Call Fct2
    *				 .         Stop         |                    Return Fct1
    *				 .                      |-- pulBP
    *				 .                                      Fct2:
    *				 .                                        ...
    *				 .                           IP --------/    Stop
    *

In this example, Fct0 calls Fct1 and Fct1 calls Fct2. This is a nested call with 3 Functions. Inside Fct2 we do a halt (e.g. stop on breakpoint). If we take a look on the stack, we see the return addresses from Fct0 and Fct1 on the stack. At the entry of each function, the base- (or frame-) pointer is pushed on the stack with the previous content. So you can see, the BP entries on the stack are organized as a chained list from stackframe to stack frame.

The first stack entry is the current position. This is calculated out of the IP address and cannot be investigated from stack.

The pulBP Parameter is a pointer, thats content is the address of the stack, where the BP entry resides.

**Parameters**

+---------+-----------+---------------------------------------------------------------------------------------------------------------------------+
| [inout] | pBP       | Pointer to last base pointer entry (or frame pointer) and returns the pointer to the next base pointer in the stack frame |
+---------+-----------+---------------------------------------------------------------------------------------------------------------------------+
| [out]   | ppAddress | Pointer pointer to return address in the code of the caller                                                               |
+---------+-----------+---------------------------------------------------------------------------------------------------------------------------+

**Returns:**

error code

.. _group___sys_cpu_handling_itf_1ga81a59c15038759a6a8b84f8fc1a776bf:

RTS_RESULT SysCpuGetCallstackEntry2 (RTS_I32 bIecCode, RTS_UINTPTR *pBP, void **ppAddress)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Routine to retrieve a callstack entry. The additional parameter bIecCode specifies, if the callstack should be retrieved in IEC-code (bIecCode = 1) or in C-code of the runtime system (bIecCode = 0). IMPLEMENTATION NOTE: The callstack in C-code is sometimes compiler dependant and must be implemented here specific to the compiler. If ERR_NOTIMPLEMENTED is returned, the generic linear backtrace on stack is done in SysCpuHandling.c.

**Parameters**

+---------+-----------+-------------------------------------------------------------------------------------------------------------------------------------------------+
| [in]    | bIecCode  | Is callstack expected in IEC- or in runtime-code: bIecCode=1: Expected in IEC-code bIecCode=0: Expected in runtime-code (external library call) |
+---------+-----------+-------------------------------------------------------------------------------------------------------------------------------------------------+
| [inout] | pBP       | Pointer to last base pointer entry (or frame pointer) and returns the pointer to the next base pointer in the stack frame                       |
+---------+-----------+-------------------------------------------------------------------------------------------------------------------------------------------------+
| [out]   | ppAddress | Pointer pointer to return address in the code of the caller                                                                                     |
+---------+-----------+-------------------------------------------------------------------------------------------------------------------------------------------------+

**Returns:**

error code

**Return values**

+--------------------+------------------------------------------------------------------------------------------------------+
| ERR_NOTIMPLEMENTED | If ERR_NOTIMPLEMENTED is returned, the generic linear backtrace on stack is done in SysCpuHandling.c |
+--------------------+------------------------------------------------------------------------------------------------------+

.. _group___sys_cpu_handling_itf_1gad47b07d01ccaab9a433ea87080d89ab1:

RTS_RESULT SysCpuGetCallstackEntry3 (RTS_I32 bIecCode, RegContext *pContext, void **ppAddress)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Routine to retrieve a callstack entry. The additional parameter bIecCode specifies, if the callstack should be retrieved in IEC-code (bIecCode = 1) or in C-code of the runtime system (bIecCode = 0). We use here first :ref:`SysCpuGetCallstackEntry2() <group___cmp_app_b_p_embedded_dep_1ga6d6dd216c3e291e58f002ec6807d7b0d>` of the platform adaptation. If it is not implemented, we do a generic backtrace on the stack.

**Parameters**

+---------+-----------+-------------------------------------------------------------------------------------------------------------------------------------------------+
| [in]    | bIecCode  | Is callstack expected in IEC- or in runtime-code: bIecCode=1: Expected in IEC-code bIecCode=0: Expected in runtime-code (external library call) |
+---------+-----------+-------------------------------------------------------------------------------------------------------------------------------------------------+
| [inout] | pContext  | Pointer to last base context entry and returns the pointer to the next context of the stack frame                                               |
+---------+-----------+-------------------------------------------------------------------------------------------------------------------------------------------------+
| [out]   | ppAddress | Pointer pointer to return address in the code corresponding to the callstack entry                                                              |
+---------+-----------+-------------------------------------------------------------------------------------------------------------------------------------------------+

**Returns:**

error code

**Return values**

+--------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ERR_OK       | Callstack entry resp. the IEC caller could be detected                                                                                                                                                                             |
+--------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ERR_FAILED   | Something failed during detecting the callstack                                                                                                                                                                                    |
+--------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ERR_NOMEMORY | Callstack entry resp. the IEC caller could _not_ be detected. Perhaps there is no IEC caller or the necessary setting in the DeviceDescription is not set for the platform: ARM, CortexM3, MIPS, PPC, SH, x86-64 and x86/WindowsCE |
+--------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

<ts:section name="codegenerator"> <ts:setting name="compiler-defines" type="string" access="visible"> <ts:value>generate_exceptioninfo</ts:value> </ts:setting> </ts:section> corresponding

**Return values**

+-------------------+------------------------------------------------------------------------------------------+
| ERR_NOT_SUPPORTED | A necessary interface function is not available (CmpApp::AppGetApplicationByAreaAddress) |
+-------------------+------------------------------------------------------------------------------------------+
| ERR_PARAMETER     | If one of the parameters is invalid                                                      |
+-------------------+------------------------------------------------------------------------------------------+

.. _group___sys_cpu_handling_itf_1ga29efadcd4e9cb59135d39c400a764105:

RTS_UINTPTR* SysCpuSearchOnStack_ (RTS_UINTPTR *pSP, RTS_UINTPTR pattern, RTS_RESULT *pResult)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Routine to find pattern on stack

**Parameters**

+---------+---------+------------------------------------+
| [in]    | pSP     | Pointer to stack to start search   |
+---------+---------+------------------------------------+
| [in]    | pattern | Pattern to search for on the stack |
+---------+---------+------------------------------------+
| [out]   | pResult | Pointer to error code              |
+---------+---------+------------------------------------+

**Returns:**

Pointer to the stack, where the pattern was found or NULL if failed

.. _group___sys_cpu_handling_itf_1ga2722c29654c8d24b447b45026f539318:

RTS_RESULT SysCpuGetInstancePointer (RTS_UINTPTR *pBP, void **ppInstancePointer)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Routine to retrieve the instance pointer of an FB. Is used to get an instance specific callstack. The position of the instance pointer depends on the CoDeSys codegenerator and is cpu dependant.

**Parameters**

+---------+-------------------+---------------------------------------------------------------------------------------------------------------------------+
| [inout] | pBP               | Pointer to last base pointer entry (or frame pointer) and returns the pointer to the next base pointer in the stack frame |
+---------+-------------------+---------------------------------------------------------------------------------------------------------------------------+
| [out]   | ppInstancePointer | Pointer pointer to the instance pointer of an FB                                                                          |
+---------+-------------------+---------------------------------------------------------------------------------------------------------------------------+

**Returns:**

error code

.. _group___sys_cpu_handling_itf_1ga404cef3173477767d7ca48ae0f1cd21b:

RTS_RESULT SysCpuGetMonitoringBase (RTS_UINTPTR *pBP)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Routine to retrieve the frame pointer for monitoring data access.

**Parameters**

+---------+-----+-----------------------------------------------------------------------------------------------------------------------+
| [inout] | pBP | Pointer to last base pointer entry (or frame pointer) and returns the pointer on the stack for monitoring data access |
+---------+-----+-----------------------------------------------------------------------------------------------------------------------+

**Returns:**

error code

.. _group___sys_cpu_handling_itf_1gaad809fbddfc71b5cd8948e0df09dfc16:

RTS_RESULT SysCpuTestAndSet (RTS_UI32 *pul, int iBit)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Obsolete: Use SysCpuTestAndSetBit instead!

OBSOLETE function to test and set a bit in an ULONG variable in one processor step. This operation must be atomic to provide a multitasking save operation.

IMPLEMENTATION NOTE: Try to use a processor opcode, that provides this operation. If such an opcode is not available, use SysCpuTestAndSetBase in your platform adaptation.

**Parameters**

+---------+---------+----------------------------------------------------------------------------------------+
| [in]    | pul     | Pointer to the unsigned value to test an set a bit inside in one atomic processor step |
+---------+---------+----------------------------------------------------------------------------------------+
| [out]   | iBitOut | ***PSEUDO*** Bit that was really set                                                   |
+---------+---------+----------------------------------------------------------------------------------------+

**Returns:**

Error code:

- ERR_OK: If bit could be set and was not set before

- ERR_FAILED: If bit is still set

.. _group___sys_cpu_handling_itf_1ga5aa3e6598c2ed1d99444811172505991:

RTS_RESULT SysCpuTestAndReset (RTS_UI32 *pul, int iBit)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Obsolete: Use SysCpuTestAndSetBit instead!

OBSOLETE function to reset a bit in an ULONG variable in one processor step. This operation must be atomic to provide a multitasking save operation.

IMPLEMENTATION NOTE: Try to use a processor opcode, that provides this operation. If such an opcode is not available, use SysCpuTestAndResetBase in your platform adaptation.

**Parameters**

+---------+------+------------------------------------------------------------------------------------------+
| [in]    | pul  | Pointer to the unsigned value to test an reset a bit inside in one atomic processor step |
+---------+------+------------------------------------------------------------------------------------------+
| [in]    | iBit | Bit number inside the variable to test and reset. 0=first bit, 31=last bit               |
+---------+------+------------------------------------------------------------------------------------------+

**Returns:**

- ERR_OK: If bit could be reset

- ERR_FAILED: If bit reset failed

.. _group___sys_cpu_handling_itf_1ga6f2a3920d62c0af0c60ba69fec79fff4:

RTS_RESULT SysCpuTestAndSetBit (void *pAddress, int nLen, int iBit, int bSet)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The function test and set or clear a bit in a variable in one processor step. This operation must be atomic to provide a multitasking save operation.

IMPLEMENTATION NOTE: Try to use a processor opcode, that provides this operation. If such an opcode is not available, use SysCpuTestAndSetBitBase in your platform adaptation. The function returns ERR_FAILED if the bit was already set or reset.

**Parameters**

+---------+----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| [in]    | pAddress | Pointer to test and set or clear a bit inside in one atomic processor step. NOTE: The pointer must be natural aligned! nLen=2: pAddress must be 2Byte aligned; nLen=4: pAddress must be 4Byte aligned RANGE=[NULL,ADDR_ALIGN0,ADDR_ALIGN1,ADDR_ALIGN2,ADDR_ALIGN3] |
+---------+----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| [in]    | nLen     | Size of the value behind the address. Can only be 1 (unsigned char), 2 (unsigned short) or 4 (unsigned long) RANGE=[1,2,4,INVALID_LEN]                                                                                                                             |
+---------+----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| [in]    | iBit     | Bit number inside the variable to test and set or clear:                                                                                                                                                                                                           |
|         |          |                                                                                                                                                                                                                                                                    |
|         |          | - nLen = 1: iBit 0..7                                                                                                                                                                                                                                              |
|         |          |                                                                                                                                                                                                                                                                    |
|         |          | - nLen = 2: iBit 0..15                                                                                                                                                                                                                                             |
|         |          |                                                                                                                                                                                                                                                                    |
|         |          | - nLen = 4: iBit 0..31 RANGE=[INT_MIN..0,0..7,8..15,16..31,32..INT_MAX]                                                                                                                                                                                            |
+---------+----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| [in]    | bSet     | 1=Set bit, 0=Clear bit RANGE=[0,1]                                                                                                                                                                                                                                 |
+---------+----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| [in]    | iBit     | Bit number inside the variable to test and set. 0=first bit, 31=last bit                                                                                                                                                                                           |
+---------+----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

**Return values**

+---------------+-----------------------------------------------------------------------------------------------+
| ERR_OK        | Bit could be set/reset successfully                                                           |
+---------------+-----------------------------------------------------------------------------------------------+
| ERR_FAILED    | Bit could not be set/reset successfully, perhaps it already was set/reset                     |
+---------------+-----------------------------------------------------------------------------------------------+
| ERR_PARAMETER | pAddress may not be null or misaligned, nLen may only be 1,2,4, iBit must be in correct range |
+---------------+-----------------------------------------------------------------------------------------------+

**Returns:**

Error code: returns if Bit could be set/reset successfully, or if any problem occured

.. _group___sys_cpu_handling_itf_1ga84f32e87a6568e4aab2cb573aebbf0be:

RTS_RESULT SysCpuGetContext (RegContext *pContext)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Get the actual register context.

**Parameters**

+---------+----------+-------------------------+
| [out]   | pContext | Actual register context |
+---------+----------+-------------------------+

**Returns:**

error code

.. _group___sys_cpu_handling_itf_1gaa546c6642b797434c619a165d0cd3714:

RTS_I32 SysCpuAtomicAdd (RTS_I32 *piValue, RTS_I32 nSum, RTS_RESULT *pResult)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Function to increment the content of the given pointer by nSum in one atomic operation (task safe).

IMPLEMENTATION NOTE: Add or substract the value to/from the content of the pointer, and return the value after this operation atomically.

**Parameters**

+---------+---------+------------------------------------------------------------------------------------------------------+
| [inout] | piValue | Pointer to the value to increment RANGE=[NULL,VALID_ATOMICADD_ADDR]                                  |
+---------+---------+------------------------------------------------------------------------------------------------------+
| [in]    | nSum    | Summand for the operation. greater 0 to increment, lower 0 to decrement RANGE=[RTS_RANGE_OF_RTS_I32] |
+---------+---------+------------------------------------------------------------------------------------------------------+
| [out]   | pResult | Pointer to error code                                                                                |
+---------+---------+------------------------------------------------------------------------------------------------------+

**Returns:**

Returns the value after the increment operation in an atomic way!

**Return values**

+--------------------+---------------------------+
| ERR_OK             | Call was sucessful        |
+--------------------+---------------------------+
| ERR_PARAMETER      | piValue was NULL          |
+--------------------+---------------------------+
| ERR_NOTIMPLEMENTED | Function is not supported |
+--------------------+---------------------------+

.. _group___sys_cpu_handling_itf_1ga76fae609a3a3212e3ba964a7f563a1c1:

RTS_I64 SysCpuAtomicAdd64 (RTS_I64 *pi64Value, RTS_I64 nSum, RTS_RESULT *pResult)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Function to increment the content of the given pointer by nSum in one atomic operation (task safe).

IMPLEMENTATION NOTE: Add or substract the value to/from the content of the pointer, and return the value after this operation atomically.

**Parameters**

+---------+-----------+-------------------------------------------------------------------------+
| [inout] | pi64Value | Pointer to the value to increment                                       |
+---------+-----------+-------------------------------------------------------------------------+
| [in]    | nSum      | Summand for the operation. greater 0 to increment, lower 0 to decrement |
+---------+-----------+-------------------------------------------------------------------------+
| [out]   | pResult   | Pointer to error code                                                   |
+---------+-----------+-------------------------------------------------------------------------+

**Returns:**

Returns the value after the increment operation in an atomic way!

**Return values**

+-------------------+---------------------------+
| ERR_OK            | Call was sucessful        |
+-------------------+---------------------------+
| ERR_PARAMETER     | pi64Value was NULL        |
+-------------------+---------------------------+
| ERR_NOT_SUPPORTED | Function is not supported |
+-------------------+---------------------------+

.. _group___sys_cpu_handling_itf_1gab1318c09a385367612ec8efbae08ed22:

RTS_RESULT SysCpuAtomicCompareAndSwap (void *pAddress, void *pSwapValue, void *pCompareValue, RTS_UI8 valueSize)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Function for compare-and-swap in one atomic operation (task safe). Supports only 32- and 64-bit types (i.e. a valid valueSize is 4 or 8)

**Parameters**

+---------+---------------+----------------------------------------------------------+
| [inout] | pAddress      | Pointer to the value to handle                           |
+---------+---------------+----------------------------------------------------------+
| [in]    | pSwapValue    | Pointer to the swap value                                |
+---------+---------------+----------------------------------------------------------+
| [in]    | pCompareValue | Pointer to the compare value                             |
+---------+---------------+----------------------------------------------------------+
| [in]    | valueSize     | Size of the value in bytes (a valid valueSize is 4 or 8) |
+---------+---------------+----------------------------------------------------------+

**Returns:**

Returns errorcode

**Return values**

+-------------------+-----------------------------------------------------------+
| ERR_OK            | Swap was successful                                       |
+-------------------+-----------------------------------------------------------+
| ERR_FAILED        | Swap was not successful                                   |
+-------------------+-----------------------------------------------------------+
| ERR_PARAMETER     | At least one of the pointers was NULL                     |
+-------------------+-----------------------------------------------------------+
| ERR_NOT_SUPPORTED | Swap not supported for this byte size or on this platform |
+-------------------+-----------------------------------------------------------+

.. _group___sys_cpu_handling_itf_1ga61ac7c09ad81724a97709944a601dc9f:

RTS_I64 SysCpuReadInt64 (RTS_I64 *pSrc, RTS_RESULT *pResult)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Function to read a 64bit integer value atomic / consistent.

**Parameters**

+---------+---------+------------------------------+
| [in]    | pSrc    | Pointer to the value to read |
+---------+---------+------------------------------+
| [out]   | pResult | Pointer to error code        |
+---------+---------+------------------------------+

**Returns:**

Returns the read value

**Return values**

+-------------------+-----------------------------------+
| ERR_OK            | Call was sucessful                |
+-------------------+-----------------------------------+
| ERR_PARAMETER     | pSrc is NULL                      |
+-------------------+-----------------------------------+
| ERR_NOT_SUPPORTED | Atomic function is not supported! |
+-------------------+-----------------------------------+

.. _group___sys_cpu_handling_itf_1gadcdac72472ff6647d7649236eb71de26:

RTS_RESULT SysCpuWriteInt64 (RTS_I64 *pDest, RTS_I64 i64Value)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Function to write a 64bit integer value atomic / consistent.

**Parameters**

+---------+----------+-------------------------------+
| [in]    | pDest    | Pointer to the value to write |
+---------+----------+-------------------------------+
| [in]    | i64Value | Value to write                |
+---------+----------+-------------------------------+

**Returns:**

Error code

**Return values**

+-------------------+-----------------------------------+
| ERR_OK            | Call was sucessful                |
+-------------------+-----------------------------------+
| ERR_PARAMETER     | pDest is NULL                     |
+-------------------+-----------------------------------+
| ERR_NOT_SUPPORTED | Atomic function is not supported! |
+-------------------+-----------------------------------+

.. _group___sys_cpu_handling_itf_1ga385c32805057dd999ad5a02452b1f2b2:

RTS_REAL64 SysCpuReadReal64 (RTS_REAL64 *pSrc, RTS_RESULT *pResult)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Function to read a 64bit real value atomic / consistent.

**Parameters**

+---------+---------+------------------------------+
| [in]    | pSrc    | Pointer to the value to read |
+---------+---------+------------------------------+
| [out]   | pResult | Pointer to error code        |
+---------+---------+------------------------------+

**Returns:**

Returns the read value

**Return values**

+-------------------+-----------------------------------+
| ERR_OK            | Call was sucessful                |
+-------------------+-----------------------------------+
| ERR_PARAMETER     | pSrc is NULL                      |
+-------------------+-----------------------------------+
| ERR_NOT_SUPPORTED | Atomic function is not supported! |
+-------------------+-----------------------------------+

.. _group___sys_cpu_handling_itf_1gaedab8a704ce10c7088ac852a99c2905d:

RTS_RESULT SysCpuWriteReal64 (RTS_REAL64 *pDest, RTS_REAL64 r64Value)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Function to write a 64bit real value atomic / consistent.

**Parameters**

+---------+----------+-------------------------------+
| [in]    | pDest    | Pointer to the value to write |
+---------+----------+-------------------------------+
| [in]    | r64Value | Value to write                |
+---------+----------+-------------------------------+

**Returns:**

Error code

**Return values**

+-------------------+-----------------------------------+
| ERR_OK            | Call was sucessful                |
+-------------------+-----------------------------------+
| ERR_PARAMETER     | pDest is NULL                     |
+-------------------+-----------------------------------+
| ERR_NOT_SUPPORTED | Atomic function is not supported! |
+-------------------+-----------------------------------+

.. _group___sys_cpu_handling_itf_1ga8e4cc6e035e5082ca20a32ea4a904be3:

RTS_RESULT SysCpuWriteValueAtomic (void *pDest, void *pSrc, RTS_UI32 nLen)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This function will write values with with 1, 2, 4 or 8 byte size as an atomic operation. Note: pDest has to be aligned according to the nLen parameter. If the alignment isn't correct the function will fail.

**Parameters**

+---------+-------+------------------------------------------------------------------------------------------------------------------------------------+
| [in]    | pDest | Pointer to the destination address. The value will be written to this address. The write operation to this address will be atomic. |
+---------+-------+------------------------------------------------------------------------------------------------------------------------------------+
| [in]    | pSrc  | Pointer to the source address. The value will be read from this address.                                                           |
+---------+-------+------------------------------------------------------------------------------------------------------------------------------------+
| [in]    | nLen  | Size of the value to be written. 1, 2, 4 and 8 will be accepted.                                                                   |
+---------+-------+------------------------------------------------------------------------------------------------------------------------------------+

**Returns:**

Error code

**Return values**

+-------------------+----------------------------------------------+
| ERR_OK            | Call was sucessful                           |
+-------------------+----------------------------------------------+
| ERR_PARAMETER     | pDest, pSrc is NULL or nLen isn't supported. |
+-------------------+----------------------------------------------+
| ERR_NOT_SUPPORTED | Atomic function is not supported!            |
+-------------------+----------------------------------------------+
| ERR_ALIGNMENT     | pDest was not aligned according to nLen.     |
+-------------------+----------------------------------------------+

.. _group___sys_cpu_handling_itf_1ga83020bd88a10f540befa908c6fafa96c:

RTS_RESULT SysCpuReadValueAtomic (void *pSrc, void *pDest, RTS_UI32 nLen)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This function will read values with with 1, 2, 4 or 8 byte size as an atomic operation. Note: pSrc has to be aligned according to the nLen parameter. If the alignment isn't correct the function will fail.

**Parameters**

+---------+------+-------------------------------------------------------------------------------------------------------------------------------+
| [in]    | pSrc | Pointer to the source address. The value will be read from this address. The read operation from this address will be atomic. |
+---------+------+-------------------------------------------------------------------------------------------------------------------------------+
| [in]    | pDst | Pointer to the destination address. The value will be written to this address.                                                |
+---------+------+-------------------------------------------------------------------------------------------------------------------------------+
| [in]    | nLen | Size of the value to be read. 1, 2, 4 and 8 will be accepted.                                                                 |
+---------+------+-------------------------------------------------------------------------------------------------------------------------------+

**Returns:**

Error code

**Return values**

+-------------------+------------------------------------------------+
| ERR_OK            | Call was sucessful                             |
+-------------------+------------------------------------------------+
| ERR_PARAMETER     | pSrc or pDest is NULL or nLen isn't supported. |
+-------------------+------------------------------------------------+
| ERR_NOT_SUPPORTED | Atomic function is not supported!              |
+-------------------+------------------------------------------------+
| ERR_ALIGNMENT     | pSrc was not aligned according to nLen.        |
+-------------------+------------------------------------------------+

.. last line of group.rst template
.. last line of composition.rst template


