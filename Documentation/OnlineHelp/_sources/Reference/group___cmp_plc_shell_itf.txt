.. first line of composition.rst template

.. first line of group.rst template

.. _group___cmp_plc_shell_itf:

==============
CmpPlcShellItf
==============

Interface of CmpPlcShell. :ref:`More... <group___cmp_plc_shell_itf-details>`

Modules
-------

- :ref:`Event parameter <group___cmp_plc_shell_itf___eventparameter>`

- :ref:`Events <group___cmp_plc_shell_itf___events>`

- :ref:`PlcShellCommandEntry <group___cmp_plc_shell_itf___plc_shell_command_entry>`

- :ref:`Static defines <group___cmp_plc_shell_itf___staticdefines>`

Data Structures
---------------

- struct :ref:`tagplcshellappend_struct <structtagplcshellappend__struct>`

- struct :ref:`tagplcshellregister_struct <structtagplcshellregister__struct>`

- struct :ref:`tagplcshellseteof_struct <structtagplcshellseteof__struct>`

- struct :ref:`tagplcshellskip_struct <structtagplcshellskip__struct>`

- struct :ref:`tagplcshellunregister_struct <structtagplcshellunregister__struct>`

- struct :ref:`ICmpPlcShell_C <struct_i_cmp_plc_shell___c>`

Macros
------

- #define :ref:`ITF_CmpPlcShell <group___cmp_plc_shell_itf_1gabe5676534b50dc5344965b9836b64b41>`

- #define :ref:`EXTITF_CmpPlcShell <group___cmp_plc_shell_itf_1ga0c361f4b65d46e30aa6a2977af96346a>`

Typedefs
--------

- typedef struct :ref:`tagplcshellappend_struct <structtagplcshellappend__struct>` :ref:`plcshellappend_struct <group___cmp_plc_shell_itf_1ga6391e768167107bfbe6fec7e521b2eb8>`

- typedef struct :ref:`tagplcshellregister_struct <structtagplcshellregister__struct>` :ref:`plcshellregister_struct <group___cmp_plc_shell_itf_1gaca715acc8c35f793c3795763d7042f80>`

- typedef struct :ref:`tagplcshellseteof_struct <structtagplcshellseteof__struct>` :ref:`plcshellseteof_struct <group___cmp_plc_shell_itf_1ga475e346b117951185d3be99c7eb57533>`

- typedef struct :ref:`tagplcshellskip_struct <structtagplcshellskip__struct>` :ref:`plcshellskip_struct <group___cmp_plc_shell_itf_1gace70c70086dc0f25428a829b017b27de>`

- typedef struct :ref:`tagplcshellunregister_struct <structtagplcshellunregister__struct>` :ref:`plcshellunregister_struct <group___cmp_plc_shell_itf_1ga27df0ce79fa5be658b5340411311d5a5>`

- typedef :ref:`ICmpPlcShell_C <struct_i_cmp_plc_shell___c>` :ref:`ICmpPlcShell <group___cmp_plc_shell_itf_1ga6d5e455f3f3f241bbe14c60443d97a20>`

Functions
---------

- void :ref:`plcshellappend <group___cmp_plc_shell_itf_1gacfb89d227e69420a44344c7cd62a3136>` (:ref:`plcshellappend_struct <group___cmp_plc_shell_itf_1ga6391e768167107bfbe6fec7e521b2eb8>` * p)

- void :ref:`plcshellregister <group___cmp_plc_shell_itf_1ga2a9185bcafdc8b85755be5e3af5999b9>` (:ref:`plcshellregister_struct <group___cmp_plc_shell_itf_1gaca715acc8c35f793c3795763d7042f80>` * p)

- void :ref:`plcshellseteof <group___cmp_plc_shell_itf_1gace351c3d75a6cd0bd0be0535aecac4de>` (:ref:`plcshellseteof_struct <group___cmp_plc_shell_itf_1ga475e346b117951185d3be99c7eb57533>` * p)

- void :ref:`plcshellskip <group___cmp_plc_shell_itf_1ga7f3a613ce00d52b61eec2cf2c95302df>` (:ref:`plcshellskip_struct <group___cmp_plc_shell_itf_1gace70c70086dc0f25428a829b017b27de>` * p)

- void :ref:`plcshellunregister <group___cmp_plc_shell_itf_1ga3d074b1cafe53d6958c6999f1478ad58>` (:ref:`plcshellunregister_struct <group___cmp_plc_shell_itf_1ga27df0ce79fa5be658b5340411311d5a5>` * p)

- RTS_RESULT :ref:`PlcShellRegister <group___cmp_plc_shell_itf_1ga984d8f2f1f4fe07ba3e51fda73cb3911>` (char * pszName, char * pszHelp, :ref:`PFEVENTCALLBACKFUNCTION <group___cmp_event_callback_itf_1ga66fcdd6103915e80e60e526bd4ad4dcf>`  pfCallbackFunction, int bIec)

- RTS_RESULT :ref:`PlcShellUnregister <group___cmp_plc_shell_itf_1gad2332a8832392229eabe4a2cefbd5df5>` (:ref:`PFEVENTCALLBACKFUNCTION <group___cmp_event_callback_itf_1ga66fcdd6103915e80e60e526bd4ad4dcf>`  pfCallbackFunction)

- RTS_RESULT :ref:`PlcShellSetEof <group___cmp_plc_shell_itf_1ga01cf373f03302baec79a02fd5a10f4f8>` (unsigned int uiEofPos)

- RTS_RESULT :ref:`PlcShellEof <group___cmp_plc_shell_itf_1gaba7dca4830fdfa59244d0d03f4b0f798>` (int iBlockID)

- RTS_RESULT :ref:`PlcShellSkip <group___cmp_plc_shell_itf_1ga757626cbb55adeb2608c69836624857b>` (int iBlockID)

- RTS_RESULT :ref:`PlcShellAppend <group___cmp_plc_shell_itf_1gaa73dc6d443ba493a43be4f2ec1461410>` (const char * pszString, int iBlockID)

.. _group___cmp_plc_shell_itf-details:

Detailed Description
--------------------

Interface of CmpPlcShell.

This interface enables foreign components or an IEC Application, to register a command handler and to send the output of the handler back to the PLC Shell.

If the output of the command is big and has to be devided into several chunks to be sent to the programming system, there are two possibilities to do that:

1) The command handler is dump and just sends the whole output, every time it is called, and doesn't care about the current "BlockID". In this case the PlcShell Component takes care about that. It calls the handler several times, but discards all output which doesn't belong to the current block.

2) The command handler is intelligent enough to prepare only the currently requested block.

- First, the handler needs to call PlcShellSkip(...) to skip the number of blocks, which he doesn't need to send again.

- Then, the handler will call PlcShellAppend(...) as much as necessary to prepare the currently sent block.

- The handler has to call the function PlcShellSetEof(...) once with the number of bytes he want's to sent at all (not within the current request, but the total number of bytes, during all requests.)

IMPLEMENTATION NOTES:

- The help description of a command is limited. So if you would like to provide a larger description: Provide a dedicated help command with "?" as a parameter and as result transport the extended help description!

Example: Command = "mycommand""
Extended help = "mycommand ?"

**Copyright:**

Copyright (c) 2017-2018 CODESYS GmbH, Copyright (c) 1994-2016 3S-Smart Software Solutions GmbH. All rights reserved.

Macro Definition Documentation
------------------------------
.. _group___cmp_plc_shell_itf_1gabe5676534b50dc5344965b9836b64b41:

#define ITF_CmpPlcShell
^^^^^^^^^^^^^^^^^^^^^^^

.. _group___cmp_plc_shell_itf_1ga0c361f4b65d46e30aa6a2977af96346a:

#define EXTITF_CmpPlcShell
^^^^^^^^^^^^^^^^^^^^^^^^^^

Typedef Documentation
---------------------

.. _group___cmp_plc_shell_itf_1ga6391e768167107bfbe6fec7e521b2eb8:

typedef struct tagplcshellappend_struct  plcshellappend_struct
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

EXTERN LIB SECTION BEGIN

Append a line to the command output

The passed parameter iBlockID, has TO be the BlockID, which was passed to the command handler! The communication layer automatically manages the split of blocks. If you want to avoid this and write only the current block that is sent to CoDeSys, use the function :ref:`PlcShellSkip() <group___cmp_plc_shell_itf_1ga757626cbb55adeb2608c69836624857b>` . RETURN: Returns the runtime system error code (see CmpErrors.library)

.. _group___cmp_plc_shell_itf_1gaca715acc8c35f793c3795763d7042f80:

typedef struct tagplcshellregister_struct  plcshellregister_struct
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Register a new Command Handler

The command is sent TO the handler as an event OF the EventMgr. So the CommandHandler needs to implement the Interface ICmpEventCallback.

Note: For the ease of use, you can also derive your Command Handler from the FB "CommandHandler" in this library. This helps you in the registration and deregistration of the handler. RETURN: Returns the runtime system error code (see CmpErrors.library)

.. _group___cmp_plc_shell_itf_1ga475e346b117951185d3be99c7eb57533:

typedef struct tagplcshellseteof_struct  plcshellseteof_struct
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Set EOF

This function should be called when the Command Handler is finished with it's output. RETURN: Returns the runtime system error code (see CmpErrors.library)

.. _group___cmp_plc_shell_itf_1gace70c70086dc0f25428a829b017b27de:

typedef struct tagplcshellskip_struct  plcshellskip_struct
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Skip a number of blocks in the output.

If a Command Handler sends a huge amount of output, it might be necessary, that this output is splitted into several blocks by the communication layer. When this happens, the communication layer will discard everything, but the current block from the output and recall the Command Handler several times.

To avoid this, an intelligent Command Handler can generate only the currently necessary block of output. For this, it needs to "skip" all blocks, which are already sent, by calling this function. Then it should write only that much data, that they fit into one block and call :ref:`PlcShellSetEof() <group___cmp_plc_shell_itf_1ga01cf373f03302baec79a02fd5a10f4f8>` when it is finished. RETURN: Returns the runtime system error code (see CmpErrors.library)

.. _group___cmp_plc_shell_itf_1ga27df0ce79fa5be658b5340411311d5a5:

typedef struct tagplcshellunregister_struct  plcshellunregister_struct
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Unregister a new Command Handler

Unregister the command handler, which is passed to this function. Most likely this function will be used in FB_exit, because every Command Handler in IEC has to unregister when the application is deleted. RETURN: Returns the runtime system error code (see CmpErrors.library)

.. _group___cmp_plc_shell_itf_1ga6d5e455f3f3f241bbe14c60443d97a20:

typedef ICmpPlcShell_C ICmpPlcShell
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Function Documentation
----------------------

.. _group___cmp_plc_shell_itf_1gacfb89d227e69420a44344c7cd62a3136:

void plcshellappend (plcshellappend_struct *p)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. _group___cmp_plc_shell_itf_1ga2a9185bcafdc8b85755be5e3af5999b9:

void plcshellregister (plcshellregister_struct *p)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. _group___cmp_plc_shell_itf_1gace351c3d75a6cd0bd0be0535aecac4de:

void plcshellseteof (plcshellseteof_struct *p)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. _group___cmp_plc_shell_itf_1ga7f3a613ce00d52b61eec2cf2c95302df:

void plcshellskip (plcshellskip_struct *p)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. _group___cmp_plc_shell_itf_1ga3d074b1cafe53d6958c6999f1478ad58:

void plcshellunregister (plcshellunregister_struct *p)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. _group___cmp_plc_shell_itf_1ga984d8f2f1f4fe07ba3e51fda73cb3911:

RTS_RESULT PlcShellRegister (char *pszName, char *pszHelp, PFEVENTCALLBACKFUNCTION pfCallbackFunction, int bIec)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

EXTERN LIB SECTION END

Register a new command handler

**Parameters**

+---------+--------------------+-------------------------------------------------------------+
| [in]    | pszName            | Name of the command.                                        |
+---------+--------------------+-------------------------------------------------------------+
| [in]    | pszHelp            | Help Text of the command.                                   |
+---------+--------------------+-------------------------------------------------------------+
| [in]    | pfCallbackFunction | Event Callback, which is called, whenever a command occurs. |
+---------+--------------------+-------------------------------------------------------------+

**Returns:**

error code

.. _group___cmp_plc_shell_itf_1gad2332a8832392229eabe4a2cefbd5df5:

RTS_RESULT PlcShellUnregister (PFEVENTCALLBACKFUNCTION pfCallbackFunction)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Unregister a new command handler

**Parameters**

+---------+--------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------+
| [in]    | pfCallbackFunction | Event Callback, which was registered with :ref:`PlcShellRegister() <group___cmp_open_s_s_l_dep___staticdefines_1ga06372363ab9c7f824efe33ebf1c9fb72>` before. |
+---------+--------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------+

**Returns:**

error code

.. _group___cmp_plc_shell_itf_1ga01cf373f03302baec79a02fd5a10f4f8:

RTS_RESULT PlcShellSetEof (unsigned int uiEofPos)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Set End Of File to current position. This function should be called from a command handler, to signal that he is finished with his output. If this function is not called upon the end of the command handler, the system implies that the end was reached at the end of the handler.

**Returns:**

error code

.. _group___cmp_plc_shell_itf_1gaba7dca4830fdfa59244d0d03f4b0f798:

RTS_RESULT PlcShellEof (int iBlockID)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Check if end of shell command reached

**Parameters**

+---------+----------+------------------------------------------------------------------------+
| [in]    | iBlockID | ID of the next block (which is equal to the number of blocks to skip). |
+---------+----------+------------------------------------------------------------------------+

**Returns:**

error code: *ERR_OK: End of shell command reached *ERR_FAILED: Shell command in progress

.. _group___cmp_plc_shell_itf_1ga757626cbb55adeb2608c69836624857b:

RTS_RESULT PlcShellSkip (int iBlockID)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Skip a number of blocks in the output buffer. Skip the specified number of blocks in the output and imply, that we are starting now with the next block, when we call :ref:`PlcShellAppend() <group___cmp_open_s_s_l_dep___staticdefines_1ga830748d0508f1e4f74e5fadd3011642e>` afterwards.

**Parameters**

+---------+----------+------------------------------------------------------------------------+
| [in]    | iBlockID | ID of the next block (which is equal to the number of blocks to skip). |
+---------+----------+------------------------------------------------------------------------+

**Returns:**

error code

.. _group___cmp_plc_shell_itf_1gaa73dc6d443ba493a43be4f2ec1461410:

RTS_RESULT PlcShellAppend (const char *pszString, int iBlockID)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Append a string to the output of the command. In case, that our output buffer is not yet or not anymore within the specified Block, the output is simply discarded.

**Parameters**

+---------+----------+------------------------------------------------------------------------+
| [in]    | iBlockID | ID of the next block (which is equal to the number of blocks to skip). |
+---------+----------+------------------------------------------------------------------------+
| [in]    | iBlockID | ID of the current block.                                               |
+---------+----------+------------------------------------------------------------------------+

**Returns:**

error code

.. last line of group.rst template
.. last line of composition.rst template


