

<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Required functions &#8212; RuntimeSystemDocumentation V3.5.16.40</title>
    <link rel="stylesheet" href="../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/theme.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Optional Functions" href="canminidriver_interface_optional_functions.html" />
    <link rel="prev" title="6.3.8.2. CANMiniDriver interface" href="canminidriver_interface.html" /> 
  </head><body>
	<div id="header">
		<a href="#" title="CODESYS" target="_top" id="logo"><img src="../../_static/logo.png" width="134" height="130" alt=""></a>
		<a href="#" title="CODESYS Documentation" target="_top" id="logo-store"><img src="../../_static/logo2.png" width="137" height="130" alt=""></a>
	</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="canminidriver_interface_optional_functions.html" title="Optional Functions"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="canminidriver_interface.html" title="6.3.8.2. CANMiniDriver interface"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">RuntimeSystemDocumentation V3.5.16.40</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >6. Tutorials / HowTos</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" >6.3.8. CANMiniDriver for CODESYS V3</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="canminidriver_interface.html" accesskey="U">6.3.8.2. CANMiniDriver interface</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
  <h4>Previous topic</h4>
  <p class="topless"><a href="canminidriver_interface.html"
                        title="previous chapter">6.3.8.2. CANMiniDriver interface</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="canminidriver_interface_optional_functions.html"
                        title="next chapter">Optional Functions</a></p>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="required-functions">
<span id="canminidriver-interface-required-functions"></span><h1>Required functions<a class="headerlink" href="#required-functions" title="Permalink to this headline">¶</a></h1>
<p>There is a minimum set of functions which have to be at least
implemented by a CANMiniDriver.</p>
<div class="section" id="cmd-getinfo-supported-functions">
<h2>CMD_GetInfo: Supported functions<a class="headerlink" href="#cmd-getinfo-supported-functions" title="Permalink to this headline">¶</a></h2>
<div class="line-block">
<div class="line">Each CANMiniDriver implements the function CMD_GetInfo which provides
information about the supported CANMiniDriver functionalities. This
information is packed into a CMD_Info structure defined in
CAA_CanMiniDriver.h:</div>
</div>
<p><img alt="image3" src="../../_images/image3.png" /></p>
<p>Figure 3: Info structure</p>
<ul>
<li><div class="line-block">
<div class="line"><strong>bySupport</strong>: A bit field with following possible bits:</div>
<div class="line"><img alt="image4" src="../../_images/image4.png" /></div>
</div>
<p>Figure 4: Supported functions bits</p>
</li>
<li><div class="line-block">
<div class="line"><strong>byMaxCycleIndex</strong>: Contains the maximum number of cyclic messages
(if SetCycle is supported).</div>
<div class="line">–&gt; If one cyclic message is supported: set to 1.</div>
</div>
</li>
<li><p><strong>byMaxMaskIndex</strong>: Not yet used by current implementation. Use 0.</p></li>
<li><p><strong>byMaxPrio</strong>: Not yet used by current implementation. Use 1.</p></li>
<li><div class="line-block">
<div class="line"><strong>byNLed</strong>: Number of LEDs. 0: No LED, 1: Bicolor LED, 2: red and
green LED.</div>
<div class="line">Not yet used by current implementation.</div>
</div>
</li>
</ul>
<p>Example:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">CMD_INFO</span> <span class="n">cmdInfo</span> <span class="p">=</span> <span class="p">{</span>
<span class="n">CMD_SUPPORT_RTRFRAME</span> <span class="p">|</span> <span class="n">CMD_SUPPORT_EXTCOBID</span> <span class="p">|</span> <span class="n">CMD_SUPPORT_BUSALARM</span>
<span class="cm">/* support RTR, Busalarm and 29 bit */</span><span class="p">,</span>
  <span class="m">0</span> <span class="cm">/* maxCycleIndex */</span><span class="p">,</span>
  <span class="m">0</span> <span class="cm">/* maxMaskIndex */</span><span class="p">,</span>
  <span class="m">1</span> <span class="cm">/* maxPrio  */</span><span class="p">,</span>
  <span class="m">0</span> <span class="cm">/* maxLed */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">CAA_ERROR</span> <span class="nf">CMD_GetInfo</span><span class="p">(</span><span class="n">CL2I_BYTE</span> <span class="n">byNet</span><span class="p">,</span> <span class="n">CMD_INFO</span><span class="p">*</span> <span class="n">pInfo</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">pInfo</span><span class="p">)</span>
  <span class="p">{</span>
     <span class="n">memcpy</span><span class="p">((</span><span class="k">void</span><span class="p">*)</span><span class="n">pInfo</span><span class="p">,</span> <span class="p">(</span><span class="k">void</span><span class="p">*)&amp;</span><span class="n">cmdInfo</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">CMD_INFO</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">CMD_NO_ERROR</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="cmd-setup-and-cl2-cmdregister-hardware-identification-registration-and-initialization">
<h2>CMD_Setup and CL2_CmdRegister: Hardware identification, registration, and initialization<a class="headerlink" href="#cmd-setup-and-cl2-cmdregister-hardware-identification-registration-and-initialization" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="../../_images/image5.png"><img alt="image5" src="../../_images/image5.png" style="width: 605.5px; height: 373.0px;" /></a></p>
<p>Figure 5: Init sequence</p>
<p>At startup (CH_INIT3 hook), a CANMiniDriver identifies all available
CAN interfaces and registers them at CL2 layer by calling CL2_CmdRegister.</p>
<p><img alt="image6" src="../../_images/image6.png" /></p>
<p>Figure 6: CmdRegister</p>
<p>It passes the following parameters to CL2:</p>
<ul>
<li><p><strong>ucNetID:</strong> A unique number which identifies the CAN interface in
CL2 layer. If Net ID is already used by another CAN interface (e.g.
occupied by another CANMiniDriver instance) or exceeds maximal
network number (define CL2_NNET) the function returns an appropriate
error code.</p></li>
<li><p><strong>pCMDRV:</strong> A pointer to the CANMiniDriver interface. Basically this
is a structure with function pointers used by CL2 to call into the
CANMiniDriver (see Figure 7: CL2I_INFO).</p></li>
<li><div class="line-block">
<div class="line"><strong>ctMessages:</strong> Number of messages that should be allocated
initially for the Rx Message Pool.</div>
<div class="line">If 0, then CL2_NRXMSG from CAADefinesGeneric.h will be used (by
default: 100).</div>
<div class="line">Note: If Rx messages run out and define CL2_QUEUE_ADAPTION in
CAADefinesGeneric.h is set to 1 (default), then the number of Rx
messages will by dynamically increased at runtime.</div>
</div>
</li>
<li><p><strong>ppInfo:</strong> A pointer to a CL2I_INFO pointer. On successful
registration, CL2 passes a pointer to a structure which serves as
exchange memory for diagnostics.</p></li>
</ul>
<p><img alt="image7" src="../../_images/image7.png" /></p>
<p>Figure 7: CL2I_INFO</p>
<p>Normally hardware is identified and registered by a function called
xxx_CanMiniDriver_Setup, where xxx is the name of the driver (e.g.
SJA_CanMiniDriver_Setup).</p>
<p>Example:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="c1">//interface definition</span>
<span class="k">static</span> <span class="n">CMD_CMDRV</span> <span class="n">cmdInterface</span> <span class="p">=</span>
<span class="p">{</span>
  <span class="n">CMD_Setup</span><span class="p">,</span>
  <span class="n">CMD_Init</span><span class="p">,</span>
  <span class="n">CMD_Send</span><span class="p">,</span>
  <span class="n">CMD_Receive</span><span class="p">,</span>
  <span class="n">CMD_GetInfo</span><span class="p">,</span>
  <span class="n">CMD_Dispose</span><span class="p">,</span>
  <span class="n">CMD_Identify</span><span class="p">,</span>
  <span class="n">CMD_SetBlock</span><span class="p">,</span>
  <span class="n">CMD_SetCycle</span><span class="p">,</span>
  <span class="n">CMD_SetMask</span><span class="p">,</span>
  <span class="n">CMD_ResetAlarm</span><span class="p">,</span>
  <span class="n">CMD_SetStatus</span>
<span class="p">}</span>

<span class="cp">#define XXX_NDRIVER CL2_NNET</span>

<span class="k">static</span> <span class="n">CL2I_INFO</span><span class="p">*</span> <span class="n">s_pInfo</span><span class="p">[</span><span class="n">XXX_NDRIVER</span><span class="p">];</span> <span class="c1">// exchange memory for diagnosis</span>
<span class="k">static</span> <span class="n">CL2I_BYTE</span> <span class="n">s_byDriver</span><span class="p">[</span><span class="n">XXX_NDRIVER</span><span class="p">];</span> <span class="c1">// lookup table for driver number</span>
<span class="k">static</span> <span class="n">CL2I_BYTE</span> <span class="n">s_byNet</span><span class="p">[</span><span class="n">CL2_NNET</span><span class="p">];</span> <span class="c1">// lookup table for NetID</span>

<span class="k">static</span> <span class="n">RTS_RESULT</span> <span class="n">CDECL</span> <span class="nf">HookFunction</span><span class="p">(</span><span class="n">RTS_UI32</span> <span class="n">ulHook</span> <span class="cm">/* , ... */</span><span class="p">)</span>

<span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">ulHook</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="c1">//…</span>
      <span class="k">case</span> <span class="n">CH_INIT3</span><span class="p">:</span>
      <span class="n">xxx_CanMiniDriver_Setup</span><span class="p">();</span>
      <span class="k">break</span><span class="p">;</span>

      <span class="c1">//…</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">ERR_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">xxx_CanMiniDriver_Setup</span><span class="p">(</span><span class="k">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">CL2I_BYTE</span> <span class="n">byDriver</span><span class="p">;</span>
  <span class="n">CL2I_BYTE</span> <span class="n">byNet</span><span class="p">;</span>
  <span class="n">CL2I_BYTE</span> <span class="n">byLastNet</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
  <span class="n">CAA_ERROR</span> <span class="n">eError</span><span class="p">;</span>

  <span class="c1">// TODO: search for available hardware interfaces</span>

  <span class="c1">// Register each driver</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">byDriver</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">byDriver</span> <span class="p">&lt;</span> <span class="n">XXX_NDRIVER</span><span class="p">;</span> <span class="n">byDriver</span><span class="p">++)</span>
  <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">byNet</span> <span class="p">=</span> <span class="n">byLastNet</span><span class="p">;</span> <span class="n">byNet</span> <span class="p">&lt;</span> <span class="n">CL2_NNET</span><span class="p">;</span> <span class="n">byNet</span><span class="p">++)</span>
    <span class="p">{</span>
      <span class="n">s_byDriver</span><span class="p">[</span><span class="n">byNet</span><span class="p">]</span> <span class="p">=</span> <span class="n">byDriver</span><span class="p">;</span>
      <span class="n">s_byNet</span><span class="p">[</span><span class="n">byDriver</span><span class="p">]</span> <span class="p">=</span> <span class="n">byNet</span><span class="p">;</span>
      <span class="n">eError</span> <span class="p">=</span> <span class="n">CL2_CmdRegister</span><span class="p">(</span><span class="n">byNet</span><span class="p">,</span>
        <span class="p">&amp;</span><span class="n">cmdInterface</span><span class="p">,</span>
        <span class="n">CL2_NRXMSG</span><span class="p">,</span>  <span class="c1">// Size of RX-Msg Pool, you can also use 0</span>
        <span class="p">&amp;</span><span class="n">s_pInfo</span><span class="p">[</span><span class="n">byNet</span><span class="p">]</span>

      <span class="p">);</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">eError</span> <span class="p">==</span> <span class="n">CL2_NO_ERROR</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="n">byLastNet</span> <span class="p">=</span> <span class="n">byNet</span> <span class="p">+</span> <span class="m">1</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span>
      <span class="p">{</span>
        <span class="n">s_pInfo</span><span class="p">[</span><span class="n">byNet</span><span class="p">]</span> <span class="p">=</span> <span class="n">CAA_pNULL</span><span class="p">;</span>
        <span class="n">s_byDriver</span><span class="p">[</span><span class="n">byNet</span><span class="p">]</span> <span class="p">=</span> <span class="n">XXX_NDRIVER</span><span class="p">;</span>
        <span class="n">s_byNet</span><span class="p">[</span><span class="n">byDriver</span><span class="p">]</span> <span class="p">=</span> <span class="n">XXX_NNET</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="m">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>After successful registration of a CAN network, CL2 calls CMD_Setup:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">CAA_ERROR</span> <span class="nf">CMD_Setup</span><span class="p">(</span><span class="n">CL2I_BYTE</span> <span class="n">byNet</span><span class="p">)</span>
<span class="p">{</span>
<span class="c1">// TODO: Initialize the particular CANbus chip so that it reacts to the</span>
<span class="c1">// connected CANbus in a completely passive manner. The necessary memory should be</span>
<span class="c1">// allocated so that a subsequent call to CMD_Init starts the CANbus service</span>
<span class="c1">// without further expense. Interrupts should not be enabled yet.</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="cmd-init-initialize-chip">
<h2>CMD_Init: Initialize chip<a class="headerlink" href="#cmd-init-initialize-chip" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="../../_images/image8.png"><img alt="image8" src="../../_images/image8.png" style="width: 977.1999999999999px; height: 252.7px;" /></a></p>
<p>Figure 8: Driver Open</p>
<p>The first time an application calls the CL2 Driver Open function for a
specific network, CL2 calls CMD_Init and passes NetID and desired baud
rate to the particular CANMiniDriver instance. In this function, the
CANMiniDriver prepares the chip for sending and receiving CAN messages
with the given baud rate.</p>
<p>Example Implementation:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">CAA_ERROR</span> <span class="nf">CMD_Init</span><span class="p">(</span><span class="n">CL2I_BYTE</span> <span class="n">byNet</span><span class="p">,</span> <span class="n">CL2I_WORD</span> <span class="n">wBaudrate</span><span class="p">)</span>

<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">byNet</span> <span class="p">&lt;</span> <span class="n">CL2_NNET</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">CAA_ERROR</span> <span class="n">eResult</span> <span class="p">=</span> <span class="n">CMD_NO_ERROR</span><span class="p">;</span>
    <span class="n">CL2I_INFO</span><span class="p">*</span> <span class="n">pCL2Info</span> <span class="p">=</span> <span class="n">s_pInfo</span><span class="p">[</span><span class="n">s_byDriver</span><span class="p">[</span><span class="n">byNet</span><span class="p">]];</span>
    <span class="c1">// TODO: init chip for driver instance s_byDriver[byNet] with wBaudrate</span>
    <span class="c1">// TODO: Reset pCL2Info set counters to 0, reset bus state, …</span>
    <span class="k">return</span> <span class="n">CMD_NO_ERROR</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">CMD_SETUP_ERROR</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="cmd-send-msgsendackn-message-sending">
<h2>CMD_Send, MsgSendAckn: Message Sending<a class="headerlink" href="#cmd-send-msgsendackn-message-sending" title="Permalink to this headline">¶</a></h2>
<p><img alt="image9" src="../../_images/image9.png" /></p>
<p>Figure 9: Message sending</p>
<div class="line-block">
<div class="line">If an application wants to send a CAN message, then it allocates a
message handle first from the Tx message pool and initializes the
message. Afterwards, it calls CL2.Write and passes the message handle
to CL2 layer. If the Tx Queue is empty, then CL2 passes the message
handle directly to the CANMiniDriver by invoking CMD_Send thread safe
(synchronized by CAA_ENTER_CRITSEC). Then CMD_Send performs the
execution of all steps necessary for the specific CANbus chip to send
the message.</div>
<div class="line">The function is defined as follows:</div>
<div class="line"><img alt="image10" src="../../_images/image10.png" /></div>
</div>
<ul class="simple">
<li><p>Returns CMD_SND_OK and eError = CMD_NO_ERROR if message was sent
successfully.</p></li>
<li><p>Returns CMD_SND_NOT_OK and eError = CMD_NO_ERROR if message cannot be
currently send (for example if chip is busy). CL2 will send the
message back to the front of Tx Queue.</p></li>
<li><p>Returns CMD_SND_NOT_OK and any error code for eError if message
cannot be sent and should be dismissed by CL2.</p></li>
</ul>
<div class="line-block">
<div class="line">If Tx Queue is not empty, then CL2.Write sends the message handle to
the Tx Queue for later processing. In this case, CMD_Send will not be
called.</div>
<div class="line">When a CANMiniDriver finished sending for the current message, it
calls CL2_MsgSendAckn with the current Tx message handle. (For further
details, see following chapters). At this point, the Tx Queue will be
checked by CL2 and another CMD_Send may be triggered.</div>
<div class="line">As CL2 implements a Tx loopback functionality, MsgSendAckn checks if
someone is interested in the Tx message. If so, then it will be sent
to the Rx Queue. Otherwise the message handle will be released and
sent back to the Tx message pool.</div>
</div>
<div class="section" id="drivers-with-tx-irq">
<h3>Drivers with Tx IRQ<a class="headerlink" href="#drivers-with-tx-irq" title="Permalink to this headline">¶</a></h3>
<div class="line-block">
<div class="line">Drivers with Tx Interrupt store the current Tx driver handle
(CMD_Send) and call MsgSendAcknIRQ for that handle in Tx Interrupt
handler. Then they signal that message was successfully sent and chip
is ready for sending the next message. Furthermore, the interrupt
service routine may update the time stamp of the message just sent.</div>
<div class="line"><strong>Note:</strong> It is important that processing Tx interrupts before Rx
interrupts. Otherwise there could be problems with synchronous PDOs
when using CANopenStack and Motion.</div>
</div>
<p>Example:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">CAA_BOOL</span> <span class="nf">CMD_Send</span><span class="p">(</span><span class="n">CL2I_BYTE</span> <span class="n">byNet</span><span class="p">,</span> <span class="n">CAA_HANDLE</span> <span class="n">hBlock</span><span class="p">,</span> <span class="n">CL2I_BYTE</span> <span class="n">byPrio</span><span class="p">,</span> <span class="n">CAA_ERROR</span><span class="p">*</span> <span class="n">peError</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">CAA_BYTE</span> <span class="n">byDriver</span> <span class="p">=</span> <span class="n">s_byDriver</span><span class="p">[</span><span class="n">byNet</span><span class="p">];</span>
  <span class="n">CL2I_INFO</span><span class="p">*</span> <span class="n">pInfo</span> <span class="p">=</span> <span class="n">s_pInfo</span><span class="p">[</span><span class="n">byDriver</span><span class="p">];</span>
  <span class="n">CL2I_BLOCK</span><span class="p">*</span> <span class="n">pBlock</span> <span class="p">=</span> <span class="p">(</span><span class="n">CL2I_BLOCK</span><span class="p">*)</span><span class="n">CAL_CL2_MsgGetData</span><span class="p">(</span><span class="n">hBlock</span><span class="p">);</span>

  <span class="n">CAA_SET_RESULT</span><span class="p">(</span><span class="n">peError</span><span class="p">,</span> <span class="n">CMD_NO_ERROR</span><span class="p">);</span>

  <span class="cm">/* … */</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">xxxDriverContext</span><span class="p">[</span><span class="n">byDriver</span><span class="p">].</span><span class="n">hBlock</span> <span class="p">!=</span> <span class="n">CAA_hINVALID</span><span class="p">)</span> <span class="cm">/* chip is busy */</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">CMD_SND_NOT_OK</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="cm">/* check TTL for CANopenSafety SIL2 */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">pBlock</span><span class="p">-&gt;</span><span class="n">dwTSP</span> <span class="p">!=</span> <span class="m">0</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="cm">/* check TTL */</span>
    <span class="n">RTS_SYSTIME</span> <span class="n">time</span><span class="p">;</span>
    <span class="n">CAA_DWORD</span> <span class="n">dwTime</span><span class="p">,</span> <span class="n">dwTTL</span><span class="p">;</span>
    <span class="n">CAL_SysTimeGetUs</span><span class="p">(&amp;</span><span class="n">time</span><span class="p">);</span>
    <span class="n">dwTime</span> <span class="p">=</span> <span class="p">(</span><span class="n">CAA_DWORD</span><span class="p">)</span><span class="n">time</span><span class="p">;</span>
    <span class="n">dwTTL</span> <span class="p">=</span> <span class="n">pBlock</span><span class="p">-&gt;</span><span class="n">dwTSP</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">dwTTL</span> <span class="p">&lt;</span> <span class="n">dwTime</span> <span class="p">&amp;&amp;</span> <span class="p">(</span><span class="n">dwTime</span> <span class="p">-</span> <span class="n">dwTTL</span><span class="p">)</span> <span class="p">&lt;</span> <span class="m">0</span><span class="n">x80000000</span><span class="p">)</span> <span class="p">||</span>
       <span class="p">(</span><span class="n">dwTTL</span> <span class="p">&gt;</span> <span class="n">dwTime</span> <span class="p">&amp;&amp;</span> <span class="p">(</span><span class="n">dwTTL</span> <span class="p">-</span> <span class="n">dwTime</span><span class="p">)</span> <span class="p">&gt;=</span> <span class="m">0</span><span class="n">x80000000</span><span class="p">))</span>
    <span class="p">{</span>
       <span class="cm">/* dwTTL &lt; dwTime ==&gt; message is not valid anymore ==&gt; discard it */</span>
       <span class="n">CAA_SET_RESULT</span><span class="p">(</span><span class="n">peError</span><span class="p">,</span> <span class="n">CMD_TTL_ERROR</span><span class="p">);</span>
       <span class="k">return</span> <span class="n">CMD_SND_NOT_OK</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="cm">/* copy message to chip */</span>
  <span class="cm">/* CAN ID: pBlock-&gt;cobId.X.ID*/</span>
  <span class="cm">/* RTR bit: pBlock-&gt;cobId.X.RTR */</span>
  <span class="cm">/* 29 bit: pBlock-&gt;cobId.X.EID */</span>
  <span class="cm">/* Data length: pBlock-&gt;byLen.X.DLC */</span>
  <span class="cm">/* Data pointer: &amp;pBlock-&gt;byData[0] */</span>
  <span class="cm">/* store the actual block for TX-IRQ handling */</span>
  <span class="n">xxxDriverContext</span><span class="p">[</span><span class="n">byDriver</span><span class="p">].</span><span class="n">hBlock</span> <span class="p">=</span> <span class="n">hBlock</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">CMD_SND_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Transmit Interrupt */</span>
<span class="k">if</span> <span class="p">(</span><span class="cm">/* Tx-IRQ */</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">hBlock</span> <span class="p">=</span> <span class="n">xxxDriverContext</span><span class="p">[</span><span class="n">byDriver</span><span class="p">].</span><span class="n">hBlock</span><span class="p">;</span>
  <span class="n">xxxDriverContext</span><span class="p">[</span><span class="n">byDriver</span><span class="p">].</span><span class="n">hBlock</span> <span class="p">=</span> <span class="n">CAA_hINVALID</span><span class="p">;</span>
  <span class="n">pBlock</span> <span class="p">=</span> <span class="n">MBM_MsgGetData</span><span class="p">(</span><span class="n">hBlock</span><span class="p">);</span>
  <span class="n">pBlock</span><span class="p">-&gt;</span><span class="n">dwTSP</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="cm">/* Set Timestamp to current time */</span>
  <span class="n">pInfo</span><span class="p">-&gt;</span><span class="n">ctMessagesSend</span><span class="p">++;</span>
  <span class="n">CL2_MsgSendAckn</span><span class="p">(</span><span class="n">byNet</span><span class="p">,</span> <span class="n">hBlock</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/* Rx Interrupt */</span>
<span class="k">if</span> <span class="p">(</span><span class="cm">/* Rx-IRQ */</span><span class="p">)</span>
<span class="c1">//…</span>
</pre></div>
</div>
</div>
<div class="section" id="drivers-without-txirq">
<h3>Drivers without TxIRQ<a class="headerlink" href="#drivers-without-txirq" title="Permalink to this headline">¶</a></h3>
<div class="line-block">
<div class="line">Drivers without Tx IRQ have to call MsgSendAcknNoIRQ directly from
CMD_Send if the message was set successfully ( CMD_Send returns
CMD_SND_OK and no error). If Tx Queue contains remaining messages,
then CL2 triggers further CMD_Send calls until all messages are
processed or CMD_Send signals that no further messages can be
processed (return value: CMD_SND_NOT_OK). In this case, CL2 will stop
sending messages until CL2_MsgSendAcknNoIRQ with CAA_hINVALID is
called from driver. Then the driver signals that sending may be
working again.</div>
<div class="line">Note: In CMD_Send implementation, you can call CL2.GetTxQueueLength
for retrieving the remaining number of Tx messages. This may be useful
if the driver wants to collect some messages first before sending it
to the chip (e.g. useful for gateway implementations where messages
are copied to Ethernet frames).</div>
</div>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">CAA_BOOL</span> <span class="nf">CMD_Send</span><span class="p">(</span><span class="n">CL2I_BYTE</span> <span class="n">byNet</span><span class="p">,</span> <span class="n">CAA_HANDLE</span> <span class="n">hBlock</span><span class="p">,</span> <span class="n">CL2I_BYTE</span> <span class="n">byPrio</span><span class="p">,</span> <span class="n">CAA_ERROR</span><span class="p">*</span> <span class="n">peError</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">CAA_BYTE</span> <span class="n">byDriver</span> <span class="p">=</span> <span class="n">s_byDriver</span><span class="p">[</span><span class="n">byNet</span><span class="p">];</span>
  <span class="n">CL2I_INFO</span><span class="p">*</span> <span class="n">pInfo</span> <span class="p">=</span> <span class="n">s_pInfo</span><span class="p">[</span><span class="n">byDriver</span><span class="p">];</span>
  <span class="n">CL2I_BLOCK</span><span class="p">*</span> <span class="n">pBlock</span> <span class="p">=</span> <span class="p">(</span><span class="n">CL2I_BLOCK</span><span class="p">*)</span><span class="n">CAL_CL2_MsgGetData</span><span class="p">(</span><span class="n">hBlock</span><span class="p">);</span>
  <span class="n">CAA_SET_RESULT</span><span class="p">(</span><span class="n">peError</span><span class="p">,</span> <span class="n">CMD_NO_ERROR</span><span class="p">);</span>
  <span class="cm">/* … */</span>
  <span class="cm">/* check TTL for SIL2 */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">pBlock</span><span class="p">-&gt;</span><span class="n">dwTSP</span> <span class="p">!=</span> <span class="m">0</span><span class="p">)</span>
  <span class="p">{</span>
     <span class="cm">/* check TTL */</span>
     <span class="n">RTS_SYSTIME</span> <span class="n">time</span><span class="p">;</span>
     <span class="n">CAA_DWORD</span> <span class="n">dwTime</span><span class="p">,</span> <span class="n">dwTTL</span><span class="p">;</span>
     <span class="n">CAL_SysTimeGetUs</span><span class="p">(&amp;</span><span class="n">time</span><span class="p">);</span>
     <span class="n">dwTime</span> <span class="p">=</span> <span class="p">(</span><span class="n">CAA_DWORD</span><span class="p">)</span><span class="n">time</span><span class="p">;</span>
     <span class="n">dwTTL</span> <span class="p">=</span> <span class="n">pBlock</span><span class="p">-&gt;</span><span class="n">dwTSP</span><span class="p">;</span>
     <span class="k">if</span> <span class="p">((</span><span class="n">dwTTL</span> <span class="p">&lt;</span> <span class="n">dwTime</span> <span class="p">&amp;&amp;</span> <span class="p">(</span><span class="n">dwTime</span> <span class="p">-</span> <span class="n">dwTTL</span><span class="p">)</span> <span class="p">&lt;</span> <span class="m">0</span><span class="n">x80000000</span><span class="p">)</span> <span class="p">||</span> <span class="p">(</span><span class="n">dwTTL</span> <span class="p">&gt;</span> <span class="n">dwTime</span> <span class="p">&amp;&amp;</span> <span class="p">(</span><span class="n">dwTTL</span> <span class="p">-</span> <span class="n">dwTime</span><span class="p">)</span> <span class="p">&gt;=</span> <span class="m">0</span><span class="n">x80000000</span><span class="p">))</span>
     <span class="p">{</span>
       <span class="cm">/* dwTTL &lt; dwTime ==&gt; message is not valid anymore ==&gt; discard it */</span>
       <span class="n">CAA_SET_RESULT</span><span class="p">(</span><span class="n">peError</span><span class="p">,</span> <span class="n">CMD_TTL_ERROR</span><span class="p">);</span>

       <span class="k">return</span> <span class="n">CMD_SND_NOT_OK</span><span class="p">;</span>
     <span class="p">}</span>
  <span class="p">}</span>
  <span class="cm">/* copy message to chip */</span>
  <span class="cm">/* CAN ID: pBlock-&gt;cobId.X.ID*/</span>
  <span class="cm">/* RTR bit: pBlock-&gt;cobId.X.RTR */</span>
  <span class="cm">/* 29 bit: pBlock-&gt;cobId.X.EID */</span>
  <span class="cm">/* Data length: pBlock-&gt;byLen.X.DLC */</span>
  <span class="cm">/* Data pointer: &amp;pBlock-&gt;byData[0] */</span>
  <span class="n">error</span> <span class="p">=</span> <span class="n">CAN_Write</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
  <span class="p">{</span>
     <span class="n">xxxDriverContext</span><span class="p">[</span><span class="n">byDriver</span><span class="p">].</span><span class="n">bTxError</span> <span class="p">=</span> <span class="n">CAA_TRUE</span><span class="p">;</span>
     <span class="cm">/* We have to call MsgSendAcknNoIRQ with CAA_hINVALID later on!*/</span>
     <span class="k">return</span> <span class="n">CMD_SND_NOT_OK</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span>
     <span class="n">pInfo</span><span class="p">-&gt;</span><span class="n">ctMessagesSend</span><span class="p">++;</span>
     <span class="n">CAL_CL2_MsgSendAcknNoIRQ</span><span class="p">(</span><span class="n">byNet</span><span class="p">,</span> <span class="n">hBlock</span><span class="p">);</span>
     <span class="k">return</span> <span class="n">CMD_SND_OK</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* the function which polls the chip for received messages */</span>
<span class="k">static</span> <span class="k">void</span> <span class="nf">xxxRxHandler</span><span class="p">(</span><span class="k">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">each</span> <span class="n">CAN</span> <span class="n">Driver</span> <span class="n">context</span><span class="p">)</span>
  <span class="p">{</span>
     <span class="cm">/* process Rx messages */</span>
     <span class="cm">/* … */</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">xxxDriverContext</span><span class="p">[</span><span class="n">byDriver</span><span class="p">].</span><span class="n">bTxError</span><span class="p">)</span>
     <span class="p">{</span>
       <span class="cm">/* In case of a tx error, we try to empty the Tx Queue here.</span>
<span class="cm">        * This is just an example. MsgSendAckn may be also called from another</span>
<span class="cm">        * method. E.g. if the hardware offers the possibility getting an event</span>
<span class="cm">        * when sending becomes possible again. */</span>
       <span class="n">xxxDriverContext</span><span class="p">[</span><span class="n">byDriver</span><span class="p">].</span><span class="n">bTxError</span> <span class="p">=</span> <span class="n">CAA_FALSE</span><span class="p">;</span>
       <span class="n">CAL_CL2_MsgSendAcknNoIRQ</span><span class="p">(</span><span class="n">s_byNet</span><span class="p">[</span><span class="n">byDriver</span><span class="p">],</span> <span class="n">CAA_hINVALID</span><span class="p">);</span>
     <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="receiving-messages">
<h2>Receiving Messages<a class="headerlink" href="#receiving-messages" title="Permalink to this headline">¶</a></h2>
<p><img alt="image11" src="../../_images/image11.png" /></p>
<p>Figure 11: Message receiving</p>
<div class="line-block">
<div class="line">When a driver receives a message from chip, it allocates an Rx Handle
from CL2 by calling MsgAlloc for the specific network. Then the driver
copies all message data from chip (usually done in a function called
CMD_Receive) and passes the message to CL2 by calling MsgPutRQueue. If
someone is interested in this message, CL2 will send it to the Rx
Queue.</div>
<div class="line">Note: The interface function CMD_Receive is not used by CL2. It may be
used internally by the CANMiniDriver for copying the message data, but
it can be also left blank.</div>
</div>
<div class="line-block">
<div class="line">Example:</div>
<div class="line">Rx IRQ Handler or Rx receive task:</div>
</div>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="k">new</span> <span class="n">message</span> <span class="n">received</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">hBlock</span> <span class="p">=</span> <span class="n">CAL_CL2_MsgAlloc</span><span class="p">(</span><span class="n">s_byNet</span><span class="p">[</span><span class="n">byDriver</span><span class="p">],</span> <span class="n">CAA_pNULL</span><span class="p">);</span>
  <span class="n">CL2I_BLOCK</span><span class="p">*</span> <span class="n">pBlock</span> <span class="p">=</span> <span class="p">(</span><span class="n">CL2I_BLOCK</span><span class="p">*)</span><span class="n">CAL_CL2_MsgGetData</span><span class="p">(</span><span class="n">hBlock</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">pBlock</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="cm">/* copy message data */</span>
    <span class="n">pBlock</span><span class="p">-&gt;</span><span class="n">byLen</span><span class="p">.</span><span class="n">B</span> <span class="p">=</span> <span class="n">byLen</span><span class="p">;</span>
    <span class="n">pBlock</span><span class="p">-&gt;</span><span class="n">byNet</span> <span class="p">=</span> <span class="n">byNet</span><span class="p">;</span>
    <span class="n">pBlock</span><span class="p">-&gt;</span><span class="n">dwTSP</span> <span class="p">=</span> <span class="n">CAL_SysTimeGetMs</span><span class="p">();</span>
    <span class="n">pBlock</span><span class="p">-&gt;</span><span class="n">cobId</span><span class="p">.</span><span class="n">D</span> <span class="p">=</span> <span class="n">dwId</span><span class="p">;</span>
    <span class="n">pBlock</span><span class="p">-&gt;</span><span class="n">cobId</span><span class="p">.</span><span class="n">X</span><span class="p">.</span><span class="n">EID</span> <span class="p">=</span> <span class="n">xType</span><span class="p">;</span>
    <span class="n">pBlock</span><span class="p">-&gt;</span><span class="n">cobId</span><span class="p">.</span><span class="n">X</span><span class="p">.</span><span class="n">RTR</span> <span class="p">=</span> <span class="n">xRtr</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">message</span> <span class="n">copy</span> <span class="n">successful</span><span class="p">)</span>
    <span class="p">{</span>
       <span class="n">s_pInfo</span><span class="p">[</span><span class="n">s_byDriver</span><span class="p">[</span><span class="n">byNet</span><span class="p">]]-&gt;</span><span class="n">ctMessagesReceived</span><span class="p">++;</span>
       <span class="n">CAL_CL2_MsgPutRQueue</span><span class="p">(</span><span class="n">s_byNet</span><span class="p">[</span><span class="n">byDriver</span><span class="p">],</span> <span class="n">hBlock</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
       <span class="n">CAL_CL2_MsgFree</span><span class="p">(</span><span class="n">hBlock</span><span class="p">);</span>
       <span class="n">s_pInfo</span><span class="p">[</span><span class="n">s_byDriver</span><span class="p">[</span><span class="n">byNet</span><span class="p">]]-&gt;</span><span class="n">ctDataOverruns</span><span class="p">++;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span>
       <span class="n">s_pInfo</span><span class="p">[</span><span class="n">s_byDriver</span><span class="p">[</span><span class="n">byNet</span><span class="p">]]-&gt;</span><span class="n">ctDataOverruns</span><span class="p">++;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="cmd-dispose-driver-close">
<h2>CMD_Dispose: Driver Close<a class="headerlink" href="#cmd-dispose-driver-close" title="Permalink to this headline">¶</a></h2>
<p><img alt="image12" src="../../_images/image12.png" /></p>
<p>Figure 12: Driver close</p>
<p>If the last driver handle for a specific network is closed by the
application, CL2 calls CMD_Dispose and the driver has to deinitialize
the chip.</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">CAA_ERROR</span> <span class="nf">CMD_Dispose</span><span class="p">(</span><span class="n">CL2I_BYTE</span> <span class="n">byNet</span><span class="p">)</span>
<span class="p">{</span>
  <span class="cm">/* deinitialize chip */</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="canminidriver_interface_optional_functions.html" title="Optional Functions"
             >next</a> |</li>
        <li class="right" >
          <a href="canminidriver_interface.html" title="6.3.8.2. CANMiniDriver interface"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">RuntimeSystemDocumentation V3.5.16.40</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >6. Tutorials / HowTos</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" >6.3.8. CANMiniDriver for CODESYS V3</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="canminidriver_interface.html" >6.3.8.2. CANMiniDriver interface</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020, 3S-Smart Software Solutions GmbH. This document is confidential. Unauthorized copying, disclosure or distribution of this document and the information contained herein is strictly forbidden.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.2.1.
    </div>
  </body>
</html>